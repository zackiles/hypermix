<repomix>This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.ts, README.md, examples/**/**, **/*
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)</notes><additional_info><user_provided_header>CRITICAL: This contains a snapshot of the entire codebase. It was manually generated and may be slightly out of date and/or inaccurate. It can be generated again with the command `hypermix`</user_provided_header></additional_info></file_summary><directory_structure>.cursor/
  rules/
    global/
      create-checklist.mdc
      find-missing-tests.mdc
      with-composition.mdc
      with-deno-stdlib.mdc
      with-javascript.mdc
      with-technical-writing.mdc
      with-typescript.mdc
.github/
  workflows/
    release-jsr.yml
    release.yml
    validate.yml
.hypermix/
  @std/
    testing.xml
  anthropics/
    sdk-examples.xml
    sdk.xml
  openai/
    sdk-examples.xml
  vercel/
    ai.xml
  YieldRay/
    json-rpc-ts.xml
examples/
  hypermix.config.jsonc
  hypermix.config.ts
scripts/
  build.ts
  serve-docs.ts
  tag.ts
src/
  add-tasks.ts
  constants.ts
  load-config.ts
  mod.ts
  types.ts
test/
  add-tasks.test.ts
  cli-args.test.ts
  error-recovery.test.ts
  github-url.test.ts
  ignore-files.test.ts
  load-config.test.ts
  output-file-verification.test.ts
  repomix-command.test.ts
  repomix-config-resolution.test.ts
  test-utils.ts
  token-counting.test.ts
.cursorignore
.cursorignoreindex
.gitignore
deno.json
deno.lock
LICENSE
README.md
repomix.config.json</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".cursor/rules/global/create-checklist.mdc">---
description:
globs:
alwaysApply: false
---
# Task: Write an Implementation Checklist at `&lt;project-root&gt;/.ai/planning/&lt;name-of-feature&gt;-checklist.md`

You will review the shown or mentioned proposal, feature, solution, or TODO and follow the steps below to create an implementation plan that includes the phases and checklist of steps for each phase.

## Steps To Create An Implementation Plan

### 1) **Prepare and Understand**

Review the TODO or proposal, other related context the user provided to understand what needs to be done to implement the proposal or solution

### 2) **Read the Code**

Analyze the full and complete code involved and their dependencies to build a deep, accurate, and precise understanding of all the code and tests involved with the TODO and the code needed to implement the TODO

### 3) **Create the Implementation Plan**

Create a new markdown checklist file for this TODO at
`&lt;project-root&gt;/.ai/planning/&lt;name-of-feature&gt;-checklist.md`.

#### 3.1) Include required metadata at the top

- Current date and time (e.g., `2025-05-13 09:14 EDT`)
- Short summary of the intended change (1–2 sentences)

#### 3.2) Define high-level implementation phases

Each phase MUST include:

- A short description explaining the purpose of the phase
- A numbered list of task steps using markdown checkboxes
- Clear action verbs for each step
- Tasks broken into discrete, testable units

#### 3.3) Add appendix section

Appendix must include:

* Inline pseudocode samples for critical functions
* Key references (e.g., RFCs, specs, related PRs)
* Configuration or environment details that impact implementation

#### 3.4) Write summary section

End the markdown file with a `## Summary` section.

Content must:

* Restate the high-level goal and purpose of the TODO
* Tell the reader to complete each phase in order
* Instruct the reader to mark steps complete before continuing
* Emphasize test validation before advancing to the next phase
* Explain that the reader can choose when to write tests:
  * a) After all phases are complete
  * b) After each phase
* Recommend selecting option a or b based on project risk and complexity

### 4) Finish Your Task

After the implementation checklist is complete, end your turn by responding to the user with only the path or link to the checklist you created for their review. Do NOT respond with the full markdown file in the chat.

## Example Of Phases and Steps

A hypothetical example of a general template specifically for the phases and steps.

```md
### 1) Refactor Utilities
Refactor and consolidate shared utilities from `old-codebase/src/helpers/`, `old-codebase/src/common/`, and `old-codebase/src/utils/` into a unified `new-codebase/src/shared/` directory for Deno 2.

#### 1.1) Identify Duplicate Logic
- [ ] Audit files in `old-codebase/src/helpers`, `old-codebase/src/common`, and `old-codebase/src/utils`
- [ ] Highlight overlap in functionality
- [ ] Propose which file should be canonical source for Deno 2 port

#### 1.2) Migrate and Delete Duplicates
- [ ] Move canonical utilities to `new-codebase/src/shared/`
- [ ] Convert CommonJS/Node idioms to ES module Deno-compatible syntax
- [ ] Update imports in migrated files using Deno-compatible `import` paths
- [ ] Remove deprecated or obsolete utility files in old codebase

### 2) Replace HTTP Client Library
Swap `axios` from `old-codebase` with Deno-native `fetch` in `new-codebase` to reduce external dependencies and simplify networking.

#### 2.1) Inventory Current Usage
- [ ] List all files in `old-codebase` importing or requiring `axios`
- [ ] Identify patterns such as `axios.create`, interceptors, or custom headers

#### 2.2) Replace API Calls
- [ ] Replace GET requests with native `fetch`
```

## Final Notes

- Main phases have short descriptions of the phase
- Phases are numbered in order of when they should be implemented
- Steps are specific, technical, and concise
- Steps are numbered in order of when they should be implemented within their given phase
- Steps include checkboxes
- **IMPORTANT**: For large or complicated phases, encourage the reader to run the tests one they&apos;re finished implementing that phase before they move on to the next phase. Leave a note in the phase&apos;s description warning them to so it draws the readers attention.

## Summary

Following these steps will ensure you write a complete and comprehensive implementation plan that walks an engineer through the step-by-step completion and implementation of the specified TODO. Review your work, double-check code samples are accurate, and always check the full source files of code and test files that the implementation would have to modify to ensure you understand the impacts of changing it.</file><file path=".cursor/rules/global/find-missing-tests.mdc">---
description:
globs:
alwaysApply: false
---
# Prompt: Identify Critical Missing Tests

## Objective

Review the **code files shown** in the same message and propose the most critical missing tests so the test suite fully protects user-facing contracts and likely real-world scenarios.

## Inputs

* One or more source-code files provided as attachments to this prompt.

## Requirements

* Focus on functionality that directly affects user or consumer experience.
* Evaluate explicit contracts (public APIs, documented behaviors) and implicit contracts (common usage patterns, error handling, performance assumptions).
* Prioritize tests by **likelihood of occurrence** × **impact of failure**.
* Output a **numbered list** sorted from **most** to **least** important.
* For each list item include:

  * **Level** – one of `critical`, `high`, `medium`.
  * **Scenario** – concise description of what the test covers.
  * **Notes** – bullet-point tips for the implementor (setup hints, edge cases, data variations).

## Instructions

1. Read every attached file and infer the intended public behavior and side-effects.
2. Map out user journeys and typical integration paths.
3. Detect untested branches, error cases, race conditions, and contract guarantees.
4. Score each potential test on likelihood and impact; assign `critical`, `high`, or `medium`.
5. List only the top tests that provide the highest risk reduction; omit trivial or redundant cases.
6. Present the final answer strictly in the numbered list format described above—no extra commentary.</file><file path=".cursor/rules/global/with-composition.mdc">---
description:
globs: *.ts,*.js,*.jsx,*.tsx
alwaysApply: false
---
# Code SHOULD Follow &quot;Composition of Concerns&quot;

Structure and compose files, folders, modules, classes, methods, and interactions using &quot;Composition of Concerns&quot; instead of &quot;Seperation of Concerns&quot;, while continually balancing the need to remain DRY and maintaining simple abstractions with intuitive consumer interfaces.

&gt; **Goal:** Embrace **composition over separation** by grouping tightly related behavior and state into cohesive backend-friendly units. This guide highlights JavaScript/TypeScript-native idioms for building high-cohesion modules, without unnecessary indirection, especially suited for APIs, CLIs, workers, or services.

---

## 1. Encapsulated Service via Closure

**Use when:** You want private internal state and controlled method exposure without using `class`.

```js
function createAuthService() {
  let token = null
  return {
    login(user, pass) {
      token = Buffer.from(`${user}:${pass}`).toString(&apos;base64&apos;)
    },
    isAuthenticated() {
      return !!token
    },
    getToken() {
      return token
    }
  }
}
````

---

## 2. Class with Private Fields

**Use when:** You need a stateful object with strict encapsulation and reusable methods.

```js
class RateLimiter {
  #requests = new Map()

  check(ip) {
    const now = Date.now()
    const window = 60000
    const count = this.#requests.get(ip) || []
    const recent = count.filter(ts =&gt; now - ts &lt; window)
    recent.push(now)
    this.#requests.set(ip, recent)
    return recent.length &lt;= 100
  }
}
```

---

## 3. Closure-Based Module Pattern

**Use when:** You want composable singletons for CLI tools, daemons, or backend modules.

```js
function createConfig() {
  let settings = {}
  return {
    load(path) {
      settings = JSON.parse(Deno.readTextFileSync(path))
    },
    get(key) {
      return settings[key]
    }
  }
}
```

---

## 4. Reducer-Driven Domain Handler

**Use when:** You want pure-function command handlers for domain logic.

```js
function accountReducer(state, action) {
  switch (action.type) {
    case &apos;credit&apos;:
      return { ...state, balance: state.balance + action.amount }
    case &apos;debit&apos;:
      return { ...state, balance: state.balance - action.amount }
    default:
      return state
  }
}
```

---

## 5. Schema-Like Validation with Embedded Logic

**Use when:** You want to enforce domain rules at the boundary of data entry.

```js
function validatePayload(payload) {
  if (typeof payload.user !== &apos;string&apos;) throw new Error(&apos;Invalid user&apos;)
  if (typeof payload.amount !== &apos;number&apos;) throw new Error(&apos;Invalid amount&apos;)
  if (payload.amount &lt;= 0) throw new Error(&apos;Amount must be positive&apos;)
  return payload
}
```

---

## 6. Namespaced Domain Utilities

**Use when:** You want to group all domain-specific operations under one object.

```js
const Email = {
  validate(address) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(address)
  },
  normalize(address) {
    return address.trim().toLowerCase()
  }
}
```

---

## 7. Object with Stateful Behavior

**Use when:** You want a composable module to wrap configuration or environment state.

```js
const Env = {
  vars: {},
  load() {
    this.vars = Object.fromEntries(Deno.env.toObject())
  },
  get(name) {
    return this.vars[name]
  }
}
```

---

## 8. Higher-Order Function Wrappers

**Use when:** You want to inject cross-cutting concerns into services (logging, auth, timing).

```js
function withTiming(fn) {
  return async (...args) =&gt; {
    const start = Date.now()
    const result = await fn(...args)
    const duration = Date.now() - start
    console.log(`Execution took ${duration}ms`)
    return result
  }
}

async function fetchData() {
  await new Promise(r =&gt; setTimeout(r, 50))
  return &apos;done&apos;
}

const timedFetch = withTiming(fetchData)
```

---

## 🕸 Lazy Init Singleton Pattern

**Use when:** You want to defer resource setup (DB, HTTP client) until first usage.

```js
const DB = (() =&gt; {
  let conn
  return {
    connect(config) {
      if (!conn) {
        conn = { url: config.url, status: &apos;connected&apos; } // placeholder
      }
    },
    query(sql) {
      if (!conn) throw new Error(&apos;DB not connected&apos;)
      return `Running ${sql} on ${conn.url}`
    }
  }
})()
```

---

## 10. File Co-location + Barrel Exports

**Use when:** You want to organize service internals without scattering files across folders.

```
user/
├── index.js
├── schema.js
├── repository.js
├── commands.js
```

**`index.js`**

```js
export * from &apos;./schema&apos;
export * from &apos;./repository&apos;
export * from &apos;./commands&apos;
```

---

## Summary: Backend Composition Patterns

| Pattern                 | When to Use                                            |
| ----------------------- | ------------------------------------------------------ |
| Closure-Based Service   | Stateful module with private logic                     |
| Class w/ Private Fields | Persistent state + enforced boundaries                 |
| Reducer Functions       | Pure transformations for commands                      |
| Validation at Entry     | Enforce contract rules alongside logic                 |
| Utility Namespaces      | Group domain concerns under single interface           |
| Stateful Objects        | Config/env/resource managers                           |
| HOFs                    | Decorators for cross-cutting logic                     |
| Lazy Singleton Init     | Deferred resource wiring (DB, API clients)             |
| Barrel Exports          | Keep related modules physically + semantically grouped |</file><file path=".cursor/rules/global/with-deno-stdlib.mdc">---
description: Import Errors
globs:
alwaysApply: false
---

# Steps To Resolving Import Errors

Follow these step by step, and in the order they&apos;re shown until the issue is resolved:

1. **Check `deno.jsonc` Imports**: import map shows installed libraries in
   format of `&quot;@std/fs&quot;: &quot;jsr:@std/fs@1&quot;`. If not installed,
   `deno add {jsr:@std/fs@1}` and import it with &apos;import { expandGlob } from
   &apos;std/fs@1&apos;`.
2. Libraries in `@std/` with `/unstable-*` in name have to be imported
   explicitly:

```ts
import { multiPromptSelect } from &apos;@std/cli/unstable-prompt-select`
```

3. NO imports from URLs or registry paths. `Deno add` install instead and use
   the short name. Examples:

- GOOD: `import { parse } &apos;@std/jsonc&apos;`
- BAD: `import { parse } &apos;jsr:@std/jsonc&apos;`
- GOOD: `import { ulid } &apos;@std/ulid&apos;`
- BAD: `import { ulid } &apos;jsr:@std/ulid&apos;`
- GOOD: `import * as jose from &apos;jose&apos;`
- BAD: `import * as jose from &apos;npm:jose&apos;`

4. **Use Deno Tools to Debug the Issue**:

- LOCAL JSR package:
  `deno info --json | jq &apos;.modules[] | select((.specifier | tostring) | test(&quot;^@std/cli$&quot;))&apos;`
- REMOTE JSR package:
  `deno info --json | jq &apos;.modules[] | select((.specifier | tostring) | test(&quot;^(jsr:|https://jsr.io/)@std/cli&quot;))&apos;`
- LOCAL **or** REMOTE JSR package:
  `deno info --json | jq &apos;.modules[] | select((.specifier | tostring) | test(&quot;(@std/cli|jsr:@std/cli|jsr.io/@std/cli)&quot;))&apos;`
- LOCAL Deno **file**: `deno info {example_name}.ts`
- LOCAL NPM package: `deno types npm:your-lib`
- UNKNOWN location of package: `deno info --json | jq &apos;.modules[] |
  select((.specifier | tostring) | test(&apos;package alias&apos;))&apos;</file><file path=".cursor/rules/global/with-javascript.mdc">---
description:
globs: *.md,*.ts
alwaysApply: false
---
## How You Write Clean Code
The following is a style guide of important styles and patterns you MUST enforce when writing code in `&lt;project-root&gt;new-codebase/`.

## Code Style Guidelines

- **Inline Comments**: Avoid inline comments unless they SIGNIFICANTLY improve the understanding of the code they&apos;re commenting on
  - **IMPORTANT**: No comments for code that is easily understood!
- **Formatting**: 2 spaces indentation, 120 char line width, single quotes, no semicolons
- **Imports**: Use `jsr:` specifier for JSR packages, `import type` for types, and `@std/` for Deno standard libraries
- **Exports**: Declared separately at the bottom of files to make it easy to quickly see what a module exports. Example:
  ```ts
  const someFunction = () =&gt; {}
  const someOtherFunction = () =&gt; {}

  // GOOD: Exports declared separately at the bottom
  export { someFunction, someOtherFunction}
  ```
- **TypeScript**:
  - Strict type checking
  - Explicit return types
  - Prefer utility types over interfaces
  - Avoid unnecessary types
  - Reuse and/or modify types that already exist from the project, native Deno types, or types from installed packages instead of creating new types
- **Error Handling**: Use `try/catch` for async operations, avoid deeply nested error handling
- **Dependencies**: Use `deno add` to manage dependencies, prefer `@std/` libraries for common tasks
- **File Structure**: Keep files under 250 lines, organize by feature, use `src/` for source code and `test/` for tests
- **Testing**: Use `@std/assert` and `@std/testing`
  - Simple tests, low to medium test coverage unless explicitly asked to create comprehensive test coverage
  - Descriptive test names
  - Arrange/act/assert pattern
  - Simple mocks whenever possible
  - Share test utilities instead of repeating functionality in test files
- **Expression-Oriented Imperative Style**: Favor concise, expression-based logic over step-by-step mutations, seeing transformations as value flows.
- **Imperative Clarity with Functional Lean**: Handle edge cases early, perform I/O or logging before transformations, then chain pure operations.

**IMPORTANT**: See `.cursor/rules/with-javascript.mdc` and `.cursor/rules/with-typescript.mdc` for full coding standards.

## Naming Conventions

- **kebab-case**: File and folder names
- **PascalCase**: Classes, interfaces, types
- **camelCase**: Variables, functions, methods
- **UPPER_SNAKE_CASE**: Constants
- **Test files**: `[filename].test.ts`


### 🧭 **Expression-Oriented Imperative Style**

#### ✅ Principle: Write logic as **expressions**, not **procedures**, when clarity permits

Favor concise, expression-based logic over step-by-step mutations, seeing transformations as value flows.

#### ✅ Guidelines

* Collapse trivial branches into ternary or nullish coalescing expressions.
* Prefer `const x = condition ? a : b` or `const y = value ?? default` over multiple statements.
* Inline single-use variables if they clarify dataflow without obscuring context.

#### ✅ Examples

```ts
const ext = filename.includes(&apos;.&apos;) ? filename.split(&apos;.&apos;).pop()! : &apos;txt&apos;
```

```ts
const timeoutMs = config.timeout ?? 5000
```

```ts
const validEmails = users.filter(u =&gt; u.isActive).map(u =&gt; u.email)
```

```ts
const outputFile = args.output ?? `${inputFile}.out`
```

---

### 🧭 **Imperative Clarity with Functional Lean**

#### ✅ Principle: Read top-to-bottom with guard clauses, minimal mutation, and isolated side effects

Handle edge cases early, perform I/O or logging before transformations, then chain pure operations.

#### ✅ Guidelines

* Use guard clauses (`if (!cond) return`) instead of nested blocks.
* Localize side effects at the top of functions.
* Chain pure transformations once state is validated.

#### ✅ Examples

```ts
function resolveBasePath(mod?: string): string {
  if (!mod) {
    console.warn(&apos;No module; falling back to cwd&apos;)
    return Deno.cwd()
  }
  const path = mod.startsWith(&apos;file:&apos;) ? fromFileUrl(mod) : mod
  return join(dirname(path), &apos;..&apos;)
}
```

```ts
function toUpperName(name?: string): string {
  if (!name) return &apos;&apos;
  const trimmed = name.trim()
  return trimmed.toUpperCase()
}
```

---

## 🦕 Deno 2 + TypeScript Syntax-Focused Clean Code Patterns

### 🧭 **Explicit Imports with Named Specifiers**

#### ✅ Principle: Use bare specifier imports for clarity and discoverability

Leverage import maps and JSR to keep imports short, predictable, and syntax-consistent.

#### ✅ Guidelines

* Prefer `import { join } from &apos;@std/path/join&apos;` over deep relative paths.
* Avoid `../`-heavy chains via import map aliases.
* Group standard library, JSR, and local imports separately.

#### ✅ Example

```ts
import { join } from &apos;@std/path/join&apos;
import { parseArgs } from &apos;@std/cli/parse-args&apos;
import { getConfig } from &apos;@/config&apos;
```

---

### 🧭 **Top-Level `await` with Clear Entry Semantics**

#### ✅ Principle: Use top-level `await` to start runtime logic without wrappers

Deno supports top-level `await`; embrace it for clean initialization.

#### ✅ Guidelines

* Write startup scripts as top-level modules; no `main()` boilerplate.
* Use `import.meta.main` with direct logic for clarity.

#### ✅ Example

```ts
import { expandGlob } from &apos;@std/fs&apos;

if (import.meta.main) {
  for await (const file of expandGlob(&apos;src/**/*.ts&apos;)) {
    console.log(file.path)
  }
}
```

---

### 🧭 **Dynamic Module Resolution with `import.meta`**

#### ✅ Principle: Use `import.meta.url` and `fromFileUrl` for module-aware paths

Replace brittle `__dirname` patterns with built-in primitives.

#### ✅ Guidelines

* Use `import.meta.url` to discover file URLs.
* Convert via `fromFileUrl()` when needing OS paths.

#### ✅ Example

```ts
import { fromFileUrl, join } from &apos;@std/path&apos;

const dir = join(fromFileUrl(import.meta.url), &apos;..&apos;)
```

---

### 🧭 **Cross-Platform Path Handling with `@std/path`**

#### ✅ Principle: Normalize paths with utility functions

Never assume POSIX-style slashes; use library functions for join/resolve.

#### ✅ Guidelines

* Use `join()`, `resolve()`, and `dirname()` from `@std/path`.
* Avoid string concatenation for file paths.

#### ✅ Example

```ts
import { join, dirname, fromFileUrl } from &apos;@std/path&apos;

const configPath = join(dirname(fromFileUrl(import.meta.url)), &apos;config.json&apos;)
```

---

### 🧭 **Idiomatic CLI Argument Handling with `@std/cli`**

#### ✅ Principle: Parse flags declaratively with `parseArgs` from `@std/cli/parse-args` ([Deno][1])

Define types, defaults, aliases, and collectable options in one call.

#### ✅ Guidelines

* Import `parseArgs` from `&apos;@std/cli/parse-args&apos;`.
* Specify `boolean`, `string`, `negatable`, `collect`, `alias`, and `default` in options.
* Destructure the returned object for clarity.

#### ✅ Example

```ts
import { parseArgs } from &apos;@std/cli/parse-args&apos;

const { verbose = false, port = 8080, _: files } = parseArgs(Deno.args, {
  boolean: [&apos;verbose&apos;],
  string: [&apos;port&apos;],
  default: { port: 8080 },
  alias: { v: &apos;verbose&apos;, p: &apos;port&apos; },
})

if (verbose) console.log(&apos;Files to process:&apos;, files)
```

---

### 🧭 **Use Native `Deno.` APIs Directly in Expressions**

#### ✅ Principle: Lean on built-in globals for conciseness

Avoid wrappers for one-off I/O or env access when inline calls suffice.

#### ✅ Guidelines

* Inline expressions using `await Deno.readTextFile()`, `Deno.env.get()`, etc.
* Avoid over-abstracting trivial API usage.

#### ✅ Example

```ts
const token = (await Deno.readTextFile(&apos;auth.txt&apos;)).trim()
```

[1]: https://docs.deno.com/examples/command_line_arguments/ &quot;Command line arguments - Deno Docs&quot;

### 🧭 **Method Chaining for Fluent Transformations**

#### ✅ Principle: Compose operations via **chained calls** for linear dataflow

#### ✅ Guidelines

* Link array transforms (`.filter`, `.map`, `.reduce`) into single expressions.
* Chain promise handlers (`.then`, `.catch`, `.finally`) for sequential async logic.
* Use chaining on APIs that expose fluent interfaces.

#### ✅ Examples

```ts
const emails = users
  .filter(u =&gt; u.isActive)
  .map(u =&gt; u.email)
  .join(&quot;;&quot;)
```

```ts
fetch(url)
  .then(res =&gt; res.json())
  .then(data =&gt; process(data))
  .catch(err =&gt; console.error(err))
```

```ts
new TextDecoder()
  .decode(await Deno.readFile(path))
  .trim()
  .split(&quot;\n&quot;)
```

### 🧭 **Hoist Repetitive Logic via Inline Arrow Helpers**

#### ✅ Principle: Keep top-level functions lean by **hoisting repeated steps** as inner arrow functions

#### ✅ Guidelines

* Define inline arrow helpers at function start for repeated transformations.
* Use hoisted helpers to eliminate duplicate code within orchestration.
* Place main orchestration and error handling at bottom for clear flow.

#### ✅ Examples

```ts
import { join } from &quot;@std/path/join&quot;

export async function buildReports(paths: string[]) {
  const read   = (p: string) =&gt; Deno.readTextFileSync(p)
  const parse  = (s: string)   =&gt; JSON.parse(s) as Report
  const format = (r: Report)   =&gt; `${r.id}: ${r.title}`

  try {
    const reports = paths
      .map(read)
      .map(parse)
      .map(format)
    console.log(&quot;Reports&quot;, reports)
  } catch (error) {
    console.error(&quot;Failed to build reports&quot;, error)
  }
}
```

```ts
export async function deploy() {
  const fetchConfig = () =&gt; Deno.readTextFile(&quot;config.json&quot;).then(JSON.parse)
  const pack        = () =&gt; Deno.readFile(&quot;app.bundle&quot;)
  const upload      = (data: Uint8Array) =&gt; Deno.writeFile(&quot;remote.pkg&quot;, data)

  try {
    const cfg    = await fetchConfig()
    const bundle = await pack()
    await upload(bundle)
    console.log(&quot;Deployed&quot;, cfg.env)
  } catch (err) {
    console.error(&quot;Deploy error&quot;, err)
  }
}
```

## Summary
This style guide promotes a clean, expression-oriented approach to Deno 2 + TypeScript that emphasizes clarity through compactness, reducing visual and cognitive noise. The goal is to write code that reads linearly, minimizes ceremony, and expresses logic as value transformations rather than imperative steps. By organizing setup and configuration at the top of functions and keeping orchestration flat and focused, it balances brevity with maintainability—favoring readable, minimal, and purposefully structured code over abstract or verbose patterns.

## IMPORTANT
- Avoid inline comments in code that is easily understood or refers to this style guide. Always cleanup dead code, bad comments, or code that doesn&apos;t adhere to this style guide
- If you see code comments that don&apos;t adhere to these rules FIX or REMOVE them!</file><file path=".cursor/rules/global/with-technical-writing.mdc">---
description:
globs:
alwaysApply: false
---
# How to Write Documentation

**DANGER**: You must follow the rules in `Style and Prose`, and `Format and Output` when doing the following:

1. Writing or editing documentation
2. Responding technically or on a technical topic to the user
3. Reviewing or proposing changes to documentation

## Style and Prose

- Sentences using the dependency grammar framework instead of phrase structure grammar
- Sentences should be brief and action-oriented
- Sentence-style capitalization and serial commas consistently
- Subject-verb-object order for clarity and rhythm
- Clear and active constructions
- Verbs instead of nominalized nouns
- Specific nouns and clear referents to eliminate ambiguity
- Plain language or clearly explains necessary jargon
- Consistent grammatical structure across headings, instructions, and examples
- Parallel structure in lists to improve scanability and comprehension
- Words connected in close proximity to each other improve comprehension
- Concise language, active voice, and consistent structure
- Second person (&quot;you&quot;) to address readers
- Imperative verbs for clear instructions
- Place conditions before actions
- Numbered lists for sequential steps
- Bullet lists for non-sequential items
- Instructions are task-oriented and start with verbs, such as &quot;Click,&quot; &quot;Select,&quot; or &quot;Enter.&quot;
- Descriptive and informative link text rather than generic terms like &quot;click here&quot; or &quot;more information.&quot;
- Consistent and precise terminology
- Prefer familiar terms over ambiguous or novel ones
- Define new or complex terms when first used
- Introduce abbreviations and acronyms before using them
- Use abbreviations consistently and sparingly
- Keep spelling, capitalization, and hyphenation uniform
- Format code and commands in `monospace`
- Keep code lines under 80 characters
- Show user input, system output, and examples clearly
- Use sentence case for headings
- Use clear subheadings and indent lists properly
- Break steps into short, clear actions
- Use tested, realistic technical examples
- Most important information at the beginning of each sentence

---

## Format and Output

- Use the rules in **Progressive‑Disclosure Pattern** when structuring documents or sections
- Use the rules in **Writing Github Flavor Markdown** when writing markdown files (`*.md`)
- Lead with clear task imperative, short clause
- Reveal context next, one sentence
- Unfold options in subsections, ordered by effort
- If needed, add deep reference data last, collapsed or linked
- Finish with short recap

### Writing Github Flavor Markdown

- Utilize the the full capabilities of Github Flavor markdown. Examples of capabilities you should use:
  - Task lists. Example: `- [x] Install dependencies`
  - Tables
  - Admonitions
    - Using the `[!TYPE]`syntax. Examples: `[!IMPORTANT]`, `[!TIP]`, `[!CAUTION]`...
    - Using an emoji + blockquote. Example: `&gt; **🧪 Example**`.
  - Strikethroughs. Example: `This is ~~struck through~~ text.`
  - Collapsed details block (`&lt;details&gt;`) are perfct for long lists. Example: `&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;&lt;/details&gt;`

### Progressive‑Disclosure

#### Example Skeleton (For Illustration Only)

```markdown
## Do X Now
Step list…

### Why X Works
Brief explanation…

### More You Can Tweak
Options list…

#### Deep Dive
Reference table…

### Recap
One‑sentence summary
```

#### Good / Bad

| Good                                                                                                                                                                          | Bad                                                                                                                                             |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| **Do:**&lt;br&gt;Install with `deno run -A mod.ts`.&lt;br&gt;**Why:** Minimal deps, quick start.&lt;br&gt;**More:** Set `--log-level=debug` for verbose output.&lt;br&gt;**Deep:** See full CLI spec. | **Overview:** This project is a powerful tool that...&lt;br&gt;It can be configured in various ways...&lt;br&gt;To install, follow these extensive steps... |

#### Related Patterns

- Inverted pyramid (journalism-inspired: summary → detail)
- Action first, explanation second (task-based documentation)
- Just-in-time help (surface detail only when needed)</file><file path=".cursor/rules/global/with-typescript.mdc">---
description:
globs: *.ts
alwaysApply: false
---
# Rules For Typescript Types
Follow these rules and standards when creating or editing types:

- The less code it takes to define a type the better
- Derive dynamic types from values instead of repeating values that already exist
- Reuse and extend existing types instead of creating whole new types
- Avoid duplicating types in the project
- Avoid redundant type declaration
- Avoid manual type annotation
- Avoid non-inferential typing
- Consolidate or share similar types across files instead of creating similar ones for each file. Examples:
  - Finding and using the `types.ts` file or common export if they exist
  - By namespace merging and augmentation of very similar interfaces that exist across files instead of creating the same or similar type in every single file.
- Prefer type-level programming or type inference-driven type construction
- GOOD: typeof inference: capturing runtime shapes for type use
- GOOD: mapped types: transforming types over keys
- GOOD: indexed access types: extracting types via `[K]`
- GOOD: template literal types: for strings and key construction.
- GOOD: conditional types: shaping types based on logic

## GOOD Methods For Creating Types

* **`satisfies`**

  * Ensures a value conforms to a type without losing literal types

    * ```ts
      const config = {
        mode: &apos;dev&apos;,
        verbose: true,
      } satisfies Record&lt;string, unknown&gt;
      ```

* **`infer`**

  * Extracts types inside conditional types

    * ```ts
      type ElementType&lt;T&gt; = T extends (infer U)[] ? U : T
      ```

* **`keyof` with `typeof`**

  * Gets literal keys from objects or arrays

    * ```ts
      const flags = [&apos;--help&apos;, &apos;--verbose&apos;] as const
      type Flag = (typeof flags)[number] // &quot;--help&quot; | &quot;--verbose&quot;
      ```

* **`ReturnType`, `Parameters`, `ConstructorParameters`**

  * Extracts return values, arguments, and constructor params from functions

    * ```ts
      type Fn = (x: number) =&gt; string
      type R = ReturnType&lt;Fn&gt; // string
      ```

* **Template Literal Types**

  * Builds new string types using embedded values

    * ```ts
      type Lang = &apos;en&apos; | &apos;fr&apos;
      type Route = `/${Lang}/home` // &quot;/en/home&quot; | &quot;/fr/home&quot;
      ```

* **`Record&lt;K, V&gt;` with `keyof`**

  * Dynamically builds object-like types from keys

    * ```ts
      type Config = Record&lt;keyof typeof config, string&gt;
      ```

* **`as const`**

  * Freezes values to preserve literal types

    * ```ts
      const roles = [&apos;admin&apos;, &apos;user&apos;] as const
      type Role = typeof roles[number] // &quot;admin&quot; | &quot;user&quot;
      ```

* **Utility Types (`Partial`, `Required`, `Pick`, `Omit`, `Exclude`, `Extract`)**

  * Shape types by including, excluding, or modifying fields

    * ```ts
      type OptionalName = Partial&lt;{ name: string; age: number }&gt;
      ```

* **`asserts` type predicates**

  * Smartly narrows types with custom logic

    * ```ts
      function isString(val: unknown): val is string {
        return typeof val === &apos;string&apos;
      }
      ```

* **`unique symbol`**

  * Creates brand/tag-like nominal types

    * ```ts
      declare const myTag: unique symbol
      type Tagged = { [myTag]: true }
      ```

## Example 1
```ts
// IMPORTANT: Given THIS Existing value
const defaultConfig = {
  ENV: &apos;production&apos;,
  PORT: 9001,
  HOST: undefined
}

// BAD: Repetitive type created (manual)
interface Config {
  HOST: string
  ENV?: string
  PORT?: number
}

// BAD: Repetitive type created (manual)
type Config = &apos;ENV&apos; | &apos;PORT&apos; | &apos;HOST&apos;

// BAD: Frozen keys array
const keys = [&apos;ENV&apos;, &apos;PORT&apos;, &apos;HOST&apos;] as const

// GOOD: Dynamic type (derived)
type Config = {
  [K in keyof typeof defaultConfig]: typeof defaultConfig[K]
}

// GOOD: Derive the type with HOST required using mapped types and intersections
type Config = {
  HOST: typeof defaultConfig[&apos;HOST&apos;]
} &amp; Partial&lt;Omit&lt;typeof defaultConfig, &apos;HOST&apos;&gt;&gt;

// GOOD: Keys only (dynamically)
type Config = keyof typeof defaultConfig

// GOOD: Keys as array
const keys = Object.keys(defaultConfig) as Array&lt;keyof typeof defaultConfig&gt;
type Config = (typeof keys)[number]
type Config = typeof keys[number]

// GOOD: Value union (types of all values)
type Config = typeof defaultConfig[keyof typeof defaultConfig]
```

## Example 2

```ts
const obj = { name: &apos;mary&apos;, age: 42 }

// GOOD: Dynamic value
interface LookupTable {
  value: keyof typeof obj
}

// BAD:
interface NewType {
  name: string
  age: number
}
```

## Debugging Typescript and Deno

When having issues with a Typescript library or module, these are the tools that will help you understand what the issue is and where you might&apos;ve made a mistake:

- **Deno Native APIs** :Get documentation generated from Typescript for Deno native APIs. Exanple: `deno doc --filter Deno.Listener`
- **JSR or Typescript Packages**: Get documentation generated from Typescript for JSR packages (if they&apos;re current installed). Examples: `deno doc &quot;jsr:@std/cli&quot;`
- **Local File**: Get documentation generated from Typescript for local file. Exanples: `./path/to/module.ts&quot;`
- **Type Checker**: `deno check ./path/to/module.ts`
- **Temporarily Disable Type Checking**: Certain commands for the deno cli accept the `--no-check` flag. Example `deno test --no-check`

## Summary

Following these rules will ensure you introduce the least amount of code and types into the codebase. You will always consistently apply these rules to enforce a clean, minimal, maintainable, and readable style of Typescript code in the codebase.</file><file path=".github/workflows/release-jsr.yml">name: Publish to JSR
on:
  workflow_run:
    workflows: [&quot;Test Installer&quot;]
    types:
      - completed
jobs:
  # This job relies on the test-installer job in the test-install.yml workflow
  publish-jsr:
    if: &gt;
      github.event.workflow_run.conclusion == &apos;success&apos; &amp;&amp;
      contains(github.event.workflow_run.head_commit.message, &apos;chore: tag version v&apos;)
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha }}
      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x
      - name: Create bin directory
        run: mkdir -p bin
      - name: Run Build Task
        run: deno task build
      - name: Publish to JSR
        run: npx jsr publish --no-check</file><file path=".github/workflows/release.yml">name: Github Release
on:
  push:
    tags:
      - &apos;v[0-9]+.[0-9]+.[0-9]+&apos;
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Git
        run: |
          git config --global user.name &quot;GitHub Action&quot;
          git config --global user.email &quot;action@github.com&quot;
      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: 2.x
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gnupg zip unzip
      - name: Install Git LFS
        run: |
          sudo apt-get install -y git-lfs
          git lfs install
      - name: Run tests
        run: deno task test
  build-and-release:
    needs: test
    runs-on: ubuntu-latest
    # Add explicit permissions for releases
    permissions:
      contents: write
      discussions: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: 2.x
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip tar
      - name: Install Git LFS
        run: |
          sudo apt-get install -y git-lfs
          git lfs install
      - name: Get tag name
        id: get_tag
        run: echo &quot;TAG=${GITHUB_REF#refs/tags/}&quot; &gt;&gt; $GITHUB_OUTPUT
      - name: Get commit message
        id: get_commit_message
        run: |
          COMMIT_MSG=$(git log -1 --pretty=format:%B ${{ github.sha }})
          # Properly handle multiline commit messages for GitHub Actions
          echo &quot;$COMMIT_MSG&quot; &gt; RELEASE_NOTES.txt
          echo &quot;NOTES_FILE=RELEASE_NOTES.txt&quot; &gt;&gt; $GITHUB_OUTPUT
      - name: Build binaries
        run: deno task build --bin-path=./bin
      - name: Verify build artifacts
        run: |
          echo &quot;Checking build output files...&quot;
          find bin -type f
          # Ensure all expected platform-specific files and aliases are present
          required_files=(
            &quot;gv-x86_64-unknown-linux-gnu&quot;
            &quot;gv-aarch64-unknown-linux-gnu&quot;
            &quot;gv-x86_64-pc-windows-msvc.exe&quot;
            &quot;gv-x86_64-apple-darwin&quot;
            &quot;gv-aarch64-apple-darwin&quot;
            &quot;gv-linux&quot;
            &quot;gv-linux-arm&quot;
            &quot;gv-windows.exe&quot;
            &quot;gv-macos&quot;
            &quot;gv-macos-arm&quot;
          )
          for file in &quot;${required_files[@]}&quot;; do
            if [ ! -f &quot;bin/$file&quot; ]; then
              echo &quot;ERROR: Missing binary file: bin/$file&quot;
              exit 1
            fi
            if [ ! -f &quot;bin/$file.zip&quot; ]; then
              echo &quot;ERROR: Missing zip file: bin/$file.zip&quot;
              exit 1
            fi
            if [ ! -f &quot;bin/$file.tar.gz&quot; ]; then
              echo &quot;ERROR: Missing tar.gz file: bin/$file.tar.gz&quot;
              exit 1
            fi
          done
          echo &quot;All required build artifacts have been verified.&quot;
      - name: Delete existing release if it exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        run: |
          gh release delete ${{ steps.get_tag.outputs.TAG }} --yes || true
      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Upload both zip and tar.gz files
          gh release create ${{ steps.get_tag.outputs.TAG }} \
            bin/*.zip \
            bin/*.tar.gz \
            --title &quot;Release ${{ steps.get_tag.outputs.TAG }}&quot; \
            --notes-file ${{ steps.get_commit_message.outputs.NOTES_FILE }}</file><file path=".github/workflows/validate.yml">name: Validate Pull Request
on:
  pull_request:
    branches: [&apos;**&apos;]
  push:
    branches-ignore:
      - main
jobs:
  check-skip:
    runs-on: ubuntu-latest
    outputs:
      should-skip: ${{ steps.check-commit-msg.outputs.should-skip }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Check commit message for skip keywords
        id: check-commit-msg
        run: |
          # Get the commit message
          if [ &quot;${{ github.event_name }}&quot; == &quot;pull_request&quot; ]; then
            COMMIT_MSG=$(git log -1 --pretty=%B ${{ github.event.pull_request.head.sha }})
          else
            COMMIT_MSG=$(git log -1 --pretty=%B ${{ github.sha }})
          fi
          # Check for skip keywords
          echo &quot;Commit message: $COMMIT_MSG&quot;
          if echo &quot;$COMMIT_MSG&quot; | grep -qE &apos;(\[skip ci\]|\[skip workflow\]|chore\(release\):|release\(|version\()&apos;; then
            echo &quot;Skip keywords found in commit message, skipping workflow&quot;
            echo &quot;should-skip=true&quot; &gt;&gt; $GITHUB_OUTPUT
          else
            echo &quot;No skip keywords found, proceeding with workflow&quot;
            echo &quot;should-skip=false&quot; &gt;&gt; $GITHUB_OUTPUT
          fi
  validate:
    needs: check-skip
    if: ${{ needs.check-skip.outputs.should-skip != &apos;true&apos; }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Git
        run: |
          git config --global user.name &quot;GitHub Action&quot;
          git config --global user.email &quot;action@github.com&quot;
      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: 2.x
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gnupg zip unzip
      - name: Install Git LFS
        run: |
          sudo apt-get install -y git-lfs
          git lfs install
      - name: Lint and type check
        run: deno task check
      - name: Run tests
        run: deno task test
      - name: Build dry run
        run: deno task build --bin-path=./bin-test
      - name: Check build output
        run: |
          if [ ! -d &quot;./bin-test&quot; ]; then
            echo &quot;Build output directory not found&quot;
            exit 1
          fi
          # Check for all platform builds - target-specific builds
          declare -a targets=(
            &quot;x86_64-unknown-linux-gnu&quot;
            &quot;aarch64-unknown-linux-gnu&quot;
            &quot;x86_64-apple-darwin&quot;
            &quot;aarch64-apple-darwin&quot;
          )
          # Check Windows separately because of .exe extension
          if [ ! -f &quot;./bin-test/gv-x86_64-pc-windows-msvc.exe&quot; ]; then
            echo &quot;Missing binary for x86_64-pc-windows-msvc.exe&quot;
            exit 1
          fi
          if [ ! -f &quot;./bin-test/gv-x86_64-pc-windows-msvc.exe.zip&quot; ]; then
            echo &quot;Missing zip for x86_64-pc-windows-msvc.exe&quot;
            exit 1
          fi
          # Check non-Windows targets
          for target in &quot;${targets[@]}&quot;; do
            if [ ! -f &quot;./bin-test/gv-${target}&quot; ]; then
              echo &quot;Missing binary for ${target}&quot;
              exit 1
            fi
            if [ ! -f &quot;./bin-test/gv-${target}.zip&quot; ]; then
              echo &quot;Missing zip for ${target}&quot;
              exit 1
            fi
          done
          # Check for platform aliases
          declare -a platforms=(
            &quot;linux&quot;
            &quot;linux-arm&quot;
            &quot;macos&quot;
            &quot;macos-arm&quot;
          )
          # Check Windows platform alias separately
          if [ ! -f &quot;./bin-test/gv-windows.exe&quot; ]; then
            echo &quot;Missing platform binary for windows.exe&quot;
            exit 1
          fi
          if [ ! -f &quot;./bin-test/gv-windows.exe.zip&quot; ]; then
            echo &quot;Missing platform zip for windows.exe&quot;
            exit 1
          fi
          # Check non-Windows platform aliases
          for platform in &quot;${platforms[@]}&quot;; do
            if [ ! -f &quot;./bin-test/gv-${platform}&quot; ]; then
              echo &quot;Missing platform binary for ${platform}&quot;
              exit 1
            fi
            if [ ! -f &quot;./bin-test/gv-${platform}.zip&quot; ]; then
              echo &quot;Missing platform zip for ${platform}&quot;
              exit 1
            fi
          done
          # Count the number of zip files
          zip_count=$(find ./bin-test -name &quot;*.zip&quot; | wc -l)
          expected_count=10  # 5 target platforms * 2 formats (specific name + platform name)
          if [ &quot;$zip_count&quot; -lt &quot;$expected_count&quot; ]; then
            echo &quot;Expected at least ${expected_count} zip files, but found ${zip_count}&quot;
            find ./bin-test -name &quot;*.zip&quot; | sort
            exit 1
          else
            echo &quot;Found $zip_count zip files in build output&quot;
            find ./bin-test -name &quot;*.zip&quot; | sort
          fi
      - name: Mock release creation (dry-run)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a temporary tag
          MOCK_TAG=&quot;pr-dryrun-${GITHUB_SHA:0:7}&quot;
          # Create mock release notes
          echo &quot;This is a dry run test for PR #${{ github.event.pull_request.number || &apos;unknown&apos; }}&quot; &gt; mock_release_notes.txt
          echo &quot;Branch: ${{ github.ref_name }}&quot; &gt;&gt; mock_release_notes.txt
          echo &quot;Commit: ${{ github.sha }}&quot; &gt;&gt; mock_release_notes.txt
          echo &quot;Would create release with tag: $MOCK_TAG&quot;
          echo &quot;Would upload $(find ./bin-test -name &quot;*.zip&quot; | wc -l) zip files from ./bin-test directory&quot;
          # Don&apos;t actually create the release, just simulating the command that would run
          echo &quot;gh release create $MOCK_TAG bin-test/*.zip --draft --title \&quot;Dry Run $MOCK_TAG\&quot; --notes-file mock_release_notes.txt&quot;</file><file path=".hypermix/@std/testing.xml">&lt;repomix&gt;This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).&lt;file_summary&gt;This section contains a summary of this file.&lt;purpose&gt;This file contains a packed representation of the entire repository&amp;apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.&lt;/purpose&gt;&lt;file_format&gt;The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file&lt;/file_format&gt;&lt;usage_guidelines&gt;- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.&lt;/usage_guidelines&gt;&lt;notes&gt;- Some files may have been excluded based on .gitignore rules and Repomix&amp;apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: testing/**/*
- Files matching these patterns are excluded: testing/tests/**, testing/mocks/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)&lt;/notes&gt;&lt;additional_info&gt;&lt;/additional_info&gt;&lt;/file_summary&gt;&lt;directory_structure&gt;testing/
  __snapshots__/
    options_tests/
      custom_path.snap
      snapshot_test.ts.snap
    snapshot_test.ts.snap
  testdata/
    configure_global_sanitizers/
      disable_sanitize_exit.ts
      disable_sanitize_ops_and_resources.ts
      disable_sanitize_resources.ts
  _mock_utils.ts
  _snapshot_utils.ts
  _test_suite.ts
  _test_utils.ts
  _time.ts
  bdd_test.ts
  bdd.ts
  deno.json
  mock_test.ts
  mock.ts
  README.md
  snapshot_test.ts
  snapshot.ts
  time_test.ts
  time.ts
  types_test.ts
  types.ts
  unstable_bdd_test.ts
  unstable_bdd.ts
  unstable_snapshot_test.ts
  unstable_snapshot.ts
  unstable_stub_test.ts
  unstable_stub.ts
  unstable_types_test.ts
  unstable_types.ts&lt;/directory_structure&gt;&lt;files&gt;This section contains the contents of the repository&amp;apos;s files.&lt;file path=&quot;testing/__snapshots__/options_tests/custom_path.snap&quot;&gt;export const snapshot = {};
snapshot[`assertSnapshot() - options &amp;gt; path &amp;gt; relative 1`] = `
[
  1,
  2,
  3,
]
`;
snapshot[`assertSnapshot() - options &amp;gt; path &amp;gt; absolute 1`] = `
[
  1,
  2,
  3,
]
`;&lt;/file&gt;&lt;file path=&quot;testing/__snapshots__/options_tests/snapshot_test.ts.snap&quot;&gt;export const snapshot = {};
snapshot[`assertSnapshot() - options &amp;gt; dir &amp;gt; relative 1`] = `
[
  1,
  2,
  3,
]
`;
snapshot[`assertSnapshot() - options &amp;gt; dir &amp;gt; absolute 1`] = `
[
  1,
  2,
  3,
]
`;&lt;/file&gt;&lt;file path=&quot;testing/__snapshots__/snapshot_test.ts.snap&quot;&gt;export const snapshot = {};
snapshot[`assertSnapshot() 1`] = `
{
  a: 1,
  b: 2,
}
`;
snapshot[`assertSnapshot() 2`] = `
TestClass {
  a: 1,
  b: 2,
}
`;
snapshot[`assertSnapshot() 3`] = `
Map(3) {
  &amp;quot;Hello&amp;quot; =&amp;gt; &amp;quot;World!&amp;quot;,
  1 =&amp;gt; 2,
  [Function (anonymous)] =&amp;gt; &amp;quot;World!&amp;quot;,
}
`;
snapshot[`assertSnapshot() 4`] = `
Set(3) {
  1,
  2,
  3,
}
`;
snapshot[`assertSnapshot() 5`] = `
{
  fn: [Function: fn],
}
`;
snapshot[`assertSnapshot() 6`] = `[Function: fn]`;
snapshot[`assertSnapshot() 7`] = `
[
  1,
  2,
  3,
]
`;
snapshot[`assertSnapshot() 8`] = `&amp;quot;hello world&amp;quot;`;
snapshot[`assertSnapshot() - step 1`] = `
{
  a: 1,
  b: 2,
}
`;
snapshot[`assertSnapshot() - step &amp;gt; nested 1`] = `
TestClass {
  a: 1,
  b: 2,
}
`;
snapshot[`assertSnapshot() - step &amp;gt; nested 2`] = `
Map(3) {
  &amp;quot;Hello&amp;quot; =&amp;gt; &amp;quot;World!&amp;quot;,
  1 =&amp;gt; 2,
  [Function (anonymous)] =&amp;gt; &amp;quot;World!&amp;quot;,
}
`;
snapshot[`assertSnapshot() - step &amp;gt; nested &amp;gt; double-nested 1`] = `
Set(3) {
  1,
  2,
  3,
}
`;
snapshot[`assertSnapshot() - step &amp;gt; nested &amp;gt; double-nested 2`] = `
{
  fn: [Function: fn],
}
`;
snapshot[`assertSnapshot() - step &amp;gt; nested &amp;gt; double-nested 3`] = `[Function: fn]`;
snapshot[`assertSnapshot() - step &amp;gt; nested 3`] = `
[
  1,
  2,
  3,
]
`;
snapshot[`assertSnapshot() - step 2`] = `&amp;quot;hello world&amp;quot;`;
snapshot[`assertSnapshot() - adverse string \\ \` \${} 1`] = `&amp;quot;\\\\ \` \${}&amp;quot;`;
snapshot[`assertSnapshot() - default serializer 1`] = `
&amp;quot;a
b	c&amp;quot;
`;
snapshot[`assertSnapshot() - multi-line strings &amp;gt; string 1`] = `
&amp;quot;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Snapshot Test - Multi-Line Strings&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;
      Snapshot Test - Multi-Line Strings
    &amp;lt;/h2&amp;gt;
    &amp;lt;p&amp;gt;
      This is a snapshot of a multi-line string.
    &amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&amp;quot;
`;
snapshot[`assertSnapshot() - multi-line strings &amp;gt; string in array 1`] = `
[
  &amp;quot;
&amp;lt;h1&amp;gt;
  Header
&amp;lt;/h1&amp;gt;&amp;quot;,
  &amp;quot;
&amp;lt;p&amp;gt;
  Content
&amp;lt;/p&amp;gt;&amp;quot;,
]
`;
snapshot[`assertSnapshot() - multi-line strings &amp;gt; string in object 1`] = `
{
  str: &amp;quot;
        Line #1
        Line #2
        Line #3&amp;quot;,
}
`;
snapshot[`assertSnapshot() - failed assertion &amp;gt; object 1`] = `
&amp;quot;Snapshot does not match:
    [Diff] Actual / Expected
    [
      1,
      2,
+     3,
    ]
To update snapshots, run
    deno test --allow-read --allow-write [files]... -- --update
&amp;quot;
`;
snapshot[`assertSnapshot() - failed assertion &amp;gt; string 1`] = `
&amp;apos;Snapshot does not match:
    [Diff] Actual / Expected
-   &amp;quot;Hello!&amp;quot;
+   &amp;quot;Hello World!&amp;quot;
To update snapshots, run
    deno test --allow-read --allow-write [files]... -- --update
&amp;apos;
`;
snapshot[`custom name 1`] = `
[
  1,
  2,
  3,
]
`;
snapshot[`custom name 2`] = `
[
  1,
  2,
  3,
]
`;
snapshot[`assertSnapshot() - options &amp;gt; serializer 1`] = `
Array Length: 3
[
  1,
  2,
  3,
]
`;
snapshot[`assertSnapshot() - options &amp;gt; msg &amp;gt; missing snapshot 1`] = `&amp;quot;[CUSTOM ERROR MESSAGE - MISSING SNAPSHOT]&amp;quot;`;
snapshot[`assertSnapshot() - options &amp;gt; msg &amp;gt; missing snapshot file 1`] = `&amp;quot;[CUSTOM ERROR MESSAGE - MISSING SNAPSHOT]&amp;quot;`;
snapshot[`assertSnapshot() - options &amp;gt; mode 1`] = `
&amp;quot;
[
  1,
  2,
  3,
]
&amp;quot;
`;
snapshot[`assertSnapshot() - options &amp;gt; mode 2`] = `
&amp;quot;running 1 test from &amp;lt;tempDir&amp;gt;/test.ts
snapshot ... ok (--ms)
------- post-test output -------
 &amp;gt; 1 snapshot updated.
----- post-test output end -----
ok | 1 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - update - New snapshot 1`] = `
&amp;quot;running 1 test from &amp;lt;tempDir&amp;gt;/test.ts
assertSnapshot() - update ... ok (--ms)
------- post-test output -------
 &amp;gt; 1 snapshot updated.
----- post-test output end -----
ok | 1 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - update - New snapshot 2`] = `
&amp;quot;export const snapshot = {};
snapshot[\`assertSnapshot() - update 1\`] = \`
[
  1,
  2,
]
\`;
&amp;quot;
`;
snapshot[`assertSnapshot() - update - Existing snapshot - no changes 1`] = `
&amp;quot;running 1 test from &amp;lt;tempDir&amp;gt;/test.ts
assertSnapshot() - update ... ok (--ms)
ok | 1 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - update - Existing snapshot - no changes 2`] = `
&amp;quot;export const snapshot = {};
snapshot[\`assertSnapshot() - update 1\`] = \`
[
  1,
  2,
]
\`;
&amp;quot;
`;
snapshot[`assertSnapshot() - update - Existing snapshot - updates 1`] = `
&amp;quot;running 1 test from &amp;lt;tempDir&amp;gt;/test.ts
assertSnapshot() - update ... ok (--ms)
------- post-test output -------
 &amp;gt; 1 snapshot updated.
----- post-test output end -----
ok | 1 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - update - Existing snapshot - updates 2`] = `
&amp;quot;export const snapshot = {};
snapshot[\`assertSnapshot() - update 1\`] = \`
[
  1,
  2,
  3,
  5,
]
\`;
&amp;quot;
`;
snapshot[`assertSnapshot() - update - Existing snapshots - reverse order 1 1`] = `
&amp;quot;running 2 tests from &amp;lt;tempDir&amp;gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------
 &amp;gt; 2 snapshots updated.
 &amp;gt; 1 snapshot removed.
   • assertSnapshot() - update 1
----- post-test output end -----
ok | 2 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - update - Existing snapshots - reverse order 1 2`] = `
&amp;apos;export const snapshot = {};
snapshot[\`Snapshot Test - First 1\`] = \`&amp;quot;FIRST&amp;quot;\`;
snapshot[\`Snapshot Test - Second 1\`] = \`&amp;quot;SECOND&amp;quot;\`;
&amp;apos;
`;
snapshot[`assertSnapshot() - update - Existing snapshots - reverse order 2 1`] = `
&amp;quot;running 2 tests from &amp;lt;tempDir&amp;gt;/test.ts
Snapshot Test - Second ... ok (--ms)
Snapshot Test - First ... ok (--ms)
ok | 2 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - update - Existing snapshots - reverse order 2 2`] = `
&amp;apos;export const snapshot = {};
snapshot[\`Snapshot Test - Second 1\`] = \`&amp;quot;SECOND&amp;quot;\`;
snapshot[\`Snapshot Test - First 1\`] = \`&amp;quot;FIRST&amp;quot;\`;
&amp;apos;
`;
snapshot[`assertSnapshot() - remove - New snapshot 1`] = `
&amp;quot;running 5 tests from &amp;lt;tempDir&amp;gt;/test.ts
assertSnapshot() - remove - First ... ok (--ms)
assertSnapshot() - remove - Second ... ok (--ms)
assertSnapshot() - remove - Third ... ok (--ms)
assertSnapshot() - remove - Fourth ... ok (--ms)
assertSnapshot() - remove - Fifth ... ok (--ms)
------- post-test output -------
 &amp;gt; 5 snapshots updated.
----- post-test output end -----
ok | 5 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - remove - Existing snapshot - removed one 1`] = `
&amp;quot;running 4 tests from &amp;lt;tempDir&amp;gt;/test.ts
assertSnapshot() - remove - First ... ok (--ms)
assertSnapshot() - remove - Second ... ok (--ms)
assertSnapshot() - remove - Fourth ... ok (--ms)
assertSnapshot() - remove - Fifth ... ok (--ms)
------- post-test output -------
 &amp;gt; 1 snapshot removed.
   • assertSnapshot() - remove - Third 1
----- post-test output end -----
ok | 4 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - remove - Existing snapshot - removed several 1`] = `
&amp;quot;running 1 test from &amp;lt;tempDir&amp;gt;/test.ts
assertSnapshot() - remove - First ... ok (--ms)
------- post-test output -------
 &amp;gt; 3 snapshots removed.
   • assertSnapshot() - remove - Second 1
   • assertSnapshot() - remove - Fourth 1
   • assertSnapshot() - remove - Fifth 1
----- post-test output end -----
ok | 1 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - different directory - New snapshot 1`] = `
&amp;quot;running 2 tests from &amp;lt;tempDir&amp;gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------
 &amp;gt; 2 snapshots updated.
----- post-test output end -----
running 2 tests from &amp;lt;tempDir&amp;gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------
 &amp;gt; 2 snapshots updated.
----- post-test output end -----
ok | 4 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - different directory - Existing snapshot - update 1`] = `
&amp;quot;running 2 tests from &amp;lt;tempDir&amp;gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------
 &amp;gt; some snapshots updated.
----- post-test output end -----
running 2 tests from &amp;lt;tempDir&amp;gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------
 &amp;gt; some snapshots updated.
----- post-test output end -----
ok | 4 passed | 0 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - regression #2140 1`] = `
{
  content: &amp;quot;
      &amp;lt;h1&amp;gt;Testing a page&amp;lt;/h1&amp;gt;
      &amp;lt;p&amp;gt;This is a test&amp;lt;/p&amp;gt;
      &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
      &amp;quot;,
  title: &amp;quot;Testing a page&amp;quot;,
}
`;
snapshot[`assertSnapshot() - regression #2144 1`] = `
{
  fmt: {
    files: {
      exclude: [],
      include: [],
    },
    options: {},
  },
}
`;
snapshot[`assertSnapshot() - empty #2245 1`] = ``;
snapshot[`createAssertSnapshot() &amp;gt; no options 1`] = `This green text has had its colors stripped`;
snapshot[`createAssertSnapshot() - options object - custom name 1`] = `This green text has had its colors stripped`;
snapshot[`createAssertSnapshot() &amp;gt; message 1`] = `&amp;quot;This snapshot has failed as expected&amp;quot;`;
snapshot[`createAssertSnapshot() - composite - custom Name 1`] = `This green text has had its colors stripped`;
snapshot[`assertSnapshot() - regression #5155 1`] = `
&amp;quot;running 1 test from &amp;lt;tempDir&amp;gt;/test.ts
Snapshot Test ... FAILED (--ms)
 ERRORS 
error: PermissionDenied: Missing write access to snapshot file (file://&amp;lt;path&amp;gt;). This is required because assertSnapshot was called in update mode. Please pass the --allow-write flag.
        throw new Deno.errors.PermissionDenied(
              ^
 FAILURES 
FAILED | 0 passed | 1 failed (--ms)
&amp;quot;
`;
snapshot[`assertSnapshot() - should work with the string with &amp;apos;\\r&amp;apos; character 1`] = `
&amp;quot;Hello\\r
World!\\r
&amp;quot;
`;&lt;/file&gt;&lt;file path=&quot;testing/testdata/configure_global_sanitizers/disable_sanitize_exit.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { describe, it } from &amp;quot;@std/testing/bdd&amp;quot;;
import { configureGlobalSanitizers } from &amp;quot;@std/testing/unstable-bdd&amp;quot;;&lt;/file&gt;&lt;file path=&quot;testing/testdata/configure_global_sanitizers/disable_sanitize_ops_and_resources.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { describe, it } from &amp;quot;@std/testing/bdd&amp;quot;;
import { configureGlobalSanitizers } from &amp;quot;@std/testing/unstable-bdd&amp;quot;;&lt;/file&gt;&lt;file path=&quot;testing/testdata/configure_global_sanitizers/disable_sanitize_resources.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { describe, it } from &amp;quot;@std/testing/bdd&amp;quot;;
import { configureGlobalSanitizers } from &amp;quot;@std/testing/unstable-bdd&amp;quot;;&lt;/file&gt;&lt;file path=&quot;testing/_mock_utils.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import type { Spy } from &amp;quot;./mock.ts&amp;quot;;
/**
 * Checks if a function is a spy.
 *
 * @typeParam Self The self type of the function.
 * @typeParam Args The arguments type of the function.
 * @typeParam Return The return type of the function.
 * @param func The function to check
 * @return `true` if the function is a spy, `false` otherwise.
 */
export function isSpy&amp;lt;Self, Args extends unknown[], Return&amp;gt;(
  func: ((this: Self, ...args: Args) =&amp;gt; Return) | unknown,
): func is Spy&amp;lt;Self, Args, Return&amp;gt;
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
function getSession(): Set&amp;lt;Spy&amp;lt;any, any[], any&amp;gt;&amp;gt;
// deno-lint-ignore no-explicit-any
export function registerMock(spy: Spy&amp;lt;any, any[], any&amp;gt;)
// deno-lint-ignore no-explicit-any
export function unregisterMock(spy: Spy&amp;lt;any, any[], any&amp;gt;)&lt;/file&gt;&lt;file path=&quot;testing/_snapshot_utils.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import type { SnapshotMode, SnapshotOptions } from &amp;quot;./snapshot.ts&amp;quot;;
import { diff } from &amp;quot;@std/internal/diff&amp;quot;;
import { diffStr } from &amp;quot;@std/internal/diff-str&amp;quot;;
import { buildMessage } from &amp;quot;@std/internal/build-message&amp;quot;;
export function getErrorMessage(message: string, options: SnapshotOptions)
/**
 * Default serializer for `assertSnapshot`.
 *
 * @example Usage
 * ```ts
 * import { serialize } from &amp;quot;@std/testing/snapshot&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * assertEquals(serialize({ foo: 42 }), &amp;quot;{\n  foo: 42,\n}&amp;quot;)
 * ```
 *
 * @param actual The value to serialize
 * @returns The serialized string
 */
export function serialize(actual: unknown): string
/**
 * Converts a string to a valid JavaScript string which can be wrapped in backticks.
 *
 * @example
 *
 * &amp;quot;special characters (\ ` $) will be escaped&amp;quot; -&amp;gt; &amp;quot;special characters (\\ \` \$) will be escaped&amp;quot;
 */
export function escapeStringForJs(str: string)
⋮----
/**
 * Get the snapshot mode.
 */
export function getMode(options: SnapshotOptions)
/**
 * Return `true` when snapshot mode is `update`.
 */
export function getIsUpdate(options: SnapshotOptions)
export function getOptions&amp;lt;T&amp;gt;(
  msgOrOpts?: string | T,
): T
export function getSnapshotNotMatchMessage(
  actualSnapshot: string,
  expectedSnapshot: string,
  options: SnapshotOptions,
)
// TODO (WWRS): Remove this when we drop support for Deno 1.x&lt;/file&gt;&lt;file path=&quot;testing/_test_suite.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { getAssertionState } from &amp;quot;@std/internal/assertion-state&amp;quot;;
import { AssertionError } from &amp;quot;@std/assert/assertion-error&amp;quot;;
⋮----
/** The options for creating a test suite with the describe function. */
export interface DescribeDefinition&amp;lt;T&amp;gt; extends Omit&amp;lt;Deno.TestDefinition, &amp;quot;fn&amp;quot;&amp;gt; {
  /** The body of the test suite */
  fn?: () =&amp;gt; void | undefined;
  /**
   * The `describe` function returns a `TestSuite` representing the group of tests.
   * If `describe` is called within another `describe` calls `fn`, the suite will default to that parent `describe` calls returned `TestSuite`.
   * If `describe` is not called within another `describe` calls `fn`, the suite will default to the `TestSuite` representing the global group of tests.
   */
  suite?: TestSuite&amp;lt;T&amp;gt;;
  /** Run some shared setup before all of the tests in the suite. */
  beforeAll?:
    | ((this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;)
    | ((this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;)[];
  /** Run some shared teardown after all of the tests in the suite. */
  afterAll?:
    | ((this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;)
    | ((this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;)[];
  /** Run some shared setup before each test in the suite. */
  beforeEach?:
    | ((this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;)
    | ((this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;)[];
  /** Run some shared teardown after each test in the suite. */
  afterEach?:
    | ((this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;)
    | ((this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;)[];
}
⋮----
/** The body of the test suite */
⋮----
/**
   * The `describe` function returns a `TestSuite` representing the group of tests.
   * If `describe` is called within another `describe` calls `fn`, the suite will default to that parent `describe` calls returned `TestSuite`.
   * If `describe` is not called within another `describe` calls `fn`, the suite will default to the `TestSuite` representing the global group of tests.
   */
⋮----
/** Run some shared setup before all of the tests in the suite. */
⋮----
/** Run some shared teardown after all of the tests in the suite. */
⋮----
/** Run some shared setup before each test in the suite. */
⋮----
/** Run some shared teardown after each test in the suite. */
⋮----
/** The options for creating an individual test case with the it function. */
export interface ItDefinition&amp;lt;T&amp;gt; extends Omit&amp;lt;Deno.TestDefinition, &amp;quot;fn&amp;quot;&amp;gt; {
  /** The body of the test case */
  fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;;
  /**
   * The `describe` function returns a `TestSuite` representing the group of tests.
   * If `it` is called within a `describe` calls `fn`, the suite will default to that parent `describe` calls returned `TestSuite`.
   * If `it` is not called within a `describe` calls `fn`, the suite will default to the `TestSuite` representing the global group of tests.
   */
  suite?: TestSuite&amp;lt;T&amp;gt;;
}
⋮----
/** The body of the test case */
⋮----
/**
   * The `describe` function returns a `TestSuite` representing the group of tests.
   * If `it` is called within a `describe` calls `fn`, the suite will default to that parent `describe` calls returned `TestSuite`.
   * If `it` is not called within a `describe` calls `fn`, the suite will default to the `TestSuite` representing the global group of tests.
   */
⋮----
/** The names of all the different types of hooks. */
export type HookNames = &amp;quot;beforeAll&amp;quot; | &amp;quot;afterAll&amp;quot; | &amp;quot;beforeEach&amp;quot; | &amp;quot;afterEach&amp;quot;;
/**
 * A group of tests.
 */
export interface TestSuite&amp;lt;T&amp;gt; {
  /** The symbol to use for grouping the test suite */
  symbol: symbol;
}
⋮----
/** The symbol to use for grouping the test suite */
⋮----
/**
 * An internal representation of a group of tests.
 */
export class TestSuiteInternal&amp;lt;T&amp;gt; implements TestSuite&amp;lt;T&amp;gt;
⋮----
constructor(describe: DescribeDefinition&amp;lt;T&amp;gt;)
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Stores how many test suites are executing. */
⋮----
/** If a test has been registered yet. Block adding global hooks if a test has been registered. */
⋮----
/** A map of all test suites by symbol. */
// deno-lint-ignore no-explicit-any
⋮----
/** The current test suite being registered. */
// deno-lint-ignore no-explicit-any
⋮----
/** The stack of tests that are actively running. */
⋮----
/** This is used internally for testing this module. */
static reset()
/** This is used internally to register tests. */
static registerTest(options: Deno.TestDefinition)
/** Updates all steps within top level suite to have ignore set to true if only is not set to true on step. */
static addingOnlyStep&amp;lt;T&amp;gt;(suite: TestSuiteInternal&amp;lt;T&amp;gt;)
/** This is used internally to add steps to a test suite. */
static addStep&amp;lt;T&amp;gt;(
    suite: TestSuiteInternal&amp;lt;T&amp;gt;,
    step: TestSuiteInternal&amp;lt;T&amp;gt; | ItDefinition&amp;lt;T&amp;gt;,
)
/** This is used internally to add hooks to a test suite. */
static setHook&amp;lt;T&amp;gt;(
    suite: TestSuiteInternal&amp;lt;T&amp;gt;,
    name: HookNames,
    fn: (this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
)
/** This is used internally to run all steps for a test suite. */
static async run&amp;lt;T&amp;gt;(
    suite: TestSuiteInternal&amp;lt;T&amp;gt;,
    context: T,
    t: Deno.TestContext,
)
⋮----
// deno-lint-ignore deno-style-guide/error-message
⋮----
static async runTest&amp;lt;T&amp;gt;(
    t: Deno.TestContext,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
    context: T,
    activeIndex = 0,
)&lt;/file&gt;&lt;file path=&quot;testing/_test_utils.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
export class Point
⋮----
constructor(x: number, y: number)
// deno-lint-ignore no-explicit-any
action(...args: any[]): any
toString(): string
explicitTypes(_x: number, _y: string)
⋮----
export function stringifyPoint(point: Point)
export type PointWithExtra = Point &amp;amp; {
  nonExistent: () =&amp;gt; number;
};&lt;/file&gt;&lt;file path=&quot;testing/_time.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
/** Used internally for testing that fake time uses real time correctly. */&lt;/file&gt;&lt;file path=&quot;testing/bdd_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import {
  assert,
  assertEquals,
  assertObjectMatch,
  assertRejects,
  assertStrictEquals,
  assertThrows,
} from &amp;quot;@std/assert&amp;quot;;
import {
  after,
  afterAll,
  afterEach,
  before,
  beforeAll,
  beforeEach,
  describe,
  it,
} from &amp;quot;./bdd.ts&amp;quot;;
import { TestSuiteInternal } from &amp;quot;./_test_suite.ts&amp;quot;;
import { assertSpyCall, assertSpyCalls, type Spy, spy, stub } from &amp;quot;./mock.ts&amp;quot;;
class TestContext implements Deno.TestContext
⋮----
constructor(name: string)
async step(t: Deno.TestStepDefinition): Promise&amp;lt;boolean&amp;gt;;
async step(
    name: string,
    fn: (t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ): Promise&amp;lt;boolean&amp;gt;;
async step(
    fn: (t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ): Promise&amp;lt;boolean&amp;gt;;
async step(
    tOrNameOrFn:
      | Deno.TestStepDefinition
      | string
      | ((t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;),
    fn?: (t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
): Promise&amp;lt;boolean&amp;gt;
⋮----
interface GlobalContext {
  allTimer: number;
  eachTimer: number;
  x?: number;
  y?: number;
}
⋮----
function hookFns()
⋮----
/**
   * Asserts that `Deno.test` is called with the correct options for the `it` call in the callback function.
   * This is used to reduce code duplication when testing calling `it` with different call signatures.
   */
async function assertOptions&amp;lt;T&amp;gt;(
    expectedOptions: Omit&amp;lt;Deno.TestDefinition, &amp;quot;name&amp;quot; | &amp;quot;fn&amp;quot;&amp;gt;,
    cb: (fn: Spy) =&amp;gt; void,
)
/**
   * Asserts that `Deno.test` is called with just the name and function for the `it` call in the callback function.
   * This is used to reduce code duplication when testing calling `it` with different call signatures.
   */
async function assertMinimumOptions(
    cb: (fn: Spy) =&amp;gt; void,
)
/**
   * Asserts that `Deno.test` is called with all of the options for the `it` call in the callback function.
   * This is used to reduce code duplication when testing calling `it` with different call signatures.
   */
async function assertAllOptions(
    cb: (fn: Spy) =&amp;gt; void,
)
⋮----
/**
     * Asserts that `Deno.test` is called with just the name, only, and function for the `it.only` call in the callback function.
     * This is used to reduce code duplication when testing calling `it.only` with different call signatures.
     */
async function assertMinimumOptions(
      cb: (fn: Spy) =&amp;gt; void,
)
/**
     * Asserts that `Deno.test` is called with all of the options for the `it.only` call in the callback function.
     * This is used to reduce code duplication when testing calling `it.only` with different call signatures.
     */
async function assertAllOptions(
      cb: (fn: Spy) =&amp;gt; void,
)
⋮----
/**
     * Asserts that `Deno.test` is called with just the name, ignore, and function for the `it.ignore` call in the callback function.
     * This is used to reduce code duplication when testing calling `it.ignore` with different call signatures.
     */
⋮----
/**
     * Asserts that `Deno.test` is called with all of the options for the `it.ignore` call in the callback function.
     * This is used to reduce code duplication when testing calling `it.ignore` with different call signatures.
     */
⋮----
/**
   * Asserts that `Deno.test` is called with the correct options for the `describe` call in the callback function.
   * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
   * This is used to reduce code duplication when testing calling `describe` with different call signatures.
   */
async function assertOptions(
    expectedOptions: Omit&amp;lt;Deno.TestDefinition, &amp;quot;name&amp;quot; | &amp;quot;fn&amp;quot;&amp;gt;,
    cb: (fns: readonly [Spy, Spy]) =&amp;gt; void,
)
/**
   * Asserts that `Deno.test` is called with just the name and function for the `describe` call in the callback function.
   * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
   * This is used to reduce code duplication when testing calling `describe` with different call signatures.
   */
async function assertMinimumOptions(
    cb: (fns: readonly [Spy, Spy]) =&amp;gt; void,
)
/**
   * Asserts that `Deno.test` is called with all of the options for the `describe` call in the callback function.
   * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
   * This is used to reduce code duplication when testing calling `describe` with different call signatures.
   */
async function assertAllOptions(
    cb: (fns: readonly [Spy, Spy]) =&amp;gt; void,
)
⋮----
/**
     * Asserts that `Deno.test` is called with just the name, only, and function for the `describe.only` call in the callback function.
     * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
     * This is used to reduce code duplication when testing calling `describe.only` with different call signatures.
     */
async function assertMinimumOptions(
      cb: (fns: readonly [Spy, Spy]) =&amp;gt; void,
)
/**
     * Asserts that `Deno.test` is called with all of the options for the `describe.only` call in the callback function.
     * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
     * This is used to reduce code duplication when testing calling `describe.only` with different call signatures.
     */
async function assertAllOptions(
      cb: (fns: readonly [Spy, Spy]) =&amp;gt; void,
)
⋮----
/**
     * Asserts that `Deno.test` is called with the correct options for the `describe` call in the callback function.
     * This is used to reduce code duplication when testing calling `describe` with different call signatures.
     */
async function assertIgnoreOptions(
      expectedOptions: Omit&amp;lt;Deno.TestDefinition, &amp;quot;name&amp;quot; | &amp;quot;fn&amp;quot;&amp;gt;,
      cb: (fns: readonly [Spy, Spy]) =&amp;gt; void,
)
/**
     * Asserts that `Deno.test` is called with just the name, ignore, and function for the `describe.ignore` call in the callback function.
     * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
     * This is used to reduce code duplication when testing calling `describe.ignore` with different call signatures.
     */
⋮----
/**
     * Asserts that `Deno.test` is called with all of the options for the `describe.ignore` call in the callback function.
     * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
     * This is used to reduce code duplication when testing calling `describe.ignore` with different call signatures.
     */
⋮----
/**
     * Asserts that when only is used on a nested `describe` or `it` call, it will be the only test case or suite that runs in the file.
     * This is used to reduce code duplication when testing calling `describe.ignore` with different call signatures.
     */
async function assertOnly(
      cb: (fns: readonly [Spy, Spy, Spy]) =&amp;gt; void,
)
⋮----
/**
     * Asserts that when only is used on a child `describe` or `it` call, it will be the only test case or suite that runs within the top test suite.
     * This demonstrates the issue where `Deno.test` is called without `only` even though one of its child steps are focused.
     * This is used to reduce code duplication when testing calling `describe.ignore` with different call signatures.
     */
⋮----
/**
     * Asserts that all the different hook types are called in the correct order when the tests run.
     * This is used to reduce code duplication when testing calling `describe` with different call signatures.
     */
async function assertHooks(
      cb: (
        options: {
          beforeAllFn: Spy;
          afterAllFn: Spy;
          beforeEachFn: Spy;
          afterEachFn: Spy;
          fns: readonly [Spy, Spy];
        },
      ) =&amp;gt; void,
)
⋮----
interface NestedContext extends GlobalContext {
      allTimerNested: number;
      eachTimerNested: number;
      x: number;
      y: number;
    }
⋮----
it(
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// TODO(kt3k): This case should be type error but it&amp;apos;s checked as
// DescribeDefinition&amp;lt;T&amp;gt; and passes the type check
// describe(async function example() {});
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// Ignores runtime errors as this case is for static type checking
⋮----
// deno-lint-ignore no-explicit-any&lt;/file&gt;&lt;file path=&quot;testing/bdd.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
/**
 * A {@link https://en.wikipedia.org/wiki/Behavior-driven_development | BDD} interface
 * to `Deno.test()` API.
 *
 * With `@std/testing/bdd` module you can write your tests in a familiar format for
 * grouping tests and adding setup/teardown hooks used by other JavaScript testing
 * frameworks like Jasmine, Jest, and Mocha.
 *
 * The `describe` function creates a block that groups together several related
 * tests. The `it` function registers an individual test case.
 *
 * ## Hooks
 *
 * There are 4 types of hooks available for test suites. A test suite can have
 * multiples of each type of hook, they will be called in the order that they are
 * registered. The `afterEach` and `afterAll` hooks will be called whether or not
 * the test case passes. The *All hooks will be called once for the whole group
 * while the *Each hooks will be called for each individual test case.
 *
 * - `beforeAll`: Runs before all of the tests in the group.
 * - `afterAll`: Runs after all of the tests in the group finish.
 * - `beforeEach`: Runs before each of the individual test cases in the group.
 * - `afterEach`: Runs after each of the individual test cases in the group.
 *
 * If a hook is registered at the top level, a global test suite will be registered
 * and all tests will belong to it. Hooks registered at the top level must be
 * registered before any individual test cases or test suites.
 *
 * ## Focusing tests
 *
 * If you would like to run only specific test cases, you can do so by calling
 * `it.only` instead of `it`. If you would like to run only specific test suites,
 * you can do so by calling `describe.only` instead of `describe`.
 *
 * There is one limitation to this when using the flat test grouping style. When
 * `describe` is called without being nested, it registers the test with
 * `Deno.test`. If a child test case or suite is registered with `it.only` or
 * `describe.only`, it will be scoped to the top test suite instead of the file. To
 * make them the only tests that run in the file, you would need to register the
 * top test suite with `describe.only` too.
 *
 * ## Ignoring tests
 *
 * If you would like to not run specific individual test cases, you can do so by
 * calling `it.ignore` instead of `it`. If you would like to not run specific test
 * suites, you can do so by calling `describe.ignore` instead of `describe`.
 *
 * ## Sanitization options
 *
 * Like `Deno.TestDefinition`, the `DescribeDefinition` and `ItDefinition` have
 * sanitization options. They work in the same way.
 *
 * - `sanitizeExit`: Ensure the test case does not prematurely cause the process to
 *   exit, for example via a call to Deno.exit. Defaults to true.
 * - `sanitizeOps`: Check that the number of async completed ops after the test is
 *   the same as number of dispatched ops. Defaults to true.
 * - `sanitizeResources`: Ensure the test case does not &amp;quot;leak&amp;quot; resources - ie. the
 *   resource table after the test has exactly the same contents as before the
 *   test. Defaults to true.
 *
 * ## Permissions option
 *
 * Like `Deno.TestDefinition`, the `DescribeDefinition` and `ItDefinition` have a
 * `permissions` option. They specify the permissions that should be used to run an
 * individual test case or test suite. Set this to `&amp;quot;inherit&amp;quot;` to keep the calling
 * thread&amp;apos;s permissions. Set this to `&amp;quot;none&amp;quot;` to revoke all permissions.
 *
 * This setting defaults to `&amp;quot;inherit&amp;quot;`.
 *
 * There is currently one limitation to this, you cannot use the permissions option
 * on an individual test case or test suite that belongs to another test suite.
 * That&amp;apos;s because internally those tests are registered with `t.step` which does
 * not support the permissions option.
 *
 * ## Comparing to Deno\.test
 *
 * The default way of writing tests is using `Deno.test` and `t.step`. The
 * `describe` and `it` functions have similar call signatures to `Deno.test`,
 * making it easy to switch between the default style and the behavior-driven
 * development style of writing tests. Internally, `describe` and `it` are
 * registering tests with `Deno.test` and `t.step`.
 *
 * Below is an example of a test file using `Deno.test` and `t.step`. In the
 * following sections there are examples of how the same test could be written with
 * `describe` and `it` using nested test grouping, flat test grouping, or a mix of
 * both styles.
 *
 * ```ts
 * import {
 *   assertEquals,
 *   assertStrictEquals,
 *   assertThrows,
 * } from &amp;quot;@std/assert&amp;quot;;
 *
 * class User {
 *   static users: Map&amp;lt;string, User&amp;gt; = new Map();
 *   name: string;
 *   age?: number;
 *
 *   constructor(name: string) {
 *     if (User.users.has(name)) {
 *       throw new Deno.errors.AlreadyExists(`User ${name} already exists`);
 *     }
 *     this.name = name;
 *     User.users.set(name, this);
 *   }
 *
 *   getAge(): number {
 *     if (!this.age) {
 *       throw new Error(&amp;quot;Age unknown&amp;quot;);
 *     }
 *     return this.age;
 *   }
 *
 *   setAge(age: number) {
 *     this.age = age;
 *   }
 * }
 *
 * Deno.test(&amp;quot;User.users initially empty&amp;quot;, () =&amp;gt; {
 *   assertEquals(User.users.size, 0);
 * });
 *
 * Deno.test(&amp;quot;User constructor&amp;quot;, () =&amp;gt; {
 *   try {
 *     const user = new User(&amp;quot;Kyle&amp;quot;);
 *     assertEquals(user.name, &amp;quot;Kyle&amp;quot;);
 *     assertStrictEquals(User.users.get(&amp;quot;Kyle&amp;quot;), user);
 *   } finally {
 *     User.users.clear();
 *   }
 * });
 *
 * Deno.test(&amp;quot;User age&amp;quot;, async (t) =&amp;gt; {
 *   const user = new User(&amp;quot;Kyle&amp;quot;);
 *
 *   await t.step(&amp;quot;getAge&amp;quot;, () =&amp;gt; {
 *     assertThrows(() =&amp;gt; user.getAge(), Error, &amp;quot;Age unknown&amp;quot;);
 *     user.age = 18;
 *     assertEquals(user.getAge(), 18);
 *   });
 *
 *   await t.step(&amp;quot;setAge&amp;quot;, () =&amp;gt; {
 *     user.setAge(18);
 *     assertEquals(user.getAge(), 18);
 *   });
 * });
 * ```
 *
 * ### Nested test grouping
 *
 * Tests created within the callback of a `describe` function call will belong to
 * the new test suite it creates. The hooks can be created within it or be added to
 * the options argument for describe.
 *
 * ```ts
 * import {
 *   assertEquals,
 *   assertStrictEquals,
 *   assertThrows,
 * } from &amp;quot;@std/assert&amp;quot;;
 * import {
 *   afterEach,
 *   beforeEach,
 *   describe,
 *   it,
 * } from &amp;quot;@std/testing/bdd&amp;quot;;
 *
 * class User {
 *   static users: Map&amp;lt;string, User&amp;gt; = new Map();
 *   name: string;
 *   age?: number;
 *
 *   constructor(name: string) {
 *     if (User.users.has(name)) {
 *       throw new Deno.errors.AlreadyExists(`User ${name} already exists`);
 *     }
 *     this.name = name;
 *     User.users.set(name, this);
 *   }
 *
 *   getAge(): number {
 *     if (!this.age) {
 *       throw new Error(&amp;quot;Age unknown&amp;quot;);
 *     }
 *     return this.age;
 *   }
 *
 *   setAge(age: number) {
 *     this.age = age;
 *   }
 * }
 *
 * describe(&amp;quot;User&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;users initially empty&amp;quot;, () =&amp;gt; {
 *     assertEquals(User.users.size, 0);
 *   });
 *
 *   it(&amp;quot;constructor&amp;quot;, () =&amp;gt; {
 *     try {
 *       const user = new User(&amp;quot;Kyle&amp;quot;);
 *       assertEquals(user.name, &amp;quot;Kyle&amp;quot;);
 *       assertStrictEquals(User.users.get(&amp;quot;Kyle&amp;quot;), user);
 *     } finally {
 *       User.users.clear();
 *     }
 *   });
 *
 *   describe(&amp;quot;age&amp;quot;, () =&amp;gt; {
 *     let user: User;
 *
 *     beforeEach(() =&amp;gt; {
 *       user = new User(&amp;quot;Kyle&amp;quot;);
 *     });
 *
 *     afterEach(() =&amp;gt; {
 *       User.users.clear();
 *     });
 *
 *     it(&amp;quot;getAge&amp;quot;, function () {
 *       assertThrows(() =&amp;gt; user.getAge(), Error, &amp;quot;Age unknown&amp;quot;);
 *       user.age = 18;
 *       assertEquals(user.getAge(), 18);
 *     });
 *
 *     it(&amp;quot;setAge&amp;quot;, function () {
 *       user.setAge(18);
 *       assertEquals(user.getAge(), 18);
 *     });
 *   });
 * });
 * ```
 *
 * ### Flat test grouping
 *
 * The `describe` function returns a unique symbol that can be used to reference
 * the test suite for adding tests to it without having to create them within a
 * callback. The gives you the ability to have test grouping without any extra
 * indentation in front of the grouped tests.
 *
 * ```ts
 * import {
 *   assertEquals,
 *   assertStrictEquals,
 *   assertThrows,
 * } from &amp;quot;@std/assert&amp;quot;;
 * import {
 *   describe,
 *   it,
 * } from &amp;quot;@std/testing/bdd&amp;quot;;
 *
 * class User {
 *   static users: Map&amp;lt;string, User&amp;gt; = new Map();
 *   name: string;
 *   age?: number;
 *
 *   constructor(name: string) {
 *     if (User.users.has(name)) {
 *       throw new Deno.errors.AlreadyExists(`User ${name} already exists`);
 *     }
 *     this.name = name;
 *     User.users.set(name, this);
 *   }
 *
 *   getAge(): number {
 *     if (!this.age) {
 *       throw new Error(&amp;quot;Age unknown&amp;quot;);
 *     }
 *     return this.age;
 *   }
 *
 *   setAge(age: number) {
 *     this.age = age;
 *   }
 * }
 *
 * const userTests = describe(&amp;quot;User&amp;quot;);
 *
 * it(userTests, &amp;quot;users initially empty&amp;quot;, () =&amp;gt; {
 *   assertEquals(User.users.size, 0);
 * });
 *
 * it(userTests, &amp;quot;constructor&amp;quot;, () =&amp;gt; {
 *   try {
 *     const user = new User(&amp;quot;Kyle&amp;quot;);
 *     assertEquals(user.name, &amp;quot;Kyle&amp;quot;);
 *     assertStrictEquals(User.users.get(&amp;quot;Kyle&amp;quot;), user);
 *   } finally {
 *     User.users.clear();
 *   }
 * });
 *
 * const ageTests = describe({
 *   name: &amp;quot;age&amp;quot;,
 *   suite: userTests,
 *   beforeEach(this: { user: User }) {
 *     this.user = new User(&amp;quot;Kyle&amp;quot;);
 *   },
 *   afterEach() {
 *     User.users.clear();
 *   },
 * });
 *
 * it(ageTests, &amp;quot;getAge&amp;quot;, function () {
 *   const { user } = this;
 *   assertThrows(() =&amp;gt; user.getAge(), Error, &amp;quot;Age unknown&amp;quot;);
 *   user.age = 18;
 *   assertEquals(user.getAge(), 18);
 * });
 *
 * it(ageTests, &amp;quot;setAge&amp;quot;, function () {
 *   const { user } = this;
 *   user.setAge(18);
 *   assertEquals(user.getAge(), 18);
 * });
 * ```
 *
 * ### Mixed test grouping
 *
 * Both nested test grouping and flat test grouping can be used together. This can
 * be useful if you&amp;apos;d like to create deep groupings without all the extra
 * indentation in front of each line.
 *
 * ```ts
 * import {
 *   assertEquals,
 *   assertStrictEquals,
 *   assertThrows,
 * } from &amp;quot;@std/assert&amp;quot;;
 * import {
 *   describe,
 *   it,
 * } from &amp;quot;@std/testing/bdd&amp;quot;;
 *
 * class User {
 *   static users: Map&amp;lt;string, User&amp;gt; = new Map();
 *   name: string;
 *   age?: number;
 *
 *   constructor(name: string) {
 *     if (User.users.has(name)) {
 *       throw new Deno.errors.AlreadyExists(`User ${name} already exists`);
 *     }
 *     this.name = name;
 *     User.users.set(name, this);
 *   }
 *
 *   getAge(): number {
 *     if (!this.age) {
 *       throw new Error(&amp;quot;Age unknown&amp;quot;);
 *     }
 *     return this.age;
 *   }
 *
 *   setAge(age: number) {
 *     this.age = age;
 *   }
 * }
 *
 * describe(&amp;quot;User&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;users initially empty&amp;quot;, () =&amp;gt; {
 *     assertEquals(User.users.size, 0);
 *   });
 *
 *   it(&amp;quot;constructor&amp;quot;, () =&amp;gt; {
 *     try {
 *       const user = new User(&amp;quot;Kyle&amp;quot;);
 *       assertEquals(user.name, &amp;quot;Kyle&amp;quot;);
 *       assertStrictEquals(User.users.get(&amp;quot;Kyle&amp;quot;), user);
 *     } finally {
 *       User.users.clear();
 *     }
 *   });
 *
 *   const ageTests = describe({
 *     name: &amp;quot;age&amp;quot;,
 *     beforeEach(this: { user: User }) {
 *       this.user = new User(&amp;quot;Kyle&amp;quot;);
 *     },
 *     afterEach() {
 *       User.users.clear();
 *     },
 *   });
 *
 *   it(ageTests, &amp;quot;getAge&amp;quot;, function () {
 *     const { user } = this;
 *     assertThrows(() =&amp;gt; user.getAge(), Error, &amp;quot;Age unknown&amp;quot;);
 *     user.age = 18;
 *     assertEquals(user.getAge(), 18);
 *   });
 *
 *   it(ageTests, &amp;quot;setAge&amp;quot;, function () {
 *     const { user } = this;
 *     user.setAge(18);
 *     assertEquals(user.getAge(), 18);
 *   });
 * });
 * ```
 *
 * @module
 */
import { getAssertionState } from &amp;quot;@std/internal/assertion-state&amp;quot;;
import { AssertionError } from &amp;quot;@std/assert/assertion-error&amp;quot;;
import {
  type DescribeDefinition,
  globalSanitizersState,
  type HookNames,
  type ItDefinition,
  type TestSuite,
  TestSuiteInternal,
} from &amp;quot;./_test_suite.ts&amp;quot;;
⋮----
/** The arguments for an ItFunction. */
export type ItArgs&amp;lt;T&amp;gt; =
  | [options: ItDefinition&amp;lt;T&amp;gt;]
  | [
    name: string,
    options: Omit&amp;lt;ItDefinition&amp;lt;T&amp;gt;, &amp;quot;name&amp;quot;&amp;gt;,
  ]
  | [
    name: string,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ]
  | [fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;]
  | [
    name: string,
    options: Omit&amp;lt;ItDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;name&amp;quot;&amp;gt;,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ]
  | [
    options: Omit&amp;lt;ItDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot;&amp;gt;,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ]
  | [
    options: Omit&amp;lt;ItDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;name&amp;quot;&amp;gt;,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    name: string,
    options: Omit&amp;lt;ItDefinition&amp;lt;T&amp;gt;, &amp;quot;name&amp;quot; | &amp;quot;suite&amp;quot;&amp;gt;,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    name: string,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    name: string,
    options: Omit&amp;lt;ItDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;name&amp;quot; | &amp;quot;suite&amp;quot;&amp;gt;,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    options: Omit&amp;lt;ItDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;suite&amp;quot;&amp;gt;,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    options: Omit&amp;lt;ItDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;name&amp;quot; | &amp;quot;suite&amp;quot;&amp;gt;,
    fn: (this: T, t: Deno.TestContext) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
  ];
/** Generates an ItDefinition from ItArgs. */
function itDefinition&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): ItDefinition&amp;lt;T&amp;gt;
/** Registers an individual test case. */
// deno-lint-ignore deno-style-guide/naming-convention
export interface it {
  &amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): void;
  /** Registers an individual test case with only set to true. */
  only&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): void;
  /** Registers an individual test case with ignore set to true. */
  ignore&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): void;
  /**
   * Registers an individual test case with ignore set to true. Alias of
   * `.ignore()`.
   */
  skip&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): void;
}
⋮----
/** Registers an individual test case with only set to true. */
only&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): void;
/** Registers an individual test case with ignore set to true. */
ignore&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): void;
/**
   * Registers an individual test case with ignore set to true. Alias of
   * `.ignore()`.
   */
skip&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): void;
⋮----
/**
 * Registers an individual test case.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function to implement the test case
 * @param args The test case
 */
export function it&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;)
⋮----
async fn(t)
⋮----
/**
 * Only execute this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   it.only(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/**
 * Ignore this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   it.ignore(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/** Skip this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   it.skip(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/**
 * Alias of {@linkcode it}
 *
 * Registers an individual test case.
 *
 * @example Usage
 * ```ts
 * import { test } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * test(&amp;quot;a test case&amp;quot;, () =&amp;gt; {
 *   // test case
 *   assertEquals(2 + 2, 4);
 * });
 * ```
 *
 * @typeParam T The self type of the function to implement the test case
 * @param args The test case
 */
export function test&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;)
/**
 * Only execute this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, test } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   test(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   test.only(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/**
 * Ignore this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, test } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   test(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   test.ignore(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/** Skip this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, test } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   test(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   test.skip(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
function addHook&amp;lt;T&amp;gt;(
  name: HookNames,
  fn: (this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
)
/**
 * Run some shared setup before all of the tests in the group.
 * Useful for async setup in `describe` blocks. Outside them,
 * top-level initialization code should be used instead.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeAll } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * beforeAll(() =&amp;gt; {
 *  console.log(&amp;quot;beforeAll&amp;quot;);
 * });
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the setup behavior.
 */
export function beforeAll&amp;lt;T&amp;gt;(
  fn: (this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
)
/**
 * Alias of {@linkcode beforeAll}
 *
 * Run some shared setup before all of the tests in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, before } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * before(() =&amp;gt; {
 *  console.log(&amp;quot;before&amp;quot;);
 * });
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the setup behavior.
 */
export function before&amp;lt;T&amp;gt;(
  fn: (this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
)
/**
 * Run some shared teardown after all of the tests in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, afterAll } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * afterAll(() =&amp;gt; {
 *  console.log(&amp;quot;afterAll&amp;quot;);
 * });
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the teardown behavior.
 */
export function afterAll&amp;lt;T&amp;gt;(
  fn: (this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
)
/**
 * Alias of {@linkcode afterAll}.
 *
 * Run some shared teardown after all of the tests in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, after } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * after(() =&amp;gt; {
 *  console.log(&amp;quot;after&amp;quot;);
 * });
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the teardown behavior.
 */
export function after&amp;lt;T&amp;gt;(
  fn: (this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
)
/**
 * Run some shared setup before each test in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeEach } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * beforeEach(() =&amp;gt; {
 *  console.log(&amp;quot;beforeEach&amp;quot;);
 * });
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the shared setup behavior
 */
export function beforeEach&amp;lt;T&amp;gt;(
  fn: (this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
)
/**
 * Run some shared teardown after each test in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, afterEach } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * afterEach(() =&amp;gt; {
 *  console.log(&amp;quot;afterEach&amp;quot;);
 * });
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the shared teardown behavior
 */
export function afterEach&amp;lt;T&amp;gt;(
  fn: (this: T) =&amp;gt; void | Promise&amp;lt;void&amp;gt;,
)
/** The arguments for a DescribeFunction. */
export type DescribeArgs&amp;lt;T&amp;gt; =
  | [options: DescribeDefinition&amp;lt;T&amp;gt;]
  | [name: string]
  | [
    name: string,
    options: Omit&amp;lt;DescribeDefinition&amp;lt;T&amp;gt;, &amp;quot;name&amp;quot;&amp;gt;,
  ]
  | [name: string, fn: () =&amp;gt; void | undefined]
  | [fn: () =&amp;gt; void | undefined]
  | [
    name: string,
    options: Omit&amp;lt;DescribeDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;name&amp;quot;&amp;gt;,
    fn: () =&amp;gt; void | undefined,
  ]
  | [
    options: Omit&amp;lt;DescribeDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot;&amp;gt;,
    fn: () =&amp;gt; void | undefined,
  ]
  | [
    options: Omit&amp;lt;DescribeDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;name&amp;quot;&amp;gt;,
    fn: () =&amp;gt; void | undefined,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    name: string,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    name: string,
    options: Omit&amp;lt;DescribeDefinition&amp;lt;T&amp;gt;, &amp;quot;name&amp;quot; | &amp;quot;suite&amp;quot;&amp;gt;,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    name: string,
    fn: () =&amp;gt; void | undefined,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    fn: () =&amp;gt; void | undefined,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    name: string,
    options: Omit&amp;lt;DescribeDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;name&amp;quot; | &amp;quot;suite&amp;quot;&amp;gt;,
    fn: () =&amp;gt; void | undefined,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    options: Omit&amp;lt;DescribeDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;suite&amp;quot;&amp;gt;,
    fn: () =&amp;gt; void | undefined,
  ]
  | [
    suite: TestSuite&amp;lt;T&amp;gt;,
    options: Omit&amp;lt;DescribeDefinition&amp;lt;T&amp;gt;, &amp;quot;fn&amp;quot; | &amp;quot;name&amp;quot; | &amp;quot;suite&amp;quot;&amp;gt;,
    fn: () =&amp;gt; void | undefined,
  ];
/** Generates a DescribeDefinition from DescribeArgs. */
function describeDefinition&amp;lt;T&amp;gt;(
  ...args: DescribeArgs&amp;lt;T&amp;gt;
): DescribeDefinition&amp;lt;T&amp;gt;
/** Registers a test suite. */
// deno-lint-ignore deno-style-guide/naming-convention
export interface describe {
  &amp;lt;T&amp;gt;(...args: DescribeArgs&amp;lt;T&amp;gt;): TestSuite&amp;lt;T&amp;gt;;
  /** Registers a test suite with only set to true. */
  only&amp;lt;T&amp;gt;(...args: DescribeArgs&amp;lt;T&amp;gt;): TestSuite&amp;lt;T&amp;gt;;
  /** Registers a test suite with ignore set to true. */
  ignore&amp;lt;T&amp;gt;(...args: DescribeArgs&amp;lt;T&amp;gt;): TestSuite&amp;lt;T&amp;gt;;
  /** Registers a test suite with ignore set to true. Alias of `.ignore()`. */
  skip&amp;lt;T&amp;gt;(...args: ItArgs&amp;lt;T&amp;gt;): void;
}
⋮----
/** Registers a test suite with only set to true. */
only&amp;lt;T&amp;gt;(...args: DescribeArgs&amp;lt;T&amp;gt;): TestSuite&amp;lt;T&amp;gt;;
/** Registers a test suite with ignore set to true. */
ignore&amp;lt;T&amp;gt;(...args: DescribeArgs&amp;lt;T&amp;gt;): TestSuite&amp;lt;T&amp;gt;;
/** Registers a test suite with ignore set to true. Alias of `.ignore()`. */
⋮----
/**
 * Registers a test suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the test suite body.
 * @param args The test suite body.
 * @returns The test suite
 */
export function describe&amp;lt;T&amp;gt;(
  ...args: DescribeArgs&amp;lt;T&amp;gt;
): TestSuite&amp;lt;T&amp;gt;
/**
 * Only execute this test suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeAll } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 *
 * // Only this test suite will run
 * describe.only(&amp;quot;example 2&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test suite body
 */
⋮----
/**
 * Ignore the test suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeAll } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 *
 * describe.ignore(&amp;quot;example 2&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test suite body
 */
⋮----
/**
 * Skip the test suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeAll } from &amp;quot;@std/testing/bdd&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * describe(&amp;quot;example&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass&amp;quot;, () =&amp;gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 *
 * describe.skip(&amp;quot;example 2&amp;quot;, () =&amp;gt; {
 *   it(&amp;quot;should pass too&amp;quot;, () =&amp;gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test suite body
 */&lt;/file&gt;&lt;file path=&quot;testing/deno.json&quot;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;@std/testing&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.13&amp;quot;,
  &amp;quot;exports&amp;quot;: {
    &amp;quot;./bdd&amp;quot;: &amp;quot;./bdd.ts&amp;quot;,
    &amp;quot;./mock&amp;quot;: &amp;quot;./mock.ts&amp;quot;,
    &amp;quot;./snapshot&amp;quot;: &amp;quot;./snapshot.ts&amp;quot;,
    &amp;quot;./time&amp;quot;: &amp;quot;./time.ts&amp;quot;,
    &amp;quot;./types&amp;quot;: &amp;quot;./types.ts&amp;quot;,
    &amp;quot;./unstable-bdd&amp;quot;: &amp;quot;./unstable_bdd.ts&amp;quot;,
    &amp;quot;./unstable-snapshot&amp;quot;: &amp;quot;./unstable_snapshot.ts&amp;quot;,
    &amp;quot;./unstable-stub&amp;quot;: &amp;quot;./unstable_stub.ts&amp;quot;,
    &amp;quot;./unstable-types&amp;quot;: &amp;quot;./unstable_types.ts&amp;quot;
  }
}&lt;/file&gt;&lt;file path=&quot;testing/mock_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { delay } from &amp;quot;@std/async/delay&amp;quot;;
import {
  assertEquals,
  AssertionError,
  assertNotEquals,
  assertRejects,
  assertThrows,
} from &amp;quot;@std/assert&amp;quot;;
import {
  assertSpyCall,
  assertSpyCallArg,
  assertSpyCallArgs,
  assertSpyCallAsync,
  assertSpyCalls,
  type ExpectedSpyCall,
  type MethodSpy,
  MockError,
  mockSession,
  mockSessionAsync,
  resolvesNext,
  restore,
  returnsArg,
  returnsArgs,
  returnsNext,
  returnsThis,
  type Spy,
  spy,
  type Stub,
  stub,
} from &amp;quot;./mock.ts&amp;quot;;
import { Point, type PointWithExtra, stringifyPoint } from &amp;quot;./_test_utils.ts&amp;quot;;
⋮----
// Check if the returned type is correct:
⋮----
// @ts-expect-error Test if passing incorrect argument types causes an error
⋮----
// @ts-expect-error Test if passing incorrect return type causes an error
⋮----
// Calling assertSpyCall with the correct types should not cause any type errors:
⋮----
override action()
⋮----
class Foo
⋮----
constructor()
⋮----
fn()
⋮----
const obj =
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// This doesn&amp;apos;t test any runtime code, only if the TypeScript types are correct.
⋮----
// @ts-expect-error Stubbing with incorrect argument types should cause a type error
⋮----
// @ts-expect-error Stubbing with an incorrect return type should cause a type error
⋮----
// Stubbing without argument types infers them from the real function
⋮----
// `toExponential()` only exists on `number`, so this will error if _x is not a number
⋮----
// `toLowerCase()` only exists on `string`, so this will error if _y is not a string
⋮----
// Stubbing with returnsNext() should not give any type errors
⋮----
// Stubbing without argument types should not cause any type errors:
⋮----
// Check if the returned type is correct:
⋮----
// @ts-expect-error Test if passing incorrect argument types causes an error
⋮----
// @ts-expect-error Test if passing incorrect return type causes an error
⋮----
// Calling assertSpyCall with the correct types should not cause any type errors
⋮----
// deno-lint-ignore no-explicit-any
⋮----
function assertRestored(expected: boolean[])
⋮----
class ExampleError extends Error
class OtherError extends Error&lt;/file&gt;&lt;file path=&quot;testing/mock.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
/** A mocking and spying library.
 *
 * Test spies are function stand-ins that are used to assert if a function&amp;apos;s
 * internal behavior matches expectations. Test spies on methods keep the original
 * behavior but allow you to test how the method is called and what it returns.
 * Test stubs are an extension of test spies that also replaces the original
 * methods behavior.
 *
 * ## Spying
 *
 * Say we have two functions, `square` and `multiply`, if we want to assert that
 * the `multiply` function is called during execution of the `square` function we
 * need a way to spy on the `multiply` function. There are a few ways to achieve
 * this with Spies, one is to have the `square` function take the `multiply`
 * multiply as a parameter.
 *
 * This way, we can call `square(multiply, value)` in the application code or wrap
 * a spy function around the `multiply` function and call
 * `square(multiplySpy, value)` in the testing code.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * function multiply(a: number, b: number): number {
 *   return a * b;
 * }
 *
 * function square(
 *   multiplyFn: (a: number, b: number) =&amp;gt; number,
 *   value: number,
 * ): number {
 *   return multiplyFn(value, value);
 * }
 *
 * Deno.test(&amp;quot;square calls multiply and returns results&amp;quot;, () =&amp;gt; {
 *   const multiplySpy = spy(multiply);
 *
 *   assertEquals(square(multiplySpy, 5), 25);
 *
 *   // asserts that multiplySpy was called at least once and details about the first call.
 *   assertSpyCall(multiplySpy, 0, {
 *     args: [5, 5],
 *     returned: 25,
 *   });
 *
 *   // asserts that multiplySpy was only called once.
 *   assertSpyCalls(multiplySpy, 1);
 * });
 * ```
 *
 * If you prefer not adding additional parameters for testing purposes only, you
 * can use spy to wrap a method on an object instead. In the following example, the
 * exported `_internals` object has the `multiply` function we want to call as a
 * method and the `square` function calls `_internals.multiply` instead of
 * `multiply`.
 *
 * This way, we can call `square(value)` in both the application code and testing
 * code. Then spy on the `multiply` method on the `_internals` object in the
 * testing code to be able to spy on how the `square` function calls the `multiply`
 * function.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * function multiply(a: number, b: number): number {
 *   return a * b;
 * }
 *
 * function square(value: number): number {
 *   return _internals.multiply(value, value);
 * }
 *
 * const _internals = { multiply };
 *
 * Deno.test(&amp;quot;square calls multiply and returns results&amp;quot;, () =&amp;gt; {
 *   const multiplySpy = spy(_internals, &amp;quot;multiply&amp;quot;);
 *
 *   try {
 *     assertEquals(square(5), 25);
 *   } finally {
 *     // unwraps the multiply method on the _internals object
 *     multiplySpy.restore();
 *   }
 *
 *   // asserts that multiplySpy was called at least once and details about the first call.
 *   assertSpyCall(multiplySpy, 0, {
 *     args: [5, 5],
 *     returned: 25,
 *   });
 *
 *   // asserts that multiplySpy was only called once.
 *   assertSpyCalls(multiplySpy, 1);
 * });
 * ```
 *
 * One difference you may have noticed between these two examples is that in the
 * second we call the `restore` method on `multiplySpy` function. That is needed to
 * remove the spy wrapper from the `_internals` object&amp;apos;s `multiply` method. The
 * `restore` method is called in a finally block to ensure that it is restored
 * whether or not the assertion in the try block is successful. The `restore`
 * method didn&amp;apos;t need to be called in the first example because the `multiply`
 * function was not modified in any way like the `_internals` object was in the
 * second example.
 *
 * Method spys are disposable, meaning that you can have them automatically restore
 * themselves with the `using` keyword. Using this approach is cleaner because you
 * do not need to wrap your assertions in a try statement to ensure you restore the
 * methods before the tests finish.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * function multiply(a: number, b: number): number {
 *   return a * b;
 * }
 *
 * function square(value: number): number {
 *   return _internals.multiply(value, value);
 * }
 *
 * const _internals = { multiply };
 *
 * Deno.test(&amp;quot;square calls multiply and returns results&amp;quot;, () =&amp;gt; {
 *   using multiplySpy = spy(_internals, &amp;quot;multiply&amp;quot;);
 *
 *   assertEquals(square(5), 25);
 *
 *   // asserts that multiplySpy was called at least once and details about the first call.
 *   assertSpyCall(multiplySpy, 0, {
 *     args: [5, 5],
 *     returned: 25,
 *   });
 *
 *   // asserts that multiplySpy was only called once.
 *   assertSpyCalls(multiplySpy, 1);
 * });
 * ```
 *
 * ## Stubbing
 *
 * Say we have two functions, `randomMultiple` and `randomInt`, if we want to
 * assert that `randomInt` is called during execution of `randomMultiple` we need a
 * way to spy on the `randomInt` function. That could be done with either of the
 * spying techniques previously mentioned. To be able to verify that the
 * `randomMultiple` function returns the value we expect it to for what `randomInt`
 * returns, the easiest way would be to replace the `randomInt` function&amp;apos;s behavior
 * with more predictable behavior.
 *
 * You could use the first spying technique to do that but that would require
 * adding a `randomInt` parameter to the `randomMultiple` function.
 *
 * You could also use the second spying technique to do that, but your assertions
 * would not be as predictable due to the `randomInt` function returning random
 * values.
 *
 * Say we want to verify it returns correct values for both negative and positive
 * random integers. We could easily do that with stubbing. The below example is
 * similar to the second spying technique example but instead of passing the call
 * through to the original `randomInt` function, we are going to replace
 * `randomInt` with a function that returns pre-defined values.
 *
 * The mock module includes some helper functions to make creating common stubs
 * easy. The `returnsNext` function takes an array of values we want it to return
 * on consecutive calls.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   returnsNext,
 *   stub,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * function randomInt(lowerBound: number, upperBound: number): number {
 *   return lowerBound + Math.floor(Math.random() * (upperBound - lowerBound));
 * }
 *
 * function randomMultiple(value: number): number {
 *   return value * _internals.randomInt(-10, 10);
 * }
 *
 * const _internals = { randomInt };
 *
 * Deno.test(&amp;quot;randomMultiple uses randomInt to generate random multiples between -10 and 10 times the value&amp;quot;, () =&amp;gt; {
 *   const randomIntStub = stub(_internals, &amp;quot;randomInt&amp;quot;, returnsNext([-3, 3]));
 *
 *   try {
 *     assertEquals(randomMultiple(5), -15);
 *     assertEquals(randomMultiple(5), 15);
 *   } finally {
 *     // unwraps the randomInt method on the _internals object
 *     randomIntStub.restore();
 *   }
 *
 *   // asserts that randomIntStub was called at least once and details about the first call.
 *   assertSpyCall(randomIntStub, 0, {
 *     args: [-10, 10],
 *     returned: -3,
 *   });
 *   // asserts that randomIntStub was called at least twice and details about the second call.
 *   assertSpyCall(randomIntStub, 1, {
 *     args: [-10, 10],
 *     returned: 3,
 *   });
 *
 *   // asserts that randomIntStub was only called twice.
 *   assertSpyCalls(randomIntStub, 2);
 * });
 * ```
 *
 * Like method spys, stubs are disposable, meaning that you can have them automatically
 * restore themselves with the `using` keyword. Using this approach is cleaner because
 * you do not need to wrap your assertions in a try statement to ensure you restore the
 * methods before the tests finish.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   returnsNext,
 *   stub,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * function randomInt(lowerBound: number, upperBound: number): number {
 *   return lowerBound + Math.floor(Math.random() * (upperBound - lowerBound));
 * }
 *
 * function randomMultiple(value: number): number {
 *   return value * _internals.randomInt(-10, 10);
 * }
 *
 * const _internals = { randomInt };
 *
 * Deno.test(&amp;quot;randomMultiple uses randomInt to generate random multiples between -10 and 10 times the value&amp;quot;, () =&amp;gt; {
 *   using randomIntStub = stub(_internals, &amp;quot;randomInt&amp;quot;, returnsNext([-3, 3]));
 *
 *   assertEquals(randomMultiple(5), -15);
 *   assertEquals(randomMultiple(5), 15);
 *
 *   // asserts that randomIntStub was called at least once and details about the first call.
 *   assertSpyCall(randomIntStub, 0, {
 *     args: [-10, 10],
 *     returned: -3,
 *   });
 *   // asserts that randomIntStub was called at least twice and details about the second call.
 *   assertSpyCall(randomIntStub, 1, {
 *     args: [-10, 10],
 *     returned: 3,
 *   });
 *
 *   // asserts that randomIntStub was only called twice.
 *   assertSpyCalls(randomIntStub, 2);
 * });
 * ```
 *
 * ## Faking time
 *
 * Say we have a function that has time based behavior that we would like to test.
 * With real time, that could cause tests to take much longer than they should. If
 * you fake time, you could simulate how your function would behave over time
 * starting from any point in time. Below is an example where we want to test that
 * the callback is called every second.
 *
 * With `FakeTime` we can do that. When the `FakeTime` instance is created, it
 * splits from real time. The `Date`, `setTimeout`, `clearTimeout`, `setInterval`
 * and `clearInterval` globals are replaced with versions that use the fake time
 * until real time is restored. You can control how time ticks forward with the
 * `tick` method on the `FakeTime` instance.
 *
 * ```ts
 * import {
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
 *
 * function secondInterval(cb: () =&amp;gt; void): number {
 *   return setInterval(cb, 1000);
 * }
 *
 * Deno.test(&amp;quot;secondInterval calls callback every second and stops after being cleared&amp;quot;, () =&amp;gt; {
 *   using time = new FakeTime();
 *
 *   const cb = spy();
 *   const intervalId = secondInterval(cb);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 1);
 *   time.tick(3500);
 *   assertSpyCalls(cb, 4);
 *
 *   clearInterval(intervalId);
 *   time.tick(1000);
 *   assertSpyCalls(cb, 4);
 * });
 * ```
 *
 * @module
 */
import { assertEquals } from &amp;quot;@std/assert/equals&amp;quot;;
import { assertIsError } from &amp;quot;@std/assert/is-error&amp;quot;;
import { assertRejects } from &amp;quot;@std/assert/rejects&amp;quot;;
import { AssertionError } from &amp;quot;@std/assert/assertion-error&amp;quot;;
import {
  isSpy,
  registerMock,
  sessions,
  unregisterMock,
} from &amp;quot;./_mock_utils.ts&amp;quot;;
/**
 * An error related to spying on a function or instance method.
 *
 * @example Usage
 * ```ts
 * import { MockError, spy } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertThrows } from &amp;quot;@std/assert&amp;quot;;
 *
 * assertThrows(() =&amp;gt; {
 *   spy({} as any, &amp;quot;no-such-method&amp;quot;);
 * }, MockError);
 * ```
 */
export class MockError extends Error
⋮----
/**
   * Construct MockError
   *
   * @param message The error message.
   */
constructor(message: string)
⋮----
/** Call information recorded by a spy. */
export interface SpyCall&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&amp;gt; {
  /** Arguments passed to a function when called. */
  args: Args;
  /** The value that was returned by a function. */
  returned?: Return;
  /** The error value that was thrown by a function. */
  error?: Error;
  /** The instance that a method was called on. */
  self?: Self;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Arguments passed to a function when called. */
⋮----
/** The value that was returned by a function. */
⋮----
/** The error value that was thrown by a function. */
⋮----
/** The instance that a method was called on. */
⋮----
/** A function or instance method wrapper that records all calls made to it. */
export interface Spy&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&amp;gt; {
  (this: Self, ...args: Args): Return;
  /** The function that is being spied on. */
  original: (this: Self, ...args: Args) =&amp;gt; Return;
  /** Information about calls made to the function or instance method. */
  calls: SpyCall&amp;lt;Self, Args, Return&amp;gt;[];
  /** Whether or not the original instance method has been restored. */
  restored: boolean;
  /** If spying on an instance method, this restores the original instance method. */
  restore(): void;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** The function that is being spied on. */
⋮----
/** Information about calls made to the function or instance method. */
⋮----
/** Whether or not the original instance method has been restored. */
⋮----
/** If spying on an instance method, this restores the original instance method. */
restore(): void;
⋮----
/** An instance method wrapper that records all calls made to it. */
export interface MethodSpy&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&amp;gt; extends Spy&amp;lt;Self, Args, Return&amp;gt;, Disposable {}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Wraps a function with a Spy. */
function functionSpy&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(func?: (this: Self, ...args: Args) =&amp;gt; Return): Spy&amp;lt;Self, Args, Return&amp;gt;
/**
 * Creates a session that tracks all mocks created before it&amp;apos;s restored.
 * If a callback is provided, it restores all mocks created within it.
 *
 * @example Usage
 * ```ts
 * import { mockSession, restore, stub } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals, assertNotEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const setTimeout = globalThis.setTimeout;
 * const id = mockSession();
 *
 * stub(globalThis, &amp;quot;setTimeout&amp;quot;);
 *
 * assertNotEquals(globalThis.setTimeout, setTimeout);
 *
 * restore(id);
 *
 * assertEquals(globalThis.setTimeout, setTimeout);
 * ```
 *
 * @returns The id of the created session.
 */
export function mockSession(): number;
/**
 * Creates a session that tracks all mocks created before it&amp;apos;s restored.
 * If a callback is provided, it restores all mocks created within it.
 *
 * @example Usage
 * ```ts
 * import { mockSession, restore, stub } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals, assertNotEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const setTimeout = globalThis.setTimeout;
 * const session = mockSession(() =&amp;gt; {
 *   stub(globalThis, &amp;quot;setTimeout&amp;quot;);
 *   assertNotEquals(globalThis.setTimeout, setTimeout);
 * });
 *
 * session();
 *
 * assertEquals(globalThis.setTimeout, setTimeout); // stub is restored
 * ```
 *
 * @typeParam Self The self type of the function.
 * @typeParam Args The arguments type of the function.
 * @typeParam Return The return type of the function.
 * @param func The function to be used for the created session.
 * @returns The function to execute the session.
 */
export function mockSession&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  func: (this: Self, ...args: Args) =&amp;gt; Return,
): (this: Self, ...args: Args)
export function mockSession&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  func?: (this: Self, ...args: Args) =&amp;gt; Return,
): number | ((this: Self, ...args: Args) =&amp;gt; Return)
/**
 * Creates an async session that tracks all mocks created before the promise resolves.
 *
 * @example Usage
 * ```ts
 * import { mockSessionAsync, restore, stub } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals, assertNotEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const setTimeout = globalThis.setTimeout;
 * const session = mockSessionAsync(async () =&amp;gt; {
 *   stub(globalThis, &amp;quot;setTimeout&amp;quot;);
 *   assertNotEquals(globalThis.setTimeout, setTimeout);
 * });
 *
 * await session();
 *
 * assertEquals(globalThis.setTimeout, setTimeout); // stub is restored
 * ```
 * @typeParam Self The self type of the function.
 * @typeParam Args The arguments type of the function.
 * @typeParam Return The return type of the function.
 * @param func The function.
 * @returns The return value of the function.
 */
export function mockSessionAsync&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  func: (this: Self, ...args: Args) =&amp;gt; Promise&amp;lt;Return&amp;gt;,
): (this: Self, ...args: Args) =&amp;gt; Promise&amp;lt;Return&amp;gt;
/**
 * Restores all mocks registered in the current session that have not already been restored.
 * If an id is provided, it will restore all mocks registered in the session associed with that id that have not already been restored.
 *
 * @example Usage
 * ```ts
 * import { mockSession, restore, stub } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals, assertNotEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const setTimeout = globalThis.setTimeout;
 *
 * stub(globalThis, &amp;quot;setTimeout&amp;quot;);
 *
 * assertNotEquals(globalThis.setTimeout, setTimeout);
 *
 * restore();
 *
 * assertEquals(globalThis.setTimeout, setTimeout);
 * ```
 *
 * @param id The id of the session to restore. If not provided, all mocks registered in the current session are restored.
 */
export function restore(id?: number)
/** Wraps an instance method with a Spy. */
function methodSpy&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(self: Self, property: keyof Self): MethodSpy&amp;lt;Self, Args, Return&amp;gt;
/** A constructor wrapper that records all calls made to it. */
export interface ConstructorSpy&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
&amp;gt; {
  /** Construct an instance. */
  new (...args: Args): Self;
  /** The function that is being spied on. */
  original: new (...args: Args) =&amp;gt; Self;
  /** Information about calls made to the function or instance method. */
  calls: SpyCall&amp;lt;Self, Args, Self&amp;gt;[];
  /** Whether or not the original instance method has been restored. */
  restored: boolean;
  /** If spying on an instance method, this restores the original instance method. */
  restore(): void;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Construct an instance. */
⋮----
/** The function that is being spied on. */
⋮----
/** Information about calls made to the function or instance method. */
⋮----
/** Whether or not the original instance method has been restored. */
⋮----
/** If spying on an instance method, this restores the original instance method. */
⋮----
/** Wraps a constructor with a Spy. */
function constructorSpy&amp;lt;
  Self,
  Args extends unknown[],
&amp;gt;(
  constructor: new (...args: Args) =&amp;gt; Self,
): ConstructorSpy&amp;lt;Self, Args&amp;gt;
⋮----
// @ts-ignore TS2509: Can&amp;apos;t know the type of `original` statically.
⋮----
// deno-lint-ignore constructor-super
constructor(...args: Args)
⋮----
static restore()
⋮----
/**
 * Utility for extracting the arguments type from a property
 *
 * @internal
 */
export type GetParametersFromProp&amp;lt;
  Self,
  Prop extends keyof Self,
&amp;gt; = Self[Prop] extends (...args: infer Args) =&amp;gt; unknown ? Args
  : unknown[];
/**
 * Utility for extracting the return type from a property
 *
 * @internal
 */
export type GetReturnFromProp&amp;lt;
  Self,
  Prop extends keyof Self,
&amp;gt; // deno-lint-ignore no-explicit-any
 = Self[Prop] extends (...args: any[]) =&amp;gt; infer Return ? Return
  : unknown;
⋮----
&amp;gt; // deno-lint-ignore no-explicit-any
⋮----
/** SpyLink object type. */
export type SpyLike&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&amp;gt; = Spy&amp;lt;Self, Args, Return&amp;gt; | ConstructorSpy&amp;lt;Self, Args&amp;gt;;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Creates a spy function.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy();
 *
 * func();
 * func(1);
 * func(2, 3);
 *
 * assertSpyCalls(func, 3);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(func, 0, { args: [] });
 * assertSpyCall(func, 1, { args: [1] });
 * assertSpyCall(func, 2, { args: [2, 3] });
 * ```
 *
 * @typeParam Self The self type of the function.
 * @typeParam Args The arguments type of the function.
 * @typeParam Return The return type of the function.
 * @returns The spy function.
 */
export function spy&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  Return = undefined,
&amp;gt;(): Spy&amp;lt;Self, Args, Return&amp;gt;;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Create a spy function with the given implementation.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy((a: number, b: number) =&amp;gt; a + b);
 *
 * func(3, 4);
 * func(5, 6);
 *
 * assertSpyCalls(func, 2);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(func, 0, { args: [3, 4], returned: 7 });
 * assertSpyCall(func, 1, { args: [5, 6], returned: 11 });
 * ```
 *
 * @typeParam Self The self type of the function to wrap
 * @typeParam Args The arguments type of the function to wrap
 * @typeParam Return The return type of the function to wrap
 * @param func The function to wrap
 * @returns The wrapped function.
 */
export function spy&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(func: (this: Self, ...args: Args)
/**
 * Create a spy constructor.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * class Foo {
 *   constructor(value: string) {}
 * };
 *
 * const Constructor = spy(Foo);
 *
 * new Constructor(&amp;quot;foo&amp;quot;);
 * new Constructor(&amp;quot;bar&amp;quot;);
 *
 * assertSpyCalls(Constructor, 2);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(Constructor, 0, { args: [&amp;quot;foo&amp;quot;] });
 * assertSpyCall(Constructor, 1, { args: [&amp;quot;bar&amp;quot;] });
 * ```
 *
 * @typeParam Self The type of the instance of the class.
 * @typeParam Args The arguments type of the constructor
 * @param constructor The constructor to spy.
 * @returns The wrapped constructor.
 */
export function spy&amp;lt;
  Self,
  Args extends unknown[],
&amp;gt;(
  constructor: new (...args: Args) =&amp;gt; Self,
): ConstructorSpy&amp;lt;Self, Args&amp;gt;;
/**
 * Wraps a instance method with a Spy.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const obj = {
 *   method(a: number, b: number): number {
 *     return a + b;
 *   },
 * };
 *
 * const methodSpy = spy(obj, &amp;quot;method&amp;quot;);
 *
 * obj.method(1, 2);
 * obj.method(3, 4);
 *
 * assertSpyCalls(methodSpy, 2);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(methodSpy, 0, { args: [1, 2], returned: 3 });
 * assertSpyCall(methodSpy, 1, { args: [3, 4], returned: 7 });
 * ```
 *
 * @typeParam Self The type of the instance to spy the method of.
 * @typeParam Prop The property to spy.
 * @param self The instance to spy.
 * @param property The property of the method to spy.
 * @returns The spy function.
 */
⋮----
export function spy&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  funcOrConstOrSelf?:
    | ((this: Self, ...args: Args) =&amp;gt; Return)
    | (new (...args: Args) =&amp;gt; Self)
    | Self,
  property?: keyof Self,
): SpyLike&amp;lt;Self, Args, Return&amp;gt;
/** An instance method replacement that records all calls made to it. */
export interface Stub&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&amp;gt; extends MethodSpy&amp;lt;Self, Args, Return&amp;gt; {
  /** The function that is used instead of the original. */
  fake: (this: Self, ...args: Args) =&amp;gt; Return;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** The function that is used instead of the original. */
⋮----
/**
 * Replaces an instance method with a Stub with empty implementation.
 *
 * @example Usage
 * ```ts
 * import { stub, assertSpyCalls } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const obj = {
 *   method() {
 *     // some inconventient feature for testing
 *   },
 * };
 *
 * const methodStub = stub(obj, &amp;quot;method&amp;quot;);
 *
 * for (const _ of Array(5)) {
 *   obj.method();
 * }
 *
 * assertSpyCalls(methodStub, 5);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @returns The stub function which replaced the original.
 */
export function stub&amp;lt;
  Self,
  Prop extends keyof Self,
&amp;gt;(
  self: Self,
  property: Prop,
): Stub&amp;lt;Self, GetParametersFromProp&amp;lt;Self, Prop&amp;gt;, GetReturnFromProp&amp;lt;Self, Prop&amp;gt;&amp;gt;;
/**
 * Replaces an instance method with a Stub with the given implementation.
 *
 * @example Usage
 * ```ts
 * import { stub } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const obj = {
 *   method(): number {
 *     return Math.random();
 *   },
 * };
 *
 * const methodStub = stub(obj, &amp;quot;method&amp;quot;, () =&amp;gt; 0.5);
 *
 * assertEquals(obj.method(), 0.5);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @param func The fake implementation of the function.
 * @returns The stub function which replaced the original.
 */
export function stub&amp;lt;
  Self,
  Prop extends keyof Self,
&amp;gt;(
  self: Self,
  property: Prop,
  func: (
    this: Self,
    ...args: GetParametersFromProp&amp;lt;Self, Prop&amp;gt;
  ) =&amp;gt; GetReturnFromProp&amp;lt;Self, Prop&amp;gt;,
): Stub&amp;lt;Self, GetParametersFromProp&amp;lt;Self, Prop&amp;gt;, GetReturnFromProp&amp;lt;Self, Prop&amp;gt;&amp;gt;;
export function stub&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  self: Self,
  property: keyof Self,
  func?: (this: Self, ...args: Args) =&amp;gt; Return,
): Stub&amp;lt;Self, Args, Return&amp;gt;
/**
 * Asserts that a spy is called as much as expected and no more.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCalls, spy } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy();
 *
 * func();
 * func();
 *
 * assertSpyCalls(func, 2);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @param spy The spy to check
 * @param expectedCalls The number of the expected calls.
 */
export function assertSpyCalls&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Return&amp;gt;,
  expectedCalls: number,
)
/** Call information recorded by a spy. */
export interface ExpectedSpyCall&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&amp;gt; {
  /** Arguments passed to a function when called. */
  args?: [...Args, ...unknown[]];
  /** The instance that a method was called on. */
  self?: Self;
  /**
   * The value that was returned by a function.
   * If you expect a promise to reject, expect error instead.
   */
  returned?: Return;
  /** The expected thrown error. */
  error?: {
    /** The class for the error that was thrown by a function. */
    // deno-lint-ignore no-explicit-any
    Class?: new (...args: any[]) =&amp;gt; Error;
    /** Part of the message for the error that was thrown by a function. */
    msgIncludes?: string;
  };
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Arguments passed to a function when called. */
⋮----
/** The instance that a method was called on. */
⋮----
/**
   * The value that was returned by a function.
   * If you expect a promise to reject, expect error instead.
   */
⋮----
/** The expected thrown error. */
⋮----
/** The class for the error that was thrown by a function. */
// deno-lint-ignore no-explicit-any
⋮----
/** Part of the message for the error that was thrown by a function. */
⋮----
function getSpyCall&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Return&amp;gt;,
  callIndex: number,
): SpyCall
/**
 * Asserts that a spy is called as expected.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCall, spy } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy((a: number, b: number) =&amp;gt; a + b);
 *
 * func(3, 4);
 * func(5, 6);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(func, 0, { args: [3, 4], returned: 7 });
 * assertSpyCall(func, 1, { args: [5, 6], returned: 11 });
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @param spy The spy to check
 * @param callIndex The index of the call to check
 * @param expected The expected spy call.
 */
export function assertSpyCall&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Return&amp;gt;,
  callIndex: number,
  expected?: ExpectedSpyCall&amp;lt;Self, Args, Return&amp;gt;,
)
/**
 * Asserts that an async spy is called as expected.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallAsync, spy } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy((a: number, b: number) =&amp;gt; new Promise((resolve) =&amp;gt; {
 *   setTimeout(() =&amp;gt; resolve(a + b), 100)
 * }));
 *
 * await func(3, 4);
 * await func(5, 6);
 *
 * // asserts each call made to the spy function.
 * await assertSpyCallAsync(func, 0, { args: [3, 4], returned: 7 });
 * await assertSpyCallAsync(func, 1, { args: [5, 6], returned: 11 });
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @param spy The spy to check
 * @param callIndex The index of the call to check
 * @param expected The expected spy call.
 */
export async function assertSpyCallAsync&amp;lt;
  Self,
  Args extends unknown[],
  Return,
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Promise&amp;lt;Return&amp;gt;&amp;gt;,
  callIndex: number,
  expected?: ExpectedSpyCall&amp;lt;Self, Args, Promise&amp;lt;Return&amp;gt; | Return&amp;gt;,
)
/**
 * Asserts that a spy is called with a specific arg as expected.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallArg, spy } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy((a: number, b: number) =&amp;gt; a + b);
 *
 * func(3, 4);
 * func(5, 6);
 *
 * // asserts each call made to the spy function.
 * assertSpyCallArg(func, 0, 0, 3);
 * assertSpyCallArg(func, 0, 1, 4);
 * assertSpyCallArg(func, 1, 0, 5);
 * assertSpyCallArg(func, 1, 1, 6);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @typeParam ExpectedArg The expected type of the argument for the spy to be called.
 * @param spy The spy to check.
 * @param callIndex The index of the call to check.
 * @param argIndex The index of the arguments to check.
 * @param expected The expected argument.
 * @returns The actual argument.
 */
export function assertSpyCallArg&amp;lt;
  Self,
  Args extends unknown[],
  Return,
  ExpectedArg,
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Return&amp;gt;,
  callIndex: number,
  argIndex: number,
  expected: ExpectedArg,
): ExpectedArg
/**
 * Asserts that an spy is called with a specific range of args as expected.
 * If a start and end index is not provided, the expected will be compared against all args.
 * If a start is provided without an end index, the expected will be compared against all args from the start index to the end.
 * The end index is not included in the range of args that are compared.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallArgs, spy } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy((a: number, b: number) =&amp;gt; a + b);
 *
 * func(3, 4);
 * func(5, 6);
 *
 * // asserts each call made to the spy function.
 * assertSpyCallArgs(func, 0, [3, 4]);
 * assertSpyCallArgs(func, 1, [5, 6]);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @typeParam ExpectedArgs The expected type of the arguments for the spy to be called.
 * @param spy The spy to check.
 * @param callIndex The index of the call to check.
 * @param expected The expected arguments.
 * @returns The actual arguments.
 */
export function assertSpyCallArgs&amp;lt;
  Self,
  Args extends unknown[],
  Return,
  ExpectedArgs extends unknown[],
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Return&amp;gt;,
  callIndex: number,
  expected: ExpectedArgs,
): ExpectedArgs;
/**
 * Asserts that an spy is called with a specific range of args as expected.
 * If a start and end index is not provided, the expected will be compared against all args.
 * If a start is provided without an end index, the expected will be compared against all args from the start index to the end.
 * The end index is not included in the range of args that are compared.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallArgs, spy } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy((...args) =&amp;gt; {});
 *
 * func(0, 1, 2, 3, 4, 5);
 *
 * assertSpyCallArgs(func, 0, 3, [3, 4, 5]);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @typeParam ExpectedArgs The expected type of the arguments for the spy to be called.
 * @param spy The spy to check.
 * @param callIndex The index of the call to check.
 * @param argsStart The start index of the arguments to check. If not specified, it checks the arguments from the beignning.
 * @param expected The expected arguments.
 * @returns The actual arguments.
 */
export function assertSpyCallArgs&amp;lt;
  Self,
  Args extends unknown[],
  Return,
  ExpectedArgs extends unknown[],
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Return&amp;gt;,
  callIndex: number,
  argsStart: number,
  expected: ExpectedArgs,
): ExpectedArgs;
/**
 * Asserts that an spy is called with a specific range of args as expected.
 * If a start and end index is not provided, the expected will be compared against all args.
 * If a start is provided without an end index, the expected will be compared against all args from the start index to the end.
 * The end index is not included in the range of args that are compared.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallArgs, spy } from &amp;quot;@std/testing/mock&amp;quot;;
 *
 * const func = spy((...args) =&amp;gt; {});
 *
 * func(0, 1, 2, 3, 4, 5);
 *
 * assertSpyCallArgs(func, 0, 3, 4, [3]);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @typeParam ExpectedArgs The expected type of the arguments for the spy to be called.
 * @param spy The spy to check
 * @param callIndex The index of the call to check
 * @param argsStart The start index of the arguments to check. If not specified, it checks the arguments from the beignning.
 * @param argsEnd The end index of the arguments to check. If not specified, it checks the arguments until the end.
 * @param expected The expected arguments.
 * @returns The actual arguments
 */
export function assertSpyCallArgs&amp;lt;
  Self,
  Args extends unknown[],
  Return,
  ExpectedArgs extends unknown[],
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Return&amp;gt;,
  callIndex: number,
  argsStart: number,
  argsEnd: number,
  expected: ExpectedArgs,
): ExpectedArgs;
export function assertSpyCallArgs&amp;lt;
  ExpectedArgs extends unknown[],
  Args extends unknown[],
  Return,
  Self,
&amp;gt;(
  spy: SpyLike&amp;lt;Self, Args, Return&amp;gt;,
  callIndex: number,
  argsStart?: number | ExpectedArgs,
  argsEnd?: number | ExpectedArgs,
  expected?: ExpectedArgs,
): ExpectedArgs
/**
 * Creates a function that returns the instance the method was called on.
 *
 * @example Usage
 * ```ts
 * import { returnsThis } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const func = returnsThis();
 * const obj = { func };
 * assertEquals(obj.func(), obj);
 * ```
 *
 * @typeParam Self The self type of the returned function.
 * @typeParam Args The arguments type of the returned function.
 * @returns A function that returns the instance the method was called on.
 */
export function returnsThis&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
&amp;gt;(): (this: Self, ...args: Args) =&amp;gt; Self
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Creates a function that returns one of its arguments.
 *
 * @example Usage
 * ```ts
 * import { returnsArg } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const func = returnsArg(1);
 * assertEquals(func(1, 2, 3), 2);
 * ```
 *
 * @typeParam Arg The type of returned argument.
 * @typeParam Self The self type of the returned function.
 * @param idx The index of the arguments to use.
 * @returns A function that returns one of its arguments.
 */
export function returnsArg&amp;lt;
  Arg,
  // deno-lint-ignore no-explicit-any
  Self = any,
&amp;gt;(
  idx: number,
): (this: Self, ...args: Arg[]) =&amp;gt; Arg | undefined
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Creates a function that returns its arguments or a subset of them. If end is specified, it will return arguments up to but not including the end.
 *
 * @example Usage
 * ```ts
 * import { returnsArgs } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const func = returnsArgs();
 * assertEquals(func(1, 2, 3), [1, 2, 3]);
 * ```
 *
 * @typeParam Args The arguments type of the returned function
 * @typeParam Self The self type of the returned function
 * @param start The start index of the arguments to return. Default is 0.
 * @param end The end index of the arguments to return.
 * @returns A function that returns its arguments or a subset of them.
 */
export function returnsArgs&amp;lt;
  Args extends unknown[],
  // deno-lint-ignore no-explicit-any
  Self = any,
&amp;gt;(
  start = 0,
  end?: number,
): (this: Self, ...args: Args) =&amp;gt; Args
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Creates a function that returns the iterable values. Any iterable values that are errors will be thrown.
 *
 * @example Usage
 * ```ts
 * import { returnsNext } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals, assertThrows } from &amp;quot;@std/assert&amp;quot;;
 *
 * const func = returnsNext([1, 2, new Error(&amp;quot;foo&amp;quot;), 3]);
 * assertEquals(func(), 1);
 * assertEquals(func(), 2);
 * assertThrows(() =&amp;gt; func(), Error, &amp;quot;foo&amp;quot;);
 * assertEquals(func(), 3);
 * ```
 *
 * @typeParam Return The type of each item of the iterable
 * @typeParam Self The self type of the returned function
 * @typeParam Args The arguments type of the returned function
 * @param values The iterable values
 * @return A function that returns the iterable values
 */
export function returnsNext&amp;lt;
  Return,
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
&amp;gt;(
  values: Iterable&amp;lt;Return | Error&amp;gt;,
): (this: Self, ...args: Args) =&amp;gt; Return
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Creates a function that resolves the awaited iterable values. Any awaited iterable values that are errors will be thrown.
 *
 * @example Usage
 * ```ts
 * import { resolvesNext } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { assertEquals, assertRejects } from &amp;quot;@std/assert&amp;quot;;
 *
 * const func = resolvesNext([1, 2, new Error(&amp;quot;foo&amp;quot;), 3]);
 * assertEquals(await func(), 1);
 * assertEquals(await func(), 2);
 * assertRejects(() =&amp;gt; func(), Error, &amp;quot;foo&amp;quot;);
 * assertEquals(await func(), 3);
 * ```
 *
 * @typeParam Return The type of each item of the iterable
 * @typeParam Self The self type of the returned function
 * @typeParam Args The type of arguments of the returned function
 * @param iterable The iterable to use
 * @returns A function that resolves the awaited iterable values
 */
export function resolvesNext&amp;lt;
  Return,
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
&amp;gt;(
  iterable:
    | Iterable&amp;lt;Return | Error | Promise&amp;lt;Return | Error&amp;gt;&amp;gt;
    | AsyncIterable&amp;lt;Return | Error | Promise&amp;lt;Return | Error&amp;gt;&amp;gt;,
): (this: Self, ...args: Args) =&amp;gt; Promise&amp;lt;Return&amp;gt;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any&lt;/file&gt;&lt;file path=&quot;testing/README.md&quot;&gt;This package provides utilities for testing.
- [BDD style testing](https://jsr.io/@std/testing/doc/bdd/~)
- [Test doubles (mocking)](https://jsr.io/@std/testing/doc/mock/~)
- [Faking time and timers](https://jsr.io/@std/testing/doc/time/~)
- [Snapshot testing](https://jsr.io/@std/testing/doc/snapshot/~)
- [Type assertions](https://jsr.io/@std/testing/doc/types/~)
```ts
import { assertSpyCalls, spy } from &amp;quot;@std/testing/mock&amp;quot;;
import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
function secondInterval(cb: () =&amp;gt; void): number {
  return setInterval(cb, 1000);
}
Deno.test(&amp;quot;secondInterval calls callback every second and stops after being cleared&amp;quot;, () =&amp;gt; {
  using time = new FakeTime();
  const cb = spy();
  const intervalId = secondInterval(cb);
  assertSpyCalls(cb, 0);
  time.tick(500);
  assertSpyCalls(cb, 0);
  time.tick(500);
  assertSpyCalls(cb, 1);
  time.tick(3500);
  assertSpyCalls(cb, 4);
  clearInterval(intervalId);
  time.tick(1000);
  assertSpyCalls(cb, 4);
});
```&lt;/file&gt;&lt;file path=&quot;testing/snapshot_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { stripAnsiCode } from &amp;quot;@std/fmt/colors&amp;quot;;
import { dirname, fromFileUrl, join, toFileUrl } from &amp;quot;@std/path&amp;quot;;
import {
  assert,
  assertInstanceOf,
  AssertionError,
  assertRejects,
  assertStringIncludes,
  fail,
} from &amp;quot;@std/assert&amp;quot;;
import { assertSnapshot, createAssertSnapshot, serialize } from &amp;quot;./snapshot.ts&amp;quot;;
import { ensureDir } from &amp;quot;../fs/ensure_dir.ts&amp;quot;;
⋮----
function formatTestOutput(string: string)
⋮----
// Strip colors and obfuscate any timings
⋮----
function formatTestError(string: string)
⋮----
// Strip colors and remove &amp;quot;Check file:///workspaces/deno_std/testing/.tmp/test.ts&amp;quot;
// as this is always output to stderr
⋮----
function testFnWithTempDir(
  fn: (t: Deno.TestContext, tempDir: string) =&amp;gt; Promise&amp;lt;void&amp;gt;,
)
function testFnWithDifferentTempDir(
  fn: (
    t: Deno.TestContext,
    tempDir1: string,
    tempDir2: string,
  ) =&amp;gt; Promise&amp;lt;void&amp;gt;,
)
class TestClass
⋮----
init()
get getA()
func()
⋮----
await assertSnapshot(t,
⋮----
async function testFailedAssertion&amp;lt;T&amp;gt;(
      snapshot: T,
      actual: T,
): Promise&amp;lt;AssertionError&amp;gt;
⋮----
async function runTest(test: string)
⋮----
async function runTestWithUpdateFlag(test: string)
function assertNoError(error: string)
/**
     * New snapshot
     */
⋮----
/**
     * Existing snapshot - no changes
     */
⋮----
/**
     * Existing snapshot - updates
     */
⋮----
/**
     * Existing snapshots - reverse order 1
     */
⋮----
/**
     * Existing snapshots - reverse order 2
     */
⋮----
/**
     * New snapshot
     */
⋮----
/**
     * Existing snapshot - removes one
     */
⋮----
/**
     * Existing snapshot - removes several
     */
⋮----
async function runTestWithUpdateFlag(test1: string, test2: string)
⋮----
function maskSnapshotCount(output: string)
/**
     * New snapshot
     */
⋮----
/**
     * Existing snapshot - updates
     */
⋮----
// Regression test for https://github.com/denoland/std/issues/2140
// Long strings should not be truncated with ellipsis
⋮----
// Regression test for https://github.com/denoland/std/issues/2144
// Empty arrays should be compacted
⋮----
// Regression test for https://github.com/denoland/std/issues/5155
// Asserting snapshots in update mode without required write permissions&lt;/file&gt;&lt;file path=&quot;testing/snapshot.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
/** A snapshotting library.
 *
 * The `assertSnapshot` function will create a snapshot of a value and compare it
 * to a reference snapshot, which is stored alongside the test file in the
 * `__snapshots__` directory.
 *
 * ```ts
 * // example_test.ts
 * import { assertSnapshot } from &amp;quot;@std/testing/snapshot&amp;quot;;
 *
 * Deno.test(&amp;quot;isSnapshotMatch&amp;quot;, async function (t): Promise&amp;lt;void&amp;gt; {
 *   const a = {
 *     hello: &amp;quot;world!&amp;quot;,
 *     example: 123,
 *   };
 *   await assertSnapshot(t, a);
 * });
 * ```
 *
 * ```ts no-assert
 * // __snapshots__/example_test.ts.snap
 * export const snapshot: Record&amp;lt;string, string&amp;gt; = {};
 *
 * snapshot[&amp;quot;isSnapshotMatch 1&amp;quot;] = `
 * {
 *   example: 123,
 *   hello: &amp;quot;world!&amp;quot;,
 * }
 * `;
 * ```
 *
 * The `assertInlineSnapshot` function will create a snapshot of a value and compare it
 * to a reference snapshot, which is stored in the test file.
 *
 * ```ts
 * // example_test.ts
 * import { assertInlineSnapshot } from &amp;quot;@std/testing/unstable-snapshot&amp;quot;;
 *
 * Deno.test(&amp;quot;isInlineSnapshotMatch&amp;quot;, function (): void {
 *   const a = {
 *     hello: &amp;quot;world!&amp;quot;,
 *     example: 123,
 *   };
 *   assertInlineSnapshot(
 *     a,
 *     `{
 *   hello: &amp;quot;world!&amp;quot;,
 *   example: 123,
 * }`
 *   );
 * });
 * ```
 *
 * If the snapshot of the passed `actual` does not match the expected snapshot,
 * `assertSnapshot` and `assertInlineSnapshot` will throw an `AssertionError`,
 * causing the test to fail.
 *
 * ## Updating Snapshots:
 *
 * When adding new snapshot assertions to your test suite, or when intentionally
 * making changes which cause your snapshots to fail, you can update your snapshots
 * by running the snapshot tests in update mode. Tests can be run in update mode by
 * passing the `--update` or `-u` flag as an argument when running the test. When
 * this flag is passed, then any snapshots which do not match will be updated.
 * When this flag is not passed, tests missing snapshots will fail.
 *
 * ```sh
 * deno test --allow-all -- --update
 * ```
 *
 * In addition, `assertInlineSnapshot` defaults to formatting the test file after
 * updating snapshots. To stop this, pass command `--no-format`:
 *
 * ```sh
 * deno test --allow-all -- --update --no-format
 * ```
 *
 * ## Permissions:
 *
 * When running `assertSnapshot`, the `--allow-read` permission must be enabled, or
 * else any calls to `assertSnapshot` will fail due to insufficient permissions.
 * Additionally, when updating snapshots, the `--allow-write` permission must also
 * be enabled, as this is required in order to update snapshot files.
 *
 * The `assertSnapshot` function will only attempt to read from and write to
 * snapshot files. As such, the allow list for `--allow-read` and `--allow-write`
 * can be limited to only include existing snapshot files, if so desired.
 *
 * If no snapshots are created, `assertInlineSnapshot` does not require any
 * permissions. However, creating snapshots requires `--allow-read` and
 * `--allow-write` on any test files for which new snapshots will be added.
 * Additionally, `--allow-run` is required if any files will be formatted (which is
 * the default if `--no-format` is not specified).
 *
 * ## Options:
 *
 * The `assertSnapshot` and `assertInlineSnapshot` functions optionally accept an
 * options object.
 *
 * ```ts
 * // example_test.ts
 * import { assertSnapshot } from &amp;quot;@std/testing/snapshot&amp;quot;;
 *
 * Deno.test(&amp;quot;isSnapshotMatch&amp;quot;, async function (t): Promise&amp;lt;void&amp;gt; {
 *   const a = {
 *     hello: &amp;quot;world!&amp;quot;,
 *     example: 123,
 *   };
 *   await assertSnapshot(t, a, {
 *     // options
 *   });
 * });
 * ```
 *
 * You can also configure default options for `assertSnapshot` and `assertInlineSnapshot`.
 *
 * ```ts
 * // example_test.ts
 * import { createAssertSnapshot } from &amp;quot;@std/testing/snapshot&amp;quot;;
 * import { createAssertInlineSnapshot } from &amp;quot;@std/testing/unstable-snapshot&amp;quot;;
 *
 * const assertSnapshot = createAssertSnapshot({
 *   // options
 * });
 * const assertInlineSnapshot = createAssertInlineSnapshot({
 *   // options
 * });
 * ```
 *
 * When configuring default options like this, the resulting `assertSnapshot` or
 * `assertInlineSnapshot` function will function the same as the default function exported
 * from thesnapshot module. If passed an optional options object, this will take precedence
 * over the default options, where the value provided for an option differs.
 *
 * It is possible to &amp;quot;extend&amp;quot; an `assertSnapshot` or `assertInlineSnapshot` function which
 * has been configured with default options.
 *
 * ```ts
 * // example_test.ts
 * import { createAssertSnapshot } from &amp;quot;@std/testing/snapshot&amp;quot;;
 * import { stripAnsiCode } from &amp;quot;@std/fmt/colors&amp;quot;;
 *
 * const assertSnapshot = createAssertSnapshot({
 *   dir: &amp;quot;.snaps&amp;quot;,
 * });
 *
 * const assertMonochromeSnapshot = createAssertSnapshot&amp;lt;string&amp;gt;(
 *   { serializer: stripAnsiCode },
 *   assertSnapshot,
 * );
 *
 * Deno.test(&amp;quot;isSnapshotMatch&amp;quot;, async function (t): Promise&amp;lt;void&amp;gt; {
 *   const a = &amp;quot;\x1b[32mThis green text has had its colors stripped\x1b[39m&amp;quot;;
 *   await assertMonochromeSnapshot(t, a);
 * });
 * ```
 *
 * ```ts no-assert
 * // .snaps/example_test.ts.snap
 * export const snapshot: Record&amp;lt;string, string&amp;gt; = {};
 *
 * snapshot[&amp;quot;isSnapshotMatch 1&amp;quot;] = &amp;quot;This green text has had its colors stripped&amp;quot;;
 * ```
 *
 * ## Version Control:
 *
 * Snapshot testing works best when changes to snapshot files are committed
 * alongside other code changes. This allows for changes to reference snapshots to
 * be reviewed along side the code changes that caused them, and ensures that when
 * others pull your changes, their tests will pass without needing to update
 * snapshots locally.
 *
 * @module
 */
import { fromFileUrl } from &amp;quot;@std/path/from-file-url&amp;quot;;
import { parse } from &amp;quot;@std/path/parse&amp;quot;;
import { resolve } from &amp;quot;@std/path/resolve&amp;quot;;
import { toFileUrl } from &amp;quot;@std/path/to-file-url&amp;quot;;
import { ensureFile, ensureFileSync } from &amp;quot;@std/fs/ensure-file&amp;quot;;
import { assert } from &amp;quot;@std/assert/assert&amp;quot;;
import { AssertionError } from &amp;quot;@std/assert/assertion-error&amp;quot;;
import { equal } from &amp;quot;@std/assert/equal&amp;quot;;
import {
  escapeStringForJs,
  getErrorMessage,
  getIsUpdate,
  getOptions,
  getSnapshotNotMatchMessage,
  serialize,
} from &amp;quot;./_snapshot_utils.ts&amp;quot;;
⋮----
/** The mode of snapshot testing. */
export type SnapshotMode = &amp;quot;assert&amp;quot; | &amp;quot;update&amp;quot;;
/** The options for {@linkcode assertSnapshot}. */
export type SnapshotOptions&amp;lt;T = unknown&amp;gt; = {
  /**
   * Snapshot output directory. Snapshot files will be written to this directory.
   * This can be relative to the test directory or an absolute path.
   *
   * If both `dir` and `path` are specified, the `dir` option will be ignored and
   * the `path` option will be handled as normal.
   */
  dir?: string;
  /**
   * Snapshot mode. Defaults to `assert`, unless the `-u` or `--update` flag is
   * passed, in which case this will be set to `update`. This option takes higher
   * priority than the update flag. If the `--update` flag is passed, it will be
   * ignored if the `mode` option is set.
   */
  mode?: SnapshotMode;
  /**
   * Failure message to log when the assertion fails. Specifying this option will
   * cause the diff not to be logged.
   */
  msg?: string;
  /**
   * Name of the snapshot to use in the snapshot file.
   */
  name?: string;
  /**
   * Snapshot output path. The snapshot will be written to this file. This can be
   * a path relative to the test directory or an absolute path.
   *
   * If both `dir` and `path` are specified, the `dir` option will be ignored and
   * the `path` option will be handled as normal.
   */
  path?: string;
  /**
   * Function to use when serializing the snapshot. The default is {@linkcode serialize}.
   */
  serializer?: (actual: T) =&amp;gt; string;
};
⋮----
/**
   * Snapshot output directory. Snapshot files will be written to this directory.
   * This can be relative to the test directory or an absolute path.
   *
   * If both `dir` and `path` are specified, the `dir` option will be ignored and
   * the `path` option will be handled as normal.
   */
⋮----
/**
   * Snapshot mode. Defaults to `assert`, unless the `-u` or `--update` flag is
   * passed, in which case this will be set to `update`. This option takes higher
   * priority than the update flag. If the `--update` flag is passed, it will be
   * ignored if the `mode` option is set.
   */
⋮----
/**
   * Failure message to log when the assertion fails. Specifying this option will
   * cause the diff not to be logged.
   */
⋮----
/**
   * Name of the snapshot to use in the snapshot file.
   */
⋮----
/**
   * Snapshot output path. The snapshot will be written to this file. This can be
   * a path relative to the test directory or an absolute path.
   *
   * If both `dir` and `path` are specified, the `dir` option will be ignored and
   * the `path` option will be handled as normal.
   */
⋮----
/**
   * Function to use when serializing the snapshot. The default is {@linkcode serialize}.
   */
⋮----
class AssertSnapshotContext
⋮----
/**
   * Returns an instance of `AssertSnapshotContext`. This will be retrieved from
   * a cache if an instance was already created for a given snapshot file path.
   */
static fromOptions(
    testContext: Deno.TestContext,
    options: SnapshotOptions,
): AssertSnapshotContext
⋮----
constructor(snapshotFileUrl: URL)
/**
   * Asserts that `this.#currentSnapshots` has been initialized and then returns it.
   *
   * Should only be called when `this.#currentSnapshots` has already been initialized.
   */
⋮----
/**
   * Write updates to the snapshot file and log statistics.
   */
⋮----
// This occurs when `assertSnapshot` is called in &amp;quot;assert&amp;quot; mode but
// the snapshot doesn&amp;apos;t exist and `assertSnapshot` is also called in
// &amp;quot;update&amp;quot; mode. In this case, we have nothing to write to the
// snapshot file so we can just exit early
⋮----
// deno-lint-ignore no-console
⋮----
// deno-lint-ignore no-console
⋮----
// deno-lint-ignore no-console
⋮----
/**
   * Returns `this.#currentSnapshots` and if necessary, tries to initialize it by reading existing
   * snapshots from the snapshot file. If the snapshot mode is `update` and the snapshot file does
   * not exist then it will be created.
   */
⋮----
/**
   * Register a teardown function which writes the snapshot file to disk and logs the number
   * of snapshots updated after all tests have run.
   *
   * This method can safely be called more than once and will only register the teardown
   * function once in a context.
   */
async registerTeardown()
/**
   * Gets the number of snapshots which have been created with the same name and increments
   * the count by 1.
   */
getCount(snapshotName: string)
/**
   * Get an existing snapshot by name or returns `undefined` if the snapshot does not exist.
   */
async getSnapshot(snapshotName: string, options: SnapshotOptions)
/**
   * Update a snapshot by name. Updates will be written to the snapshot file when all tests
   * have run. If the snapshot does not exist, it will be created.
   *
   * Should only be called when mode is `update`.
   */
updateSnapshot(snapshotName: string, snapshot: string)
/**
   * Get the number of updated snapshots.
   */
getUpdatedCount()
/**
   * Add a snapshot to the update queue.
   *
   * Tracks the order in which snapshots were created so that they can be written to
   * the snapshot file in the correct order.
   *
   * Should be called with each snapshot, regardless of the mode, as a future call to
   * `assertSnapshot` could cause updates to be written to the snapshot file if the
   * `update` mode is passed in the options.
   */
pushSnapshotToUpdateQueue(snapshotName: string)
/**
   * Check if exist snapshot
   */
hasSnapshot(snapshotName: string): boolean
⋮----
/**
 * Make an assertion that `actual` matches a snapshot. If the snapshot and `actual` do
 * not match, then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @example Usage
 * ```ts
 * import { assertSnapshot } from &amp;quot;@std/testing/snapshot&amp;quot;;
 *
 * Deno.test(&amp;quot;snapshot&amp;quot;, async (t) =&amp;gt; {
 *   await assertSnapshot&amp;lt;number&amp;gt;(t, 2);
 * });
 * ```
 * @typeParam T The type of the snapshot
 * @param context The test context
 * @param actual The actual value to compare
 * @param options The options
 */
export async function assertSnapshot&amp;lt;T&amp;gt;(
  context: Deno.TestContext,
  actual: T,
  options: SnapshotOptions&amp;lt;T&amp;gt;,
): Promise&amp;lt;void&amp;gt;;
/**
 * Make an assertion that `actual` matches a snapshot. If the snapshot and `actual` do
 * not match, then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @example Usage
 * ```ts
 * import { assertSnapshot } from &amp;quot;@std/testing/snapshot&amp;quot;;
 *
 * Deno.test(&amp;quot;snapshot&amp;quot;, async (t) =&amp;gt; {
 *   await assertSnapshot&amp;lt;number&amp;gt;(t, 2);
 * });
 * ```
 *
 * @typeParam T The type of the snapshot
 * @param context The test context
 * @param actual The actual value to compare
 * @param message The optional assertion message
 */
export async function assertSnapshot&amp;lt;T&amp;gt;(
  context: Deno.TestContext,
  actual: T,
  message?: string,
): Promise&amp;lt;void&amp;gt;;
export async function assertSnapshot(
  context: Deno.TestContext,
  actual: unknown,
  msgOrOpts?: string | SnapshotOptions&amp;lt;unknown&amp;gt;,
)
⋮----
function getTestName(
    context: Deno.TestContext,
    options?: SnapshotOptions,
): string
⋮----
/**
 * Create {@linkcode assertSnapshot} function with the given options.
 *
 * The specified option becomes the default for returned {@linkcode assertSnapshot}
 *
 * @example Usage
 * ```ts
 * import { createAssertSnapshot } from &amp;quot;@std/testing/snapshot&amp;quot;;
 *
 * const assertSnapshot = createAssertSnapshot({
 *   // Uses the custom directory for saving snapshot files.
 *   dir: &amp;quot;my_snapshot_dir&amp;quot;,
 * });
 *
 * Deno.test(&amp;quot;a snapshot test case&amp;quot;, async (t) =&amp;gt; {
 *   await assertSnapshot(t, {
 *     foo: &amp;quot;Hello&amp;quot;,
 *     bar: &amp;quot;World&amp;quot;,
 *   });
 * })
 * ```
 *
 * @typeParam T The type of the snapshot
 * @param options The options
 * @param baseAssertSnapshot {@linkcode assertSnapshot} function implementation. Default to the original {@linkcode assertSnapshot}
 * @returns {@linkcode assertSnapshot} function with the given default options.
 */
export function createAssertSnapshot&amp;lt;T&amp;gt;(
  options: SnapshotOptions&amp;lt;T&amp;gt;,
  baseAssertSnapshot: typeof assertSnapshot = assertSnapshot,
): typeof assertSnapshot&lt;/file&gt;&lt;file path=&quot;testing/time_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import {
  assert,
  assertAlmostEquals,
  assertEquals,
  assertInstanceOf,
  assertMatch,
  assertNotEquals,
  assertRejects,
  assertStrictEquals,
  assertThrows,
} from &amp;quot;@std/assert&amp;quot;;
import { FakeTime, TimeError } from &amp;quot;./time.ts&amp;quot;;
import { _internals } from &amp;quot;./_time.ts&amp;quot;;
import { assertSpyCall, spy, type SpyCall } from &amp;quot;./mock.ts&amp;quot;;
import { deadline, delay } from &amp;quot;@std/async&amp;quot;;
function fromNow(): (..._args: unknown[]) =&amp;gt; number
⋮----
const asyncFn = async () =&amp;gt;
⋮----
// Callback is called by `next`.
⋮----
// Callback is already called before `next` called.
⋮----
// Callbacks are cleared before `next` called.
⋮----
// Callback is partially cleared before `next` called.
⋮----
// Callback is called by `nextAsync`.
⋮----
// Callback is already called before `nextAsync` called.
⋮----
// Callbacks are cleared before `nextAsync` called.
⋮----
// Callback is partially cleared before `nextAsync` called.
⋮----
// https://github.com/denoland/std/issues/5499&lt;/file&gt;&lt;file path=&quot;testing/time.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
/**
 * Utilities for mocking time while testing.
 *
 * ```ts
 * import {
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
 *
 * function secondInterval(cb: () =&amp;gt; void): number {
 *   return setInterval(cb, 1000);
 * }
 *
 * Deno.test(&amp;quot;secondInterval calls callback every second and stops after being cleared&amp;quot;, () =&amp;gt; {
 *   using time = new FakeTime();
 *
 *   const cb = spy();
 *   const intervalId = secondInterval(cb);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 1);
 *   time.tick(3500);
 *   assertSpyCalls(cb, 4);
 *
 *   clearInterval(intervalId);
 *   time.tick(1000);
 *   assertSpyCalls(cb, 4);
 * });
 * ```
 *
 * @module
 */
import { RedBlackTree } from &amp;quot;@std/data-structures/red-black-tree&amp;quot;;
import { ascend } from &amp;quot;@std/data-structures/comparators&amp;quot;;
import type { DelayOptions } from &amp;quot;@std/async/delay&amp;quot;;
import { _internals } from &amp;quot;./_time.ts&amp;quot;;
⋮----
/**
 * Represents an error when trying to execute an invalid operation on fake time,
 * given the state fake time is in.
 *
 * @example Usage
 * ```ts
 * import { FakeTime, TimeError } from &amp;quot;@std/testing/time&amp;quot;;
 * import { assertThrows } from &amp;quot;@std/assert&amp;quot;;
 *
 * assertThrows(() =&amp;gt; {
 *   const time = new FakeTime();
 *   time.restore();
 *   time.restore();
 * }, TimeError);
 * ```
 */
export class TimeError extends Error
⋮----
/** Construct TimeError.
   *
   * @param message The error message
   */
constructor(message: string)
⋮----
function fakeTimeNow()
⋮----
construct(_target, args)
⋮----
// @ts-expect-error this is a passthrough
⋮----
apply(_target, _thisArg, _args)
get(target, prop, receiver)
⋮----
interface Timer {
  id: number;
  // deno-lint-ignore no-explicit-any
  callback: (...args: any[]) =&amp;gt; void;
  delay: number;
  args: unknown[];
  due: number;
  repeat: boolean;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** The option for {@linkcode FakeTime} */
export interface FakeTimeOptions {
  /**
   * The rate relative to real time at which fake time is updated.
   * By default time only moves forward through calling tick or setting now.
   * Set to 1 to have the fake time automatically tick forward at the same rate in milliseconds as real time.
   *
   * @default {0}
   */
  advanceRate: number;
  /**
   * The frequency in milliseconds at which fake time is updated.
   * If advanceRate is set, we will update the time every 10 milliseconds by default.
   *
   * @default {10}
   */
  advanceFrequency?: number;
}
⋮----
/**
   * The rate relative to real time at which fake time is updated.
   * By default time only moves forward through calling tick or setting now.
   * Set to 1 to have the fake time automatically tick forward at the same rate in milliseconds as real time.
   *
   * @default {0}
   */
⋮----
/**
   * The frequency in milliseconds at which fake time is updated.
   * If advanceRate is set, we will update the time every 10 milliseconds by default.
   *
   * @default {10}
   */
⋮----
interface DueNode {
  due: number;
  timers: Timer[];
}
⋮----
function fakeSetTimeout(
  // deno-lint-ignore no-explicit-any
  callback: (...args: any[]) =&amp;gt; void,
  delay = 0,
  // deno-lint-ignore no-explicit-any
  ...args: any[]
): number
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
function fakeClearTimeout(id?: unknown)
function fakeSetInterval(
  // deno-lint-ignore no-explicit-any
  callback: (...args: any[]) =&amp;gt; unknown,
  delay = 0,
  // deno-lint-ignore no-explicit-any
  ...args: any[]
): number
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
function fakeClearInterval(id?: unknown)
function setTimer(
  // deno-lint-ignore no-explicit-any
  callback: (...args: any[]) =&amp;gt; void,
  delay = 0,
  args: unknown[],
  repeat = false,
): number
⋮----
// deno-lint-ignore no-explicit-any
⋮----
function fakeAbortSignalTimeout(delay: number): AbortSignal
function overrideGlobals()
function restoreGlobals()
⋮----
function nextDueNode(): DueNode | null
⋮----
/**
 * Overrides the real Date object and timer functions with fake ones that can be
 * controlled through the fake time instance.
 *
 * Note: there is no setter for the `start` property, as it cannot be changed
 * after initialization.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCalls,
 *   spy,
 * } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
 *
 * function secondInterval(cb: () =&amp;gt; void): number {
 *   return setInterval(cb, 1000);
 * }
 *
 * Deno.test(&amp;quot;secondInterval calls callback every second and stops after being cleared&amp;quot;, () =&amp;gt; {
 *   using time = new FakeTime();
 *
 *   const cb = spy();
 *   const intervalId = secondInterval(cb);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 1);
 *   time.tick(3500);
 *   assertSpyCalls(cb, 4);
 *
 *   clearInterval(intervalId);
 *   time.tick(1000);
 *   assertSpyCalls(cb, 4);
 * });
 * ```
 */
export class FakeTime
⋮----
/**
   * Construct a FakeTime object. This overrides the real Date object and timer functions with fake ones that can be
   * controlled through the fake time instance.
   *
   * @param start The time to simulate. The default is the current time.
   * @param options The options
   *
   * @throws {TimeError} If time is already faked
   * @throws {TypeError} If the start is invalid
   */
constructor(
    start?: number | string | Date | null,
    options?: FakeTimeOptions,
)
/**
   * Restores real time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals, assertNotEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const setTimeout = globalThis.setTimeout;
   *
   * {
   *   using fakeTime = new FakeTime();
   *
   *   assertNotEquals(globalThis.setTimeout, setTimeout);
   *
   *   // test timer related things.
   *
   *   // You don&amp;apos;t need to call fakeTime.restore() explicitly
   *   // as it&amp;apos;s implicitly called via the [Symbol.dispose] method
   *   // when declared with `using`.
   * }
   *
   * assertEquals(globalThis.setTimeout, setTimeout);
   * ```
   */
⋮----
/**
   * Restores real time.
   *
   * @throws {TimeError} If time is already restored
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals, assertNotEquals } from &amp;quot;@std/assert&amp;quot;
   *
   * const setTimeout = globalThis.setTimeout;
   *
   * const fakeTime = new FakeTime();
   *
   * assertNotEquals(globalThis.setTimeout, setTimeout);
   *
   * FakeTime.restore();
   *
   * assertEquals(globalThis.setTimeout, setTimeout);
   * ```
   */
static restore()
/**
   * Restores real time temporarily until callback returns and resolves.
   *
   * @throws {TimeError} If time is not faked
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals, assertNotEquals } from &amp;quot;@std/assert&amp;quot;
   *
   * const setTimeout = globalThis.setTimeout;
   *
   * const fakeTime = new FakeTime();
   *
   * assertNotEquals(globalThis.setTimeout, setTimeout);
   *
   * FakeTime.restoreFor(() =&amp;gt; {
   *   assertEquals(globalThis.setTimeout, setTimeout);
   * });
   * ```
   *
   * @typeParam T The returned value type of the callback
   * @param callback The callback to be called while FakeTime being restored
   * @param args The arguments to pass to the callback
   * @returns The returned value from the callback
   */
static restoreFor&amp;lt;T&amp;gt;(
    // deno-lint-ignore no-explicit-any
    callback: (...args: any[]) =&amp;gt; Promise&amp;lt;T&amp;gt; | T,
    // deno-lint-ignore no-explicit-any
    ...args: any[]
): Promise&amp;lt;T&amp;gt;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
   * The number of milliseconds elapsed since the epoch (January 1, 1970 00:00:00 UTC) for the fake time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * assertEquals(fakeTime.now, 15_000);
   *
   * fakeTime.tick(5_000);
   *
   * assertEquals(fakeTime.now, 20_000);
   * ```
   *
   * @returns The number of milliseconds elapsed since the epoch (January 1, 1970 00:00:00 UTC) for the fake time
   */
get now(): number
/**
   * Set the current time. It will call any functions waiting to be called between the current and new fake time.
   * If the timer callback throws, time will stop advancing forward beyond that timer.
   *
   * @throws {RangeError} If the time goes backwards
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * assertEquals(fakeTime.now, 15_000);
   *
   * fakeTime.now = 35_000;
   *
   * assertEquals(fakeTime.now, 35_000);
   * ```
   *
   * @param value The current time (in milliseconds)
   */
set now(value: number)
/**
   * The initial number of milliseconds elapsed since the epoch (January 1, 1970 00:00:00 UTC) for the fake time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * assertEquals(fakeTime.start, 15_000);
   * ```
   *
   * @returns The initial number of milliseconds elapsed since the epoch (January 1, 1970 00:00:00 UTC) for the fake time.
   */
get start(): number
/**
   * Resolves after the given number of milliseconds using real time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * await fakeTime.delay(500); // wait 500 ms in real time.
   *
   * assertEquals(fakeTime.now, 15_000); // The simulated time doesn&amp;apos;t advance.
   * ```
   *
   * @param ms The milliseconds to delay
   * @param options The options
   */
async delay(ms: number, options: DelayOptions =
⋮----
const abort = ()
const done = () =&amp;gt;
⋮----
/**
   * Runs all pending microtasks.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assert } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let called = false;
   *
   * Promise.resolve().then(() =&amp;gt; { called = true });
   *
   * await fakeTime.runMicrotasks();
   *
   * assert(called);
   * ```
   */
async runMicrotasks()
/**
   * Adds the specified number of milliseconds to the fake time.
   * This will call any functions waiting to be called between the current and new fake time.
   *
   * @example Usage
   * ```ts
   * import {
   *   assertSpyCalls,
   *   spy,
   * } from &amp;quot;@std/testing/mock&amp;quot;;
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   *
   * function secondInterval(cb: () =&amp;gt; void): number {
   *   return setInterval(cb, 1000);
   * }
   *
   * Deno.test(&amp;quot;secondInterval calls callback every second and stops after being cleared&amp;quot;, () =&amp;gt; {
   *   using time = new FakeTime();
   *
   *   const cb = spy();
   *   const intervalId = secondInterval(cb);
   *   assertSpyCalls(cb, 0);
   *   time.tick(500);
   *   assertSpyCalls(cb, 0);
   *   time.tick(500);
   *   assertSpyCalls(cb, 1);
   *   time.tick(3500);
   *   assertSpyCalls(cb, 4);
   *
   *   clearInterval(intervalId);
   *   time.tick(1000);
   *   assertSpyCalls(cb, 4);
   * });
   * ```
   *
   * @param ms The milliseconds to advance
   */
tick(ms = 0)
/**
   * Runs all pending microtasks then adds the specified number of milliseconds to the fake time.
   * This will call any functions waiting to be called between the current and new fake time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assert, assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let called = false;
   *
   * Promise.resolve().then(() =&amp;gt; { called = true });
   *
   * await fakeTime.tickAsync(5_000);
   *
   * assert(called);
   * assertEquals(fakeTime.now, 20_000);
   * ```
   *
   * @param ms The milliseconds to advance
   */
async tickAsync(ms = 0)
/**
   * Advances time to when the next scheduled timer is due.
   * If there are no pending timers, time will not be changed.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assert, assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let called = false;
   *
   * setTimeout(() =&amp;gt; { called = true }, 5000);
   *
   * fakeTime.next();
   *
   * assert(called);
   * assertEquals(fakeTime.now, 20_000);
   * ```
   *
   * @returns `true` when there is a scheduled timer and `false` when there is not.
   */
next(): boolean
/**
   * Runs all pending microtasks then advances time to when the next scheduled timer is due.
   * If there are no pending timers, time will not be changed.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assert, assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let called0 = false;
   * let called1 = false;
   *
   * setTimeout(() =&amp;gt; { called0 = true }, 5000);
   * Promise.resolve().then(() =&amp;gt; { called1 = true });
   *
   * await fakeTime.nextAsync();
   *
   * assert(called0);
   * assert(called1);
   * assertEquals(fakeTime.now, 20_000);
   * ```
   *
   * @returns `true` if the pending timers existed and the time advanced, `false` if there was no pending timer and the time didn&amp;apos;t advance.
   */
async nextAsync(): Promise&amp;lt;boolean&amp;gt;
/**
   * Advances time forward to the next due timer until there are no pending timers remaining.
   * If the timers create additional timers, they will be run too. If there is an interval,
   * time will keep advancing forward until the interval is cleared.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let count = 0;
   *
   * setTimeout(() =&amp;gt; { count++ }, 5_000);
   * setTimeout(() =&amp;gt; { count++ }, 15_000);
   * setTimeout(() =&amp;gt; { count++ }, 35_000);
   *
   * fakeTime.runAll();
   *
   * assertEquals(count, 3);
   * assertEquals(fakeTime.now, 50_000);
   * ```
   */
runAll()
/**
   * Advances time forward to the next due timer until there are no pending timers remaining.
   * If the timers create additional timers, they will be run too. If there is an interval,
   * time will keep advancing forward until the interval is cleared.
   * Runs all pending microtasks before each timer.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let count = 0;
   *
   * setTimeout(() =&amp;gt; { count++ }, 5_000);
   * setTimeout(() =&amp;gt; { count++ }, 15_000);
   * setTimeout(() =&amp;gt; { count++ }, 35_000);
   * Promise.resolve().then(() =&amp;gt; { count++ });
   *
   * await fakeTime.runAllAsync();
   *
   * assertEquals(count, 4);
   * assertEquals(fakeTime.now, 50_000);
   * ```
   */
async runAllAsync()
/**
   * Restores time related global functions to their original state.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &amp;quot;@std/testing/time&amp;quot;;
   * import { assertEquals, assertNotEquals } from &amp;quot;@std/assert&amp;quot;;
   *
   * const setTimeout = globalThis.setTimeout;
   *
   * const fakeTime = new FakeTime(); // global timers are now faked
   *
   * assertNotEquals(globalThis.setTimeout, setTimeout);
   *
   * fakeTime.restore(); // timers are restored
   *
   * assertEquals(globalThis.setTimeout, setTimeout);
   * ```
   */
restore()&lt;/file&gt;&lt;file path=&quot;testing/types_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
// Copyright @dsherret and dsherret/conditional-type-checks contributors. All rights reserved. MIT license.
// deno-lint-ignore-file no-explicit-any ban-types
import {
  type Assert,
  type AssertFalse,
  type AssertTrue,
  assertType,
  type Has,
  type IsAny,
  type IsExact,
  type IsNever,
  type IsNullable,
  type IsUnknown,
  type NotHas,
} from &amp;quot;./types.ts&amp;quot;;
// IsNullable
⋮----
// matching
⋮----
assertType&amp;lt;IsNullable&amp;lt;null | undefined&amp;gt;&amp;gt;(true); // maybe this shouldn&amp;apos;t be true?
// not matching
⋮----
// IsExact
⋮----
class _Class&amp;lt;T&amp;gt;
⋮----
constructor(prop: T)
⋮----
// matching
⋮----
assertType&amp;lt;IsExact&amp;lt;any, any&amp;gt;&amp;gt;(true); // ok to have any for both
⋮----
// not matching
⋮----
assertType&amp;lt;IsExact&amp;lt;{ prop: string | undefined }, { prop?: string }&amp;gt;&amp;gt;(false); // these are different
⋮----
// Has
⋮----
// matching
⋮----
assertType&amp;lt;Has&amp;lt;string | number, Date | string&amp;gt;&amp;gt;(true); // maybe?
⋮----
// not matching
⋮----
// NotHas
⋮----
// matching
⋮----
// not matching
⋮----
assertType&amp;lt;NotHas&amp;lt;string | number, Date | string&amp;gt;&amp;gt;(false); // should be true?
⋮----
// IsAny
⋮----
// matching
⋮----
// not matching
⋮----
// tests for issue #3 (IsAny resolving to boolean)
⋮----
// IsNever
⋮----
// matching
⋮----
// not matching
⋮----
// IsUnknown
⋮----
// matching
⋮----
// not matching
⋮----
// AssertTrue
⋮----
type Test = AssertTrue&amp;lt;IsNever&amp;lt;never&amp;gt;&amp;gt;;
⋮----
// AssertFalse
⋮----
type Test = AssertFalse&amp;lt;IsNever&amp;lt;string&amp;gt;&amp;gt;;
⋮----
// Assert
⋮----
type Test =
    | Assert&amp;lt;Has&amp;lt;string | number, number&amp;gt;, true&amp;gt;
    | Assert&amp;lt;Has&amp;lt;string | number, Date&amp;gt;, false&amp;gt;;
⋮----
// Recursive types
⋮----
type RecursiveType1 = string | number | Date | RecursiveType1[];
⋮----
type RecursiveType2 = {
    a: string;
    prop: RecursiveType2;
    sub: {
      prop: RecursiveType2;
      other: RecursiveType1;
    };
  };&lt;/file&gt;&lt;file path=&quot;testing/types.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
// Copyright @dsherret and dsherret/conditional-type-checks contributors. All rights reserved. MIT license.
/**
 * Testing utilities for types.
 *
 * ```ts expect-error ignore
 * import { assertType, IsExact, IsNullable } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * const result = &amp;quot;some result&amp;quot; as string | number;
 *
 * // compile error if the type of `result` is not exactly `string | number`
 * assertType&amp;lt;IsExact&amp;lt;typeof result, string | number&amp;gt;&amp;gt;(true);
 *
 * // causes a compile error that `true` is not assignable to `false`
 * assertType&amp;lt;IsNullable&amp;lt;string&amp;gt;&amp;gt;(true); // error: string is not nullable
 * ```
 *
 * @module
 */
/**
 * Asserts at compile time that the provided type argument&amp;apos;s type resolves to the expected boolean literal type.
 *
 * @example Usage
 * ```ts expect-error ignore
 * import { assertType, IsExact, IsNullable } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * const result = &amp;quot;some result&amp;quot; as string | number;
 *
 * // compile error if the type of `result` is not exactly `string | number`
 * assertType&amp;lt;IsExact&amp;lt;typeof result, string | number&amp;gt;&amp;gt;(true);
 *
 * // causes a compile error that `true` is not assignable to `false`
 * assertType&amp;lt;IsNullable&amp;lt;string&amp;gt;&amp;gt;(true); // error: string is not nullable
 * ```
 *
 * @typeParam T The expected type (`true` or `false`)
 * @param expectTrue True if the passed in type argument resolved to true.
 */
export function assertType&amp;lt;T extends boolean&amp;gt;(
⋮----
// deno-lint-ignore no-unused-vars
⋮----
/**
 * Asserts at compile time that the provided type argument&amp;apos;s type resolves to true.
 *
 * @example Usage
 * ```ts
 * import { AssertTrue, Has, IsNullable } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * const result = 1 as string | number | null;
 *
 * type doTest = AssertTrue&amp;lt;Has&amp;lt;typeof result, string&amp;gt; | IsNullable&amp;lt;typeof result&amp;gt;&amp;gt;;
 * ```
 *
 * @typeParam T The type to assert is true.
 */
export type AssertTrue&amp;lt;T extends true&amp;gt; = never;
/**
 * Asserts at compile time that the provided type argument&amp;apos;s type resolves to false.
 *
 * @example Usage
 * ```ts
 * import { AssertFalse, IsNever } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * const result = 1 as string | number | null;
 *
 * type doTest = AssertFalse&amp;lt;IsNever&amp;lt;typeof result&amp;gt;&amp;gt;;
 * ```
 *
 * @typeParam T The type to assert is false.
 */
export type AssertFalse&amp;lt;T extends false&amp;gt; = never;
/**
 * Asserts at compile time that the provided type argument&amp;apos;s type resolves to the expected boolean literal type.
 *
 * @example Usage
 * ```ts
 * import { Assert, Has } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * const result = 1 as string | number | null;
 *
 * type doTest = Assert&amp;lt;Has&amp;lt;typeof result, number&amp;gt;, true&amp;gt;;
 * ```
 *
 * @typeParam T The type to assert is the expected boolean literal type.
 * @typeParam Expected The expected boolean literal type.
 */
export type Assert&amp;lt;T extends boolean, Expected extends T&amp;gt; = never;
/**
 * Checks if type `T` has the specified type `U`.
 *
 * @example Usage
 * ```ts
 * import { assertType, Has } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * assertType&amp;lt;Has&amp;lt;string | number, string&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;Has&amp;lt;any, number&amp;gt;&amp;gt;(true);
 *
 * assertType&amp;lt;Has&amp;lt;string | number, Date&amp;gt;&amp;gt;(false);
 * assertType&amp;lt;Has&amp;lt;string, number&amp;gt;&amp;gt;(false);
 * assertType&amp;lt;Has&amp;lt;number, any&amp;gt;&amp;gt;(false);
 * ```
 *
 * @typeParam T The type to check if it has the specified type `U`.
 * @typeParam U The type to check if it is in the type `T`.
 */
export type Has&amp;lt;T, U&amp;gt; = IsAny&amp;lt;T&amp;gt; extends true ? true
  : IsAny&amp;lt;U&amp;gt; extends true ? false
  : Extract&amp;lt;T, U&amp;gt; extends never ? false
  : true;
/**
 * Checks if type `T` does not have the specified type `U`.
 *
 * @example Usage
 * ```ts
 * import { assertType, NotHas } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * assertType&amp;lt;NotHas&amp;lt;string | number, Date&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;NotHas&amp;lt;string, number&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;NotHas&amp;lt;number, any&amp;gt;&amp;gt;(true);
 *
 * assertType&amp;lt;NotHas&amp;lt;string | number, string&amp;gt;&amp;gt;(false);
 * assertType&amp;lt;NotHas&amp;lt;any, number&amp;gt;&amp;gt;(false);
 * ```
 *
 * @typeParam T The type to check if it does not have the specified type `U`.
 * @typeParam U The type to check if it is not in the type `T`.
 */
export type NotHas&amp;lt;T, U&amp;gt; = Has&amp;lt;T, U&amp;gt; extends false ? true : false;
/**
 * Checks if type `T` is possibly null or undefined.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsNullable } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * assertType&amp;lt;IsNullable&amp;lt;string | null&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;IsNullable&amp;lt;string | undefined&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;IsNullable&amp;lt;null | undefined&amp;gt;&amp;gt;(true);
 *
 * assertType&amp;lt;IsNullable&amp;lt;string&amp;gt;&amp;gt;(false);
 * assertType&amp;lt;IsNullable&amp;lt;any&amp;gt;&amp;gt;(false);
 * assertType&amp;lt;IsNullable&amp;lt;never&amp;gt;&amp;gt;(false);
 * ```
 *
 * @typeParam T The type to check if it is nullable.
 */
export type IsNullable&amp;lt;T&amp;gt; = Extract&amp;lt;T, null | undefined&amp;gt; extends never ? false
  : true;
/**
 * Checks if type `T` exactly matches type `U`.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsExact } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * assertType&amp;lt;IsExact&amp;lt;string | number, string | number&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;IsExact&amp;lt;any, any&amp;gt;&amp;gt;(true); // ok to have any for both
 * assertType&amp;lt;IsExact&amp;lt;never, never&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;IsExact&amp;lt;{ prop: string }, { prop: string }&amp;gt;&amp;gt;(true);
 *
 * assertType&amp;lt;IsExact&amp;lt;string | number | Date, string | number&amp;gt;&amp;gt;(false);
 * assertType&amp;lt;IsExact&amp;lt;string, string | number&amp;gt;&amp;gt;(false);
 * assertType&amp;lt;IsExact&amp;lt;string | undefined, string&amp;gt;&amp;gt;(false);
 * assertType&amp;lt;IsExact&amp;lt;string | undefined, any | string&amp;gt;&amp;gt;(false);
 * ```
 *
 * @typeParam T The type to check if it exactly matches type `U`.
 * @typeParam U The type to check if it exactly matches type `T`.
 */
export type IsExact&amp;lt;T, U&amp;gt; = ParametersAndReturnTypeMatches&amp;lt;
  FlatType&amp;lt;AnyToBrand&amp;lt;T&amp;gt;&amp;gt;,
  FlatType&amp;lt;AnyToBrand&amp;lt;U&amp;gt;&amp;gt;
&amp;gt; extends true ? ParametersAndReturnTypeMatches&amp;lt;
    FlatType&amp;lt;DeepPrepareIsExact&amp;lt;T&amp;gt;&amp;gt;,
    FlatType&amp;lt;DeepPrepareIsExact&amp;lt;U&amp;gt;&amp;gt;
  &amp;gt; extends true ? true
  : false
  : false;
/** @internal */
export type DeepPrepareIsExact&amp;lt;T, VisitedTypes = never&amp;gt; = {
  // make optional properties required
  [P in keyof T]-?: IsAny&amp;lt;T[P]&amp;gt; extends true ? AnyBrand
    : DeepPrepareIsExactProp&amp;lt;T[P], T, VisitedTypes&amp;gt;;
};
⋮----
// make optional properties required
⋮----
/** @internal */
export type DeepPrepareIsExactProp&amp;lt;Prop, Parent, VisitedTypes&amp;gt; = Prop extends
  VisitedTypes
  // recursive, bail
  ? Prop
  // not recursive, keep going and add the parent type as a visited type
  : DeepPrepareIsExact&amp;lt;Prop, VisitedTypes | Parent&amp;gt;;
⋮----
// recursive, bail
⋮----
// not recursive, keep going and add the parent type as a visited type
⋮----
/**
 * Checks if type `T` is the `any` type.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsAny } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * assertType&amp;lt;IsAny&amp;lt;any&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;IsAny&amp;lt;unknown&amp;gt;&amp;gt;(false);
 * ```
 *
 * @typeParam T The type to check if it is the `any` type.
 */
// https://stackoverflow.com/a/49928360/3406963
export type IsAny&amp;lt;T&amp;gt; = 0 extends (1 &amp;amp; T) ? true : false;
/**
 * Checks if type `T` is the `never` type.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsNever } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * assertType&amp;lt;IsNever&amp;lt;never&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;IsNever&amp;lt;unknown&amp;gt;&amp;gt;(false);
 * ```
 *
 * @typeParam T The type to check if it is the `never` type.
 */
export type IsNever&amp;lt;T&amp;gt; = [T] extends [never] ? true : false;
/**
 * Checks if type `T` is the `unknown` type.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsUnknown } from &amp;quot;@std/testing/types&amp;quot;;
 *
 * assertType&amp;lt;IsUnknown&amp;lt;unknown&amp;gt;&amp;gt;(true);
 * assertType&amp;lt;IsUnknown&amp;lt;never&amp;gt;&amp;gt;(false);
 * ```
 *
 * @typeParam T The type to check if it is the `unknown` type.
 */
export type IsUnknown&amp;lt;T&amp;gt; = unknown extends T
  ? ([T] extends [null] ? false : true)
  : false;
/**
 * The internal utility type to match the given types as return types.
 *
 * @internal
 */
export type ParametersAndReturnTypeMatches&amp;lt;T, U&amp;gt; = Matches&amp;lt;
  &amp;lt;X&amp;gt;(_: T) =&amp;gt; X extends T ? 1 : 2,
  &amp;lt;X&amp;gt;(_: U) =&amp;gt; X extends U ? 1 : 2
&amp;gt;;
/**
 * The internal utility type to match the given types as tuples.
 *
 * @internal
 */
export type TupleMatches&amp;lt;T, U&amp;gt; = Matches&amp;lt;[T], [U]&amp;gt;;
/**
 * The internal utility type to match the given types.
 *
 * @internal
 */
export type Matches&amp;lt;T, U&amp;gt; = T extends U ? U extends T ? true : false : false;
/**
 * The utility type to convert any to {@linkcode AnyBrand}.
 *
 * @internal
 */
export type AnyToBrand&amp;lt;T&amp;gt; = IsAny&amp;lt;T&amp;gt; extends true ? AnyBrand : T;
/**
 * The utility type to represent any type.
 *
 * @internal
 */
export type AnyBrand = { __conditionalTypeChecksAny__: undefined };
/**
 * The utility type to flatten record types.
 *
 * @internal
 */
export type FlatType&amp;lt;T&amp;gt; = T extends Record&amp;lt;PropertyKey, unknown&amp;gt;
  ? { [K in keyof T]: FlatType&amp;lt;T[K]&amp;gt; }
  : T;&lt;/file&gt;&lt;file path=&quot;testing/unstable_bdd_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { assertEquals } from &amp;quot;@std/assert&amp;quot;;&lt;/file&gt;&lt;file path=&quot;testing/unstable_bdd.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { globalSanitizersState } from &amp;quot;./_test_suite.ts&amp;quot;;
/** Options for {@linkcode configureGlobalSanitizers}. */
export type ConfigureGlobalSanitizersOptions = {
  sanitizeOps?: boolean;
  sanitizeResources?: boolean;
  sanitizeExit?: boolean;
};
/**
 * Configures the global sanitizers.
 * @param options The options
 * @example Usage
 * ```ts no-assert
 * import { configureGlobalSanitizers } from &amp;quot;@std/testing/unstable-bdd&amp;quot;;
 * configureGlobalSanitizers({ sanitizeResources: false })
 * ```
 */
export function configureGlobalSanitizers(
  options: ConfigureGlobalSanitizersOptions,
): void&lt;/file&gt;&lt;file path=&quot;testing/unstable_snapshot_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { stripAnsiCode } from &amp;quot;@std/fmt/colors&amp;quot;;
import { dirname, fromFileUrl, join, toFileUrl } from &amp;quot;@std/path&amp;quot;;
import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
import {
  assertInlineSnapshot,
  createAssertInlineSnapshot,
} from &amp;quot;./unstable_snapshot.ts&amp;quot;;
import { LINT_SUPPORTED } from &amp;quot;./_snapshot_utils.ts&amp;quot;;
⋮----
class TestClass
⋮----
init()
get getA()
func()
⋮----&lt;/file&gt;&lt;file path=&quot;testing/unstable_snapshot.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
// @ts-nocheck Deno.lint namespace does not pass type checking in Deno 1.x
import type { SnapshotOptions } from &amp;quot;./snapshot.ts&amp;quot;;
import { AssertionError } from &amp;quot;@std/assert/assertion-error&amp;quot;;
import { equal } from &amp;quot;@std/assert/equal&amp;quot;;
import {
  escapeStringForJs,
  getIsUpdate,
  getOptions,
  getSnapshotNotMatchMessage,
  LINT_SUPPORTED,
  serialize,
} from &amp;quot;./_snapshot_utils.ts&amp;quot;;
/**
 * The options for {@linkcode assertInlineSnapshot}.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 */
export interface InlineSnapshotOptions&amp;lt;T = unknown&amp;gt;
  extends Pick&amp;lt;SnapshotOptions&amp;lt;T&amp;gt;, &amp;quot;msg&amp;quot; | &amp;quot;serializer&amp;quot;&amp;gt; {}
interface ErrorLocation {
  lineNumber: number;
  columnNumber: number;
}
interface SnapshotUpdateRequest {
  fileName: string;
  lineNumber: number;
  columnNumber: number;
  actualSnapshot: string;
}
// See https://v8.dev/docs/stack-trace-api
type V8Error = typeof Error &amp;amp; {
  prepareStackTrace(error: Error, structuredStackTrace: CallSite[]): unknown;
};
⋮----
prepareStackTrace(error: Error, structuredStackTrace: CallSite[]): unknown;
⋮----
// See https://v8.dev/docs/stack-trace-api
interface CallSite {
  isEval(): boolean;
  getFileName(): string | null;
  getLineNumber(): number | null;
  getColumnNumber(): number | null;
}
⋮----
isEval(): boolean;
getFileName(): string | null;
getLineNumber(): number | null;
getColumnNumber(): number | null;
⋮----
function makeSnapshotUpdater(
  updateRequests: SnapshotUpdateRequest[],
): Deno.lint.Plugin
⋮----
create(context)
⋮----
// TODO(WWRS): Add \u2028 and \u2029 once Deno counts them as line breaks
⋮----
// Since lineNumber is 1-indexed, subtract 1 to convert to 0-indexed.
// Then fetch the line break before this line, which is the (n-1)th break,
// or 0 if this is the top line (index 0).
⋮----
// Fetching all functions lets us support createAssertInlineSnapshot
⋮----
fix(fixer)
⋮----
function updateSnapshots()
⋮----
// Apply the fixes in order
⋮----
// deno-lint-ignore no-console
⋮----
/**
 * Make an assertion that `actual` matches `expectedSnapshot`. If they do not match,
 * then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Usage
 * ```ts no-assert
 * import { assertInlineSnapshot } from &amp;quot;@std/testing/unstable-snapshot&amp;quot;;
 *
 * Deno.test(&amp;quot;snapshot&amp;quot;, () =&amp;gt; {
 *   assertInlineSnapshot&amp;lt;number&amp;gt;(2, `2`);
 * });
 * ```
 * @typeParam T The type of the snapshot
 * @param actual The actual value to compare
 * @param expectedSnapshot The expected snapshot, or \`CREATE\` to create
 * @param options The options
 */
export function assertInlineSnapshot&amp;lt;T&amp;gt;(
  actual: T,
  expectedSnapshot: string,
  options?: InlineSnapshotOptions&amp;lt;T&amp;gt;,
): void;
/**
 * Make an assertion that `actual` matches `expectedSnapshot`. If they do not match,
 * then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Usage
 * ```ts no-assert
 * import { assertInlineSnapshot } from &amp;quot;@std/testing/unstable-snapshot&amp;quot;;
 *
 * Deno.test(&amp;quot;snapshot&amp;quot;, () =&amp;gt; {
 *   assertInlineSnapshot&amp;lt;number&amp;gt;(2, `2`);
 * });
 * ```
 * @typeParam T The type of the snapshot
 * @param actual The actual value to compare
 * @param expectedSnapshot The expected snapshot, or \`CREATE\` to create
 * @param message The optional assertion message
 */
export function assertInlineSnapshot&amp;lt;T&amp;gt;(
  actual: T,
  expectedSnapshot: string,
  message?: string,
): void;
export function assertInlineSnapshot(
  actual: unknown,
  expectedSnapshot: string,
  msgOrOpts?: string | InlineSnapshotOptions&amp;lt;unknown&amp;gt;,
): void
⋮----
// TODO(WWRS): dedent expectedSnapshot to allow snapshots to look nicer
⋮----
// Capture the stack that comes after this function.
⋮----
// Forcibly access the stack, and note it down
⋮----
/**
 * Create {@linkcode assertInlineSnapshot} function with the given options.
 *
 * The specified option becomes the default for returned {@linkcode assertInlineSnapshot}
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Usage
 * ```ts no-assert
 * import { createAssertInlineSnapshot } from &amp;quot;@std/testing/unstable-snapshot&amp;quot;;
 *
 * const assertInlineSnapshot = createAssertInlineSnapshot({
 *   serializer: JSON.stringify,
 * });
 *
 * Deno.test(&amp;quot;a snapshot test case&amp;quot;, () =&amp;gt; {
 *   assertInlineSnapshot(
 *     { foo: &amp;quot;Hello&amp;quot;, bar: undefined },
 *     `{&amp;quot;foo&amp;quot;:&amp;quot;Hello&amp;quot;}`
 *   );
 * })
 * ```
 *
 * @typeParam T The type of the snapshot
 * @param options The options
 * @param baseAssertSnapshot {@linkcode assertInlineSnapshot} function implementation. Default to the original {@linkcode assertInlineSnapshot}
 * @returns {@linkcode assertInlineSnapshot} function with the given default options.
 */
export function createAssertInlineSnapshot&amp;lt;T&amp;gt;(
  options: InlineSnapshotOptions&amp;lt;T&amp;gt;,
  baseAssertSnapshot: typeof assertInlineSnapshot = assertInlineSnapshot,
): typeof assertInlineSnapshot&lt;/file&gt;&lt;file path=&quot;testing/unstable_stub_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { assertEquals, assertThrows } from &amp;quot;@std/assert&amp;quot;;
import {
  assertSpyCall,
  assertSpyCallArg,
  assertSpyCalls,
  MockError,
  returnsNext,
} from &amp;quot;./mock.ts&amp;quot;;
import { Point, type PointWithExtra } from &amp;quot;./_test_utils.ts&amp;quot;;
import { type Stub, stub } from &amp;quot;./unstable_stub.ts&amp;quot;;
⋮----
// This doesn&amp;apos;t test any runtime code, only if the TypeScript types are correct.
⋮----
// @ts-expect-error Stubbing with incorrect argument types should cause a type error
⋮----
// @ts-expect-error Stubbing with an incorrect return type should cause a type error
⋮----
// Stubbing without argument types infers them from the real function
⋮----
// `toExponential()` only exists on `number`, so this will error if _x is not a number
⋮----
// `toLowerCase()` only exists on `string`, so this will error if _y is not a string
⋮----
// Stubbing with returnsNext() should not give any type errors
⋮----
// Stubbing without argument types should not cause any type errors:
⋮----
// Check if the returned type is correct:
⋮----
// @ts-expect-error Test if passing incorrect argument types causes an error
⋮----
// @ts-expect-error Test if passing incorrect return type causes an error
⋮----
// Calling assertSpyCall with the correct types should not cause any type errors
⋮----
fn()
⋮----
// deno-lint-ignore no-explicit-any
⋮----
const obj =&lt;/file&gt;&lt;file path=&quot;testing/unstable_stub.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
import { isSpy, registerMock, unregisterMock } from &amp;quot;./_mock_utils.ts&amp;quot;;
import {
  type GetParametersFromProp,
  type GetReturnFromProp,
  type MethodSpy,
  MockError,
  type Spy,
  spy,
  type SpyCall,
} from &amp;quot;./mock.ts&amp;quot;;
/** An instance method replacement that records all calls made to it. */
export interface Stub&amp;lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&amp;gt; extends MethodSpy&amp;lt;Self, Args, Return&amp;gt; {
  /** The function that is used instead of the original. */
  fake: (this: Self, ...args: Args) =&amp;gt; Return;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** The function that is used instead of the original. */
⋮----
/**
 * Replaces an instance method with a Stub with empty implementation.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCalls } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { stub } from &amp;quot;@std/testing/unstable-stub&amp;quot;;
 *
 * const obj = {
 *   method() {
 *     // some inconventient feature for testing
 *   },
 * };
 *
 * const methodStub = stub(obj, &amp;quot;method&amp;quot;);
 *
 * for (const _ of Array(5)) {
 *   obj.method();
 * }
 *
 * assertSpyCalls(methodStub, 5);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @returns The stub function which replaced the original.
 */
export function stub&amp;lt;
  Self,
  Prop extends keyof Self,
&amp;gt;(
  self: Self,
  property: Prop,
): Stub&amp;lt;Self, GetParametersFromProp&amp;lt;Self, Prop&amp;gt;, GetReturnFromProp&amp;lt;Self, Prop&amp;gt;&amp;gt;;
/**
 * Replaces an instance method with a Stub with the given implementation.
 *
 * @example Usage
 * ```ts
 * import { stub } from &amp;quot;@std/testing/unstable-stub&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const obj = {
 *   method(): number {
 *     return Math.random();
 *   },
 * };
 *
 * const methodStub = stub(obj, &amp;quot;method&amp;quot;, () =&amp;gt; 0.5);
 *
 * assertEquals(obj.method(), 0.5);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @param func The fake implementation of the function.
 * @returns The stub function which replaced the original.
 */
export function stub&amp;lt;
  Self,
  Prop extends keyof Self,
&amp;gt;(
  self: Self,
  property: Prop,
  func: (
    this: Self,
    ...args: GetParametersFromProp&amp;lt;Self, Prop&amp;gt;
  ) =&amp;gt; GetReturnFromProp&amp;lt;Self, Prop&amp;gt;,
): Stub&amp;lt;Self, GetParametersFromProp&amp;lt;Self, Prop&amp;gt;, GetReturnFromProp&amp;lt;Self, Prop&amp;gt;&amp;gt;;
/**
 * Replaces an instance property setter or getter with a Stub with the given implementation.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCalls } from &amp;quot;@std/testing/mock&amp;quot;;
 * import { stub } from &amp;quot;@std/testing/unstable-stub&amp;quot;;
 * import { assertEquals } from &amp;quot;@std/assert&amp;quot;;
 *
 * const obj = {
 *  prop: &amp;quot;foo&amp;quot;,
 * };
 *
 * const getterStub = stub(obj, &amp;quot;prop&amp;quot;, {
 *  get: function () {
 *    return &amp;quot;bar&amp;quot;;
 *  },
 * });
 *
 * assertEquals(obj.prop, &amp;quot;bar&amp;quot;);
 * assertSpyCalls(getterStub.get, 1);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @param descriptor The javascript property descriptor with fake implementation of the getter and setter.
 * @returns The stub with get and set properties which are spys of the setter and getter.
 */
export function stub&amp;lt;Self, Prop extends keyof Self&amp;gt;(
export function stub&amp;lt;Self, Args extends unknown[], Return&amp;gt;(
  self: Self,
  property: keyof Self,
  descriptorOrFunction?:
    | ((this: Self, ...args: Args) =&amp;gt; Return)
    | Omit&amp;lt;PropertyDescriptor, &amp;quot;configurable&amp;quot;&amp;gt;,
): Stub&amp;lt;Self, Args, Return&amp;gt;&lt;/file&gt;&lt;file path=&quot;testing/unstable_types_test.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
// deno-lint-ignore-file
import { assertType } from &amp;quot;./types.ts&amp;quot;;
import type { IsMutuallyAssignable } from &amp;quot;./unstable_types.ts&amp;quot;;
// IsMutuallyAssignable
⋮----
// matching
⋮----
// not matching&lt;/file&gt;&lt;file path=&quot;testing/unstable_types.ts&quot;&gt;// Copyright 2018-2025 the Deno authors. MIT license.
/**
 * Checks if the actual type `A` is assignable to the expected type `E`, and
 * vice versa.
 *
 * This is often less strict than `IsExact` because the two type parameters are
 * allowed to have a different structure as long as they are assignable to each
 * other. This is often more strict than `Has` because none of the two type
 * parameters may be a union that contains the other, as this would fail the
 * check for mutual assignability.
 *
 * @example Usage
 * ```ts
 * import { assertType } from &amp;quot;@std/testing/types&amp;quot;;
 * import type { IsMutuallyAssignable } from &amp;quot;@std/testing/unstable-types&amp;quot;;
 *
 * // false because E is not assignable to A
 * assertType&amp;lt;IsMutuallyAssignable&amp;lt;string &amp;amp; RegExpMatchArray, string&amp;gt;&amp;gt;(false);
 * // false because A is not assignable to E
 * assertType&amp;lt;IsMutuallyAssignable&amp;lt;string | RegExpMatchArray, string&amp;gt;&amp;gt;(false);
 * // true because both types are assignable to each other
 * assertType&amp;lt;IsMutuallyAssignable&amp;lt;string | (string &amp;amp; RegExpMatchArray), string&amp;gt;&amp;gt;(true);
 * ```
 */
export type IsMutuallyAssignable&amp;lt;A, E&amp;gt; = [E] extends [A]
  ? [A] extends [E] ? true : false
  : false;&lt;/file&gt;&lt;/files&gt;&lt;/repomix&gt;</file><file path=".hypermix/anthropics/sdk-examples.xml">&lt;repomix&gt;This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).&lt;file_summary&gt;This section contains a summary of this file.&lt;purpose&gt;This file contains a packed representation of the entire repository&amp;apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.&lt;/purpose&gt;&lt;file_format&gt;The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file&lt;/file_format&gt;&lt;usage_guidelines&gt;- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.&lt;/usage_guidelines&gt;&lt;notes&gt;- Some files may have been excluded based on .gitignore rules and Repomix&amp;apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: examples/**/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)&lt;/notes&gt;&lt;additional_info&gt;&lt;/additional_info&gt;&lt;/file_summary&gt;&lt;directory_structure&gt;examples/
  .keep
  batch-results.ts
  cancellation.ts
  count-tokens.ts
  demo.ts
  mcp.ts
  raw-streaming.ts
  streaming.ts
  thinking-stream.ts
  thinking.ts
  tools-streaming.ts
  tools.ts
  web-search-stream.ts
  web-search.ts&lt;/directory_structure&gt;&lt;files&gt;This section contains the contents of the repository&amp;apos;s files.&lt;file path=&quot;examples/.keep&quot;&gt;File generated from our OpenAPI spec by Stainless.
This directory can be used to store example files demonstrating usage of this SDK.
It is ignored by Stainless code generation and its content (other than this keep file) won&amp;apos;t be touched.&lt;/file&gt;&lt;file path=&quot;examples/batch-results.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk/index&amp;apos;;
⋮----
async function main()&lt;/file&gt;&lt;file path=&quot;examples/cancellation.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
⋮----
/**
 * This script demonstrates two ways of cancelling a stream,
 * by racing to see whether some Rust code prints &amp;quot;unwrap&amp;quot;
 * before 1.5 seconds or not.
 *
 * The most common is simply to `break` from the loop,
 * but you can also call `stream.controller.abort()` from outside the loop
 * if you need to.
 */
async function main()
⋮----
// If you need to, you can cancel a stream from outside the iterator
// by calling &amp;quot;stream.controller.abort()&amp;quot;
⋮----
// Most typically, you can cancel the stream by using &amp;quot;break&amp;quot;&lt;/file&gt;&lt;file path=&quot;examples/count-tokens.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic(); // gets API Key from environment variable ANTHROPIC_API_KEY
async function main()&lt;/file&gt;&lt;file path=&quot;examples/demo.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic(); // gets API Key from environment variable ANTHROPIC_API_KEY
async function main()&lt;/file&gt;&lt;file path=&quot;examples/mcp.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const anthropic = new Anthropic(); // gets API Key from environment variable ANTHROPIC_API_KEY
const main = async () =&amp;gt;
⋮----
// Optional, defaults to allowing all tools
enabled: true, // Optional
allowed_tools: [&amp;apos;echo&amp;apos;, &amp;apos;add&amp;apos;], // Optional&lt;/file&gt;&lt;file path=&quot;examples/raw-streaming.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic(); // gets API Key from environment variable ANTHROPIC_API_KEY
async function main()&lt;/file&gt;&lt;file path=&quot;examples/streaming.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic(); // gets API Key from environment variable ANTHROPIC_API_KEY
async function main()
⋮----
// Once a content block is fully streamed, this event will fire
⋮----
// Once a message is fully streamed, this event will fire&lt;/file&gt;&lt;file path=&quot;examples/thinking-stream.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic(); // gets API Key from environment variable ANTHROPIC_API_KEY
async function main()&lt;/file&gt;&lt;file path=&quot;examples/thinking.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
⋮----
async function main()&lt;/file&gt;&lt;file path=&quot;examples/tools-streaming.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
import { inspect } from &amp;apos;util&amp;apos;;
// gets API Key from environment variable ANTHROPIC_API_KEY
⋮----
async function main()
⋮----
// When a JSON content block delta is encountered this
// event will be fired with the delta and the currently accumulated object&lt;/file&gt;&lt;file path=&quot;examples/tools.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
import assert from &amp;apos;node:assert&amp;apos;;
const client = new Anthropic(); // gets API Key from environment variable ANTHROPIC_API_KEY
async function main()&lt;/file&gt;&lt;file path=&quot;examples/web-search-stream.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
⋮----
async function main()
⋮----
// Create a stream with web search enabled
⋮----
// Print text as it arrives
⋮----
// Track when web search is being used
⋮----
// Wait for the stream to complete
⋮----
// Display message content types for debugging
⋮----
// Show full message for debugging&lt;/file&gt;&lt;file path=&quot;examples/web-search.ts&quot;&gt;import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
⋮----
async function main()
⋮----
// Create a message with web search enabled
⋮----
// Print the full response
⋮----
// Extract and print the content
⋮----
// Print usage information&lt;/file&gt;&lt;/files&gt;&lt;/repomix&gt;</file><file path=".hypermix/anthropics/sdk.xml">&lt;repomix&gt;This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).&lt;file_summary&gt;This section contains a summary of this file.&lt;purpose&gt;This file contains a packed representation of the entire repository&amp;apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.&lt;/purpose&gt;&lt;file_format&gt;The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file&lt;/file_format&gt;&lt;usage_guidelines&gt;- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.&lt;/usage_guidelines&gt;&lt;notes&gt;- Some files may have been excluded based on .gitignore rules and Repomix&amp;apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/**, api.md, README.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)&lt;/notes&gt;&lt;additional_info&gt;&lt;/additional_info&gt;&lt;/file_summary&gt;&lt;directory_structure&gt;src/
  _vendor/
    partial-json-parser/
      parser.ts
      README.md
  core/
    api-promise.ts
    error.ts
    pagination.ts
    README.md
    resource.ts
    streaming.ts
    uploads.ts
  internal/
    decoders/
      jsonl.ts
      line.ts
    utils/
      base64.ts
      bytes.ts
      env.ts
      log.ts
      path.ts
      sleep.ts
      uuid.ts
      values.ts
    builtin-types.ts
    constants.ts
    detect-platform.ts
    errors.ts
    headers.ts
    parse.ts
    README.md
    request-options.ts
    shim-types.d.ts
    shims.ts
    stream-utils.ts
    to-file.ts
    types.ts
    uploads.ts
    utils.ts
  lib/
    .keep
    BetaMessageStream.ts
    MessageStream.ts
  resources/
    beta/
      messages/
        batches.ts
        index.ts
        messages.ts
      beta.ts
      files.ts
      index.ts
      messages.ts
      models.ts
    messages/
      batches.ts
      index.ts
      messages.ts
    beta.ts
    completions.ts
    index.ts
    messages.ts
    models.ts
    shared.ts
    top-level.ts
  api-promise.ts
  client.ts
  error.ts
  index.ts
  pagination.ts
  resource.ts
  resources.ts
  streaming.ts
  uploads.ts
  version.ts
api.md
README.md&lt;/directory_structure&gt;&lt;files&gt;This section contains the contents of the repository&amp;apos;s files.&lt;file path=&quot;src/_vendor/partial-json-parser/parser.ts&quot;&gt;type Token = {
  type: string;
  value: string;
};
const tokenize = (input: string): Token[] =&amp;gt;
⋮----
// unknown token, e.g. `nul` which isn&amp;apos;t quite `null`
⋮----
strip = (tokens: Token[]): Token[] =&amp;gt;
⋮----
unstrip = (tokens: Token[]): Token[] =&amp;gt;
⋮----
generate = (tokens: Token[]): string =&amp;gt;
⋮----
partialParse = (input: string): unknown&lt;/file&gt;&lt;file path=&quot;src/_vendor/partial-json-parser/README.md&quot;&gt;# Partial JSON Parser
Vendored from https://www.npmjs.com/package/partial-json-parser and updated to use TypeScript.&lt;/file&gt;&lt;file path=&quot;src/core/api-promise.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { type BaseAnthropic } from &amp;apos;../client&amp;apos;;
import { type PromiseOrValue } from &amp;apos;../internal/types&amp;apos;;
import {
  type APIResponseProps,
  type WithRequestID,
  defaultParseResponse,
  addRequestID,
} from &amp;apos;../internal/parse&amp;apos;;
/**
 * A subclass of `Promise` providing additional helper methods
 * for interacting with the SDK.
 */
export class APIPromise&amp;lt;T&amp;gt; extends Promise&amp;lt;WithRequestID&amp;lt;T&amp;gt;&amp;gt;
⋮----
constructor(
    client: BaseAnthropic,
    private responsePromise: Promise&amp;lt;APIResponseProps&amp;gt;,
    private parseResponse: (
      client: BaseAnthropic,
      props: APIResponseProps,
    ) =&amp;gt; PromiseOrValue&amp;lt;WithRequestID&amp;lt;T&amp;gt;&amp;gt; = defaultParseResponse,
)
⋮----
// this is maybe a bit weird but this has to be a no-op to not implicitly
// parse the response body; instead .then, .catch, .finally are overridden
// to parse the response
⋮----
_thenUnwrap&amp;lt;U&amp;gt;(transform: (data: T, props: APIResponseProps) =&amp;gt; U): APIPromise&amp;lt;U&amp;gt;
/**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `&amp;quot;moduleResolution&amp;quot;: &amp;quot;NodeNext&amp;quot;` or add `&amp;quot;lib&amp;quot;: [&amp;quot;DOM&amp;quot;]`
   * to your `tsconfig.json`.
   */
asResponse(): Promise&amp;lt;Response&amp;gt;
/**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `&amp;quot;moduleResolution&amp;quot;: &amp;quot;NodeNext&amp;quot;` or add `&amp;quot;lib&amp;quot;: [&amp;quot;DOM&amp;quot;]`
   * to your `tsconfig.json`.
   */
async withResponse(): Promise&amp;lt;
private parse(): Promise&amp;lt;WithRequestID&amp;lt;T&amp;gt;&amp;gt;
override then&amp;lt;TResult1 = WithRequestID&amp;lt;T&amp;gt;, TResult2 = never&amp;gt;(
    onfulfilled?: ((value: WithRequestID&amp;lt;T&amp;gt;) =&amp;gt; TResult1 | PromiseLike&amp;lt;TResult1&amp;gt;) | undefined | null,
    onrejected?: ((reason: any) =&amp;gt; TResult2 | PromiseLike&amp;lt;TResult2&amp;gt;) | undefined | null,
): Promise&amp;lt;TResult1 | TResult2&amp;gt;
override catch&amp;lt;TResult = never&amp;gt;(
    onrejected?: ((reason: any) =&amp;gt; TResult | PromiseLike&amp;lt;TResult&amp;gt;) | undefined | null,
): Promise&amp;lt;WithRequestID&amp;lt;T&amp;gt; | TResult&amp;gt;
override finally(onfinally?: (() =&amp;gt; void) | undefined | null): Promise&amp;lt;WithRequestID&amp;lt;T&amp;gt;&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/core/error.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { castToError } from &amp;apos;../internal/errors&amp;apos;;
export class AnthropicError extends Error
export class APIError&amp;lt;
TStatus extends number | undefined = number | undefined,
⋮----
/** HTTP status for the response that caused the error */
⋮----
/** HTTP headers for the response that caused the error */
⋮----
/** JSON body of the response that caused the error */
⋮----
constructor(status: TStatus, error: TError, message: string | undefined, headers: THeaders)
private static makeMessage(status: number | undefined, error: any, message: string | undefined)
static generate(
    status: number | undefined,
    errorResponse: Object | undefined,
    message: string | undefined,
    headers: Headers | undefined,
): APIError
⋮----
export class APIUserAbortError extends APIError&amp;lt;undefined, undefined, undefined&amp;gt;
⋮----
constructor(
⋮----
export class APIConnectionError extends APIError&amp;lt;undefined, undefined, undefined&amp;gt;
⋮----
// in some environments the &amp;apos;cause&amp;apos; property is already declared
// @ts-ignore
⋮----
export class APIConnectionTimeoutError extends APIConnectionError
export class BadRequestError extends APIError&amp;lt;400, Headers&amp;gt;
export class AuthenticationError extends APIError&amp;lt;401, Headers&amp;gt;
export class PermissionDeniedError extends APIError&amp;lt;403, Headers&amp;gt;
export class NotFoundError extends APIError&amp;lt;404, Headers&amp;gt;
export class ConflictError extends APIError&amp;lt;409, Headers&amp;gt;
export class UnprocessableEntityError extends APIError&amp;lt;422, Headers&amp;gt;
export class RateLimitError extends APIError&amp;lt;429, Headers&amp;gt;
export class InternalServerError extends APIError&amp;lt;number, Headers&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/core/pagination.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { AnthropicError } from &amp;apos;./error&amp;apos;;
import { FinalRequestOptions } from &amp;apos;../internal/request-options&amp;apos;;
import { defaultParseResponse, WithRequestID } from &amp;apos;../internal/parse&amp;apos;;
import { type BaseAnthropic } from &amp;apos;../client&amp;apos;;
import { APIPromise } from &amp;apos;./api-promise&amp;apos;;
import { type APIResponseProps } from &amp;apos;../internal/parse&amp;apos;;
import { maybeObj } from &amp;apos;../internal/utils/values&amp;apos;;
export type PageRequestOptions = Pick&amp;lt;FinalRequestOptions, &amp;apos;query&amp;apos; | &amp;apos;headers&amp;apos; | &amp;apos;body&amp;apos; | &amp;apos;path&amp;apos; | &amp;apos;method&amp;apos;&amp;gt;;
export abstract class AbstractPage&amp;lt;Item&amp;gt; implements AsyncIterable&amp;lt;Item&amp;gt;
⋮----
constructor(client: BaseAnthropic, response: Response, body: unknown, options: FinalRequestOptions)
abstract nextPageRequestOptions(): PageRequestOptions | null;
abstract getPaginatedItems(): Item[];
hasNextPage(): boolean
async getNextPage(): Promise&amp;lt;this&amp;gt;
async *iterPages(): AsyncGenerator&amp;lt;this&amp;gt;
⋮----
/**
 * This subclass of Promise will resolve to an instantiated Page once the request completes.
 *
 * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:
 *
 *    for await (const item of client.items.list()) {
 *      console.log(item)
 *    }
 */
export class PagePromise&amp;lt;
PageClass extends AbstractPage&amp;lt;Item&amp;gt;,
⋮----
constructor(
    client: BaseAnthropic,
    request: Promise&amp;lt;APIResponseProps&amp;gt;,
    Page: new (...args: ConstructorParameters&amp;lt;typeof AbstractPage&amp;gt;) =&amp;gt; PageClass,
)
/**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
⋮----
export interface PageResponse&amp;lt;Item&amp;gt; {
  data: Array&amp;lt;Item&amp;gt;;
  has_more: boolean;
  first_id: string | null;
  last_id: string | null;
}
export interface PageParams {
  /**
   * Number of items per page.
   */
  limit?: number;
  before_id?: string;
  after_id?: string;
}
⋮----
/**
   * Number of items per page.
   */
⋮----
export class Page&amp;lt;Item&amp;gt; extends AbstractPage&amp;lt;Item&amp;gt; implements PageResponse&amp;lt;Item&amp;gt;
⋮----
constructor(
    client: BaseAnthropic,
    response: Response,
    body: PageResponse&amp;lt;Item&amp;gt;,
    options: FinalRequestOptions,
)
getPaginatedItems(): Item[]
override hasNextPage(): boolean
nextPageRequestOptions(): PageRequestOptions | null
⋮----
// in reverse&lt;/file&gt;&lt;file path=&quot;src/core/README.md&quot;&gt;# `core`
This directory holds public modules implementing non-resource-specific SDK functionality.&lt;/file&gt;&lt;file path=&quot;src/core/resource.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { BaseAnthropic } from &amp;apos;../client&amp;apos;;
export class APIResource
⋮----
constructor(client: BaseAnthropic)&lt;/file&gt;&lt;file path=&quot;src/core/streaming.ts&quot;&gt;import { AnthropicError } from &amp;apos;./error&amp;apos;;
import { type ReadableStream } from &amp;apos;../internal/shim-types&amp;apos;;
import { makeReadableStream } from &amp;apos;../internal/shims&amp;apos;;
import { findDoubleNewlineIndex, LineDecoder } from &amp;apos;../internal/decoders/line&amp;apos;;
import { ReadableStreamToAsyncIterable } from &amp;apos;../internal/shims&amp;apos;;
import { isAbortError } from &amp;apos;../internal/errors&amp;apos;;
import { safeJSON } from &amp;apos;../internal/utils/values&amp;apos;;
import { encodeUTF8 } from &amp;apos;../internal/utils/bytes&amp;apos;;
import { APIError } from &amp;apos;./error&amp;apos;;
type Bytes = string | ArrayBuffer | Uint8Array | null | undefined;
export type ServerSentEvent = {
  event: string | null;
  data: string;
  raw: string[];
};
export class Stream&amp;lt;Item&amp;gt; implements AsyncIterable&amp;lt;Item&amp;gt;
⋮----
constructor(
    private iterator: () =&amp;gt; AsyncIterator&amp;lt;Item&amp;gt;,
    controller: AbortController,
)
static fromSSEResponse&amp;lt;Item&amp;gt;(response: Response, controller: AbortController): Stream&amp;lt;Item&amp;gt;
⋮----
// If the user calls `stream.controller.abort()`, we should exit without throwing.
⋮----
// If the user `break`s, abort the ongoing request.
⋮----
/**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
static fromReadableStream&amp;lt;Item&amp;gt;(readableStream: ReadableStream, controller: AbortController): Stream&amp;lt;Item&amp;gt;
⋮----
// If the user calls `stream.controller.abort()`, we should exit without throwing.
⋮----
// If the user `break`s, abort the ongoing request.
⋮----
/**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
tee(): [Stream&amp;lt;Item&amp;gt;, Stream&amp;lt;Item&amp;gt;]
⋮----
const teeIterator = (queue: Array&amp;lt;Promise&amp;lt;IteratorResult&amp;lt;Item&amp;gt;&amp;gt;&amp;gt;): AsyncIterator&amp;lt;Item&amp;gt; =&amp;gt;
⋮----
/**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
toReadableStream(): ReadableStream
⋮----
async start()
async pull(ctrl: any)
async cancel()
⋮----
/**
 * Given an async iterable iterator, iterates over it and yields full
 * SSE chunks, i.e. yields when a double new-line is encountered.
 */
⋮----
class SSEDecoder
⋮----
constructor()
decode(line: string)
⋮----
// empty line and we didn&amp;apos;t previously encounter any messages
⋮----
function partition(str: string, delimiter: string): [string, string, string]&lt;/file&gt;&lt;file path=&quot;src/core/uploads.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;src/internal/decoders/jsonl.ts&quot;&gt;import { AnthropicError } from &amp;apos;../../core/error&amp;apos;;
import { ReadableStreamToAsyncIterable } from &amp;apos;../shims&amp;apos;;
import { LineDecoder, type Bytes } from &amp;apos;./line&amp;apos;;
export class JSONLDecoder&amp;lt;T&amp;gt;
⋮----
constructor(
    private iterator: AsyncIterableIterator&amp;lt;Bytes&amp;gt;,
    controller: AbortController,
)
private async *decoder(): AsyncIterator&amp;lt;T, any, undefined&amp;gt;
⋮----
static fromResponse&amp;lt;T&amp;gt;(response: Response, controller: AbortController): JSONLDecoder&amp;lt;T&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/internal/decoders/line.ts&quot;&gt;import { concatBytes, decodeUTF8, encodeUTF8 } from &amp;apos;../utils/bytes&amp;apos;;
export type Bytes = string | ArrayBuffer | Uint8Array | null | undefined;
/**
 * A re-implementation of httpx&amp;apos;s `LineDecoder` in Python that handles incrementally
 * reading lines from text.
 *
 * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258
 */
export class LineDecoder
⋮----
// prettier-ignore
⋮----
constructor()
decode(chunk: Bytes): string[]
⋮----
// skip until we either get a corresponding `\n`, a new `\r` or nothing
⋮----
// we got double \r or \rtext\n
⋮----
flush(): string[]
⋮----
/**
 * This function searches the buffer for the end patterns, (\r or \n)
 * and returns an object with the index preceding the matched newline and the
 * index after the newline char. `null` is returned if no new line is found.
 *
 * ```ts
 * findNewLineIndex(&amp;apos;abc\ndef&amp;apos;) -&amp;gt; { preceding: 2, index: 3 }
 * ```
 */
function findNewlineIndex(
  buffer: Uint8Array,
  startIndex: number | null,
):
⋮----
const newline = 0x0a; // \n
const carriage = 0x0d; // \r
⋮----
export function findDoubleNewlineIndex(buffer: Uint8Array): number
⋮----
// This function searches the buffer for the end patterns (\r\r, \n\n, \r\n\r\n)
// and returns the index right after the first occurrence of any pattern,
// or -1 if none of the patterns are found.
const newline = 0x0a; // \n
const carriage = 0x0d; // \r
⋮----
// \n\n
⋮----
// \r\r
⋮----
// \r\n\r\n&lt;/file&gt;&lt;file path=&quot;src/internal/utils/base64.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { AnthropicError } from &amp;apos;../../core/error&amp;apos;;
import { encodeUTF8 } from &amp;apos;./bytes&amp;apos;;
export const toBase64 = (data: string | Uint8Array | null | undefined): string =&amp;gt;
export const fromBase64 = (str: string): Uint8Array =&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/internal/utils/bytes.ts&quot;&gt;export function concatBytes(buffers: Uint8Array[]): Uint8Array
⋮----
export function encodeUTF8(str: string)
⋮----
export function decodeUTF8(bytes: Uint8Array)&lt;/file&gt;&lt;file path=&quot;src/internal/utils/env.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
/**
 * Read an environment variable.
 *
 * Trims beginning and trailing whitespace.
 *
 * Will return undefined if the environment variable doesn&amp;apos;t exist or cannot be accessed.
 */
export const readEnv = (env: string): string | undefined =&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/internal/utils/log.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { hasOwn } from &amp;apos;./values&amp;apos;;
import { type BaseAnthropic } from &amp;apos;../../client&amp;apos;;
import { RequestOptions } from &amp;apos;../request-options&amp;apos;;
type LogFn = (message: string, ...rest: unknown[]) =&amp;gt; void;
export type Logger = {
  error: LogFn;
  warn: LogFn;
  info: LogFn;
  debug: LogFn;
};
export type LogLevel = &amp;apos;off&amp;apos; | &amp;apos;error&amp;apos; | &amp;apos;warn&amp;apos; | &amp;apos;info&amp;apos; | &amp;apos;debug&amp;apos;;
⋮----
export const parseLogLevel = (
  maybeLevel: string | undefined,
  sourceName: string,
  client: BaseAnthropic,
): LogLevel | undefined =&amp;gt;
function noop()
function makeLogFn(fnLevel: keyof Logger, logger: Logger | undefined, logLevel: LogLevel)
⋮----
// Don&amp;apos;t wrap logger functions, we want the stacktrace intact!
⋮----
export function loggerFor(client: BaseAnthropic): Logger
export const formatRequestDetails = (details: {
  options?: RequestOptions | undefined;
  headers?: Headers | Record&amp;lt;string, string&amp;gt; | undefined;
  retryOfRequestLogID?: string | undefined;
  retryOf?: string | undefined;
  url?: string | undefined;
  status?: number | undefined;
  method?: string | undefined;
  durationMs?: number | undefined;
  message?: unknown;
  body?: unknown;
}) =&amp;gt;
⋮----
delete details.options[&amp;apos;headers&amp;apos;]; // redundant + leaks internals&lt;/file&gt;&lt;file path=&quot;src/internal/utils/path.ts&quot;&gt;import { AnthropicError } from &amp;apos;../../core/error&amp;apos;;
/**
 * Percent-encode everything that isn&amp;apos;t safe to have in a path without encoding safe chars.
 *
 * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:
 * &amp;gt; unreserved  = ALPHA / DIGIT / &amp;quot;-&amp;quot; / &amp;quot;.&amp;quot; / &amp;quot;_&amp;quot; / &amp;quot;~&amp;quot;
 * &amp;gt; sub-delims  = &amp;quot;!&amp;quot; / &amp;quot;$&amp;quot; / &amp;quot;&amp;amp;&amp;quot; / &amp;quot;&amp;apos;&amp;quot; / &amp;quot;(&amp;quot; / &amp;quot;)&amp;quot; / &amp;quot;*&amp;quot; / &amp;quot;+&amp;quot; / &amp;quot;,&amp;quot; / &amp;quot;;&amp;quot; / &amp;quot;=&amp;quot;
 * &amp;gt; pchar       = unreserved / pct-encoded / sub-delims / &amp;quot;:&amp;quot; / &amp;quot;@&amp;quot;
 */
export function encodeURIPath(str: string)
export const createPathTagFunction = (pathEncoder = encodeURIPath)
⋮----
// If there are no params, no processing is needed.
⋮----
// Find all invalid segments
⋮----
/**
 * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.
 */&lt;/file&gt;&lt;file path=&quot;src/internal/utils/sleep.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
export const sleep = (ms: number)&lt;/file&gt;&lt;file path=&quot;src/internal/utils/uuid.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
/**
 * https://stackoverflow.com/a/2117523
 */&lt;/file&gt;&lt;file path=&quot;src/internal/utils/values.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { AnthropicError } from &amp;apos;../../core/error&amp;apos;;
// https://url.spec.whatwg.org/#url-scheme-string
⋮----
export const isAbsoluteURL = (url: string): boolean =&amp;gt;
/** Returns an object if the given value isn&amp;apos;t an object, otherwise returns as-is */
export function maybeObj(x: unknown): object
// https://stackoverflow.com/a/34491287
export function isEmptyObj(obj: Object | null | undefined): boolean
// https://eslint.org/docs/latest/rules/no-prototype-builtins
export function hasOwn&amp;lt;T extends object = object&amp;gt;(obj: T, key: PropertyKey): key is keyof T
export function isObj(obj: unknown): obj is Record&amp;lt;string, unknown&amp;gt;
export const ensurePresent = &amp;lt;T&amp;gt;(value: T | null | undefined): T =&amp;gt;
export const validatePositiveInteger = (name: string, n: unknown): number =&amp;gt;
export const coerceInteger = (value: unknown): number =&amp;gt;
export const coerceFloat = (value: unknown): number =&amp;gt;
export const coerceBoolean = (value: unknown): boolean =&amp;gt;
export const maybeCoerceInteger = (value: unknown): number | undefined =&amp;gt;
export const maybeCoerceFloat = (value: unknown): number | undefined =&amp;gt;
export const maybeCoerceBoolean = (value: unknown): boolean | undefined =&amp;gt;
export const safeJSON = (text: string) =&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/internal/builtin-types.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
export type Fetch = (input: string | URL | Request, init?: RequestInit) =&amp;gt; Promise&amp;lt;Response&amp;gt;;
/**
 * An alias to the builtin `RequestInit` type so we can
 * easily alias it in import statements if there are name clashes.
 *
 * https://developer.mozilla.org/docs/Web/API/RequestInit
 */
type _RequestInit = RequestInit;
/**
 * An alias to the builtin `Response` type so we can
 * easily alias it in import statements if there are name clashes.
 *
 * https://developer.mozilla.org/docs/Web/API/Response
 */
type _Response = Response;
/**
 * The type for the first argument to `fetch`.
 *
 * https://developer.mozilla.org/docs/Web/API/Window/fetch#resource
 */
type _RequestInfo = Request | URL | string;
/**
 * The type for constructing `RequestInit` Headers.
 *
 * https://developer.mozilla.org/docs/Web/API/RequestInit#setting_headers
 */
type _HeadersInit = RequestInit[&amp;apos;headers&amp;apos;];
/**
 * The type for constructing `RequestInit` body.
 *
 * https://developer.mozilla.org/docs/Web/API/RequestInit#body
 */
type _BodyInit = RequestInit[&amp;apos;body&amp;apos;];
/**
 * An alias to the builtin `Array&amp;lt;T&amp;gt;` type so we can
 * easily alias it in import statements if there are name clashes.
 */
type _Array&amp;lt;T&amp;gt; = Array&amp;lt;T&amp;gt;;
/**
 * An alias to the builtin `Record&amp;lt;K, T&amp;gt;` type so we can
 * easily alias it in import statements if there are name clashes.
 */
type _Record&amp;lt;K extends keyof any, T&amp;gt; = Record&amp;lt;K, T&amp;gt;;
⋮----
/**
 * A copy of the builtin `EndingType` type as it isn&amp;apos;t fully supported in certain
 * environments and attempting to reference the global version will error.
 *
 * https://github.com/microsoft/TypeScript/blob/49ad1a3917a0ea57f5ff248159256e12bb1cb705/src/lib/dom.generated.d.ts#L27941
 */
type EndingType = &amp;apos;native&amp;apos; | &amp;apos;transparent&amp;apos;;
/**
 * A copy of the builtin `BlobPropertyBag` type as it isn&amp;apos;t fully supported in certain
 * environments and attempting to reference the global version will error.
 *
 * https://github.com/microsoft/TypeScript/blob/49ad1a3917a0ea57f5ff248159256e12bb1cb705/src/lib/dom.generated.d.ts#L154
 * https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob#options
 */
export interface BlobPropertyBag {
  endings?: EndingType;
  type?: string;
}
/**
 * A copy of the builtin `FilePropertyBag` type as it isn&amp;apos;t fully supported in certain
 * environments and attempting to reference the global version will error.
 *
 * https://github.com/microsoft/TypeScript/blob/49ad1a3917a0ea57f5ff248159256e12bb1cb705/src/lib/dom.generated.d.ts#L503
 * https://developer.mozilla.org/en-US/docs/Web/API/File/File#options
 */
export interface FilePropertyBag extends BlobPropertyBag {
  lastModified?: number;
}&lt;/file&gt;&lt;file path=&quot;src/internal/constants.ts&quot;&gt;// File containing shared constants
/**
 * Model-specific timeout constraints for non-streaming requests
 */&lt;/file&gt;&lt;file path=&quot;src/internal/detect-platform.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { VERSION } from &amp;apos;../version&amp;apos;;
export const isRunningInBrowser = () =&amp;gt;
⋮----
// @ts-ignore
⋮----
// @ts-ignore
⋮----
// @ts-ignore
⋮----
type DetectedPlatform = &amp;apos;deno&amp;apos; | &amp;apos;node&amp;apos; | &amp;apos;edge&amp;apos; | &amp;apos;unknown&amp;apos;;
/**
 * Note this does not detect &amp;apos;browser&amp;apos;; for that, use getBrowserInfo().
 */
function getDetectedPlatform(): DetectedPlatform
⋮----
type Arch = &amp;apos;x32&amp;apos; | &amp;apos;x64&amp;apos; | &amp;apos;arm&amp;apos; | &amp;apos;arm64&amp;apos; | `other:${string}` | &amp;apos;unknown&amp;apos;;
type PlatformName =
  | &amp;apos;MacOS&amp;apos;
  | &amp;apos;Linux&amp;apos;
  | &amp;apos;Windows&amp;apos;
  | &amp;apos;FreeBSD&amp;apos;
  | &amp;apos;OpenBSD&amp;apos;
  | &amp;apos;iOS&amp;apos;
  | &amp;apos;Android&amp;apos;
  | `Other:${string}`
  | &amp;apos;Unknown&amp;apos;;
type Browser = &amp;apos;ie&amp;apos; | &amp;apos;edge&amp;apos; | &amp;apos;chrome&amp;apos; | &amp;apos;firefox&amp;apos; | &amp;apos;safari&amp;apos;;
type PlatformProperties = {
  &amp;apos;X-Stainless-Lang&amp;apos;: &amp;apos;js&amp;apos;;
  &amp;apos;X-Stainless-Package-Version&amp;apos;: string;
  &amp;apos;X-Stainless-OS&amp;apos;: PlatformName;
  &amp;apos;X-Stainless-Arch&amp;apos;: Arch;
  &amp;apos;X-Stainless-Runtime&amp;apos;: &amp;apos;node&amp;apos; | &amp;apos;deno&amp;apos; | &amp;apos;edge&amp;apos; | `browser:${Browser}` | &amp;apos;unknown&amp;apos;;
  &amp;apos;X-Stainless-Runtime-Version&amp;apos;: string;
};
const getPlatformProperties = (): PlatformProperties =&amp;gt;
⋮----
// Check if Node.js
⋮----
// TODO add support for Cloudflare workers, etc.
⋮----
type BrowserInfo = {
  browser: Browser;
  version: string;
};
⋮----
// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts
function getBrowserInfo(): BrowserInfo | null
⋮----
// NOTE: The order matters here!
⋮----
// Find the FIRST matching browser
⋮----
const normalizeArch = (arch: string): Arch =&amp;gt;
⋮----
// Node docs:
// - https://nodejs.org/api/process.html#processarch
// Deno docs:
// - https://doc.deno.land/deno/stable/~/Deno.build
⋮----
const normalizePlatform = (platform: string): PlatformName =&amp;gt;
⋮----
// Node platforms:
// - https://nodejs.org/api/process.html#processplatform
// Deno platforms:
// - https://doc.deno.land/deno/stable/~/Deno.build
// - https://github.com/denoland/deno/issues/14799
⋮----
// NOTE: this iOS check is untested and may not work
// Node does not work natively on IOS, there is a fork at
// https://github.com/nodejs-mobile/nodejs-mobile
// however it is unknown at the time of writing how to detect if it is running
⋮----
export const getPlatformHeaders = () =&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/internal/errors.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
export function isAbortError(err: unknown)
⋮----
// Spec-compliant fetch implementations
⋮----
// Expo fetch
⋮----
export const castToError = (err: any): Error =&amp;gt;
⋮----
// @ts-ignore - not all envs have native support for cause yet
⋮----
// @ts-ignore - not all envs have native support for cause yet&lt;/file&gt;&lt;file path=&quot;src/internal/headers.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
type HeaderValue = string | undefined | null;
export type HeadersLike =
  | Headers
  | readonly HeaderValue[][]
  | Record&amp;lt;string, HeaderValue | readonly HeaderValue[]&amp;gt;
  | undefined
  | null
  | NullableHeaders;
⋮----
/**
 * @internal
 * Users can pass explicit nulls to unset default headers. When we parse them
 * into a standard headers type we need to preserve that information.
 */
export type NullableHeaders = {
  /** Brand check, prevent users from creating a NullableHeaders. */
  [_: typeof brand_privateNullableHeaders]: true;
  /** Parsed headers. */
  values: Headers;
  /** Set of lowercase header names explicitly set to null. */
  nulls: Set&amp;lt;string&amp;gt;;
};
⋮----
/** Brand check, prevent users from creating a NullableHeaders. */
⋮----
/** Parsed headers. */
⋮----
/** Set of lowercase header names explicitly set to null. */
⋮----
// Objects keys always overwrite older headers, they never append.
// Yield a null to clear the header before adding the new values.
⋮----
export const buildHeaders = (newHeaders: HeadersLike[]): NullableHeaders =&amp;gt;
export const isEmptyHeaders = (headers: HeadersLike) =&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/internal/parse.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import type { FinalRequestOptions } from &amp;apos;./request-options&amp;apos;;
import { Stream } from &amp;apos;../core/streaming&amp;apos;;
import { type BaseAnthropic } from &amp;apos;../client&amp;apos;;
import { formatRequestDetails, loggerFor } from &amp;apos;./utils/log&amp;apos;;
import type { AbstractPage } from &amp;apos;../core/pagination&amp;apos;;
export type APIResponseProps = {
  response: Response;
  options: FinalRequestOptions;
  controller: AbortController;
  requestLogID: string;
  retryOfRequestLogID: string | undefined;
  startTime: number;
};
export async function defaultParseResponse&amp;lt;T&amp;gt;(
  client: BaseAnthropic,
  props: APIResponseProps,
): Promise&amp;lt;WithRequestID&amp;lt;T&amp;gt;&amp;gt;
⋮----
// Note: there is an invariant here that isn&amp;apos;t represented in the type system
// that if you set `stream: true` the response type must also be `Stream&amp;lt;T&amp;gt;`
⋮----
// fetch refuses to read the body when the status code is 204.
⋮----
export type WithRequestID&amp;lt;T&amp;gt; =
  T extends Array&amp;lt;any&amp;gt; | Response | AbstractPage&amp;lt;any&amp;gt; ? T
  : T extends Record&amp;lt;string, any&amp;gt; ? T &amp;amp; { _request_id?: string | null }
  : T;
export function addRequestID&amp;lt;T&amp;gt;(value: T, response: Response): WithRequestID&amp;lt;T&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/internal/README.md&quot;&gt;# `internal`
The modules in this directory are not importable outside this package and will change between releases.&lt;/file&gt;&lt;file path=&quot;src/internal/request-options.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { NullableHeaders } from &amp;apos;./headers&amp;apos;;
import type { BodyInit } from &amp;apos;./builtin-types&amp;apos;;
import { Stream } from &amp;apos;../core/streaming&amp;apos;;
import type { HTTPMethod, MergedRequestInit } from &amp;apos;./types&amp;apos;;
import { type HeadersLike } from &amp;apos;./headers&amp;apos;;
export type FinalRequestOptions = RequestOptions &amp;amp; { method: HTTPMethod; path: string };
export type RequestOptions = {
  method?: HTTPMethod;
  path?: string;
  query?: object | undefined | null;
  body?: unknown;
  headers?: HeadersLike;
  maxRetries?: number;
  stream?: boolean | undefined;
  timeout?: number;
  fetchOptions?: MergedRequestInit;
  signal?: AbortSignal | undefined | null;
  idempotencyKey?: string;
  __binaryResponse?: boolean | undefined;
  __streamClass?: typeof Stream;
};
export type EncodedContent = { bodyHeaders: HeadersLike; body: BodyInit };
export type RequestEncoder = (request: { headers: NullableHeaders; body: unknown }) =&amp;gt; EncodedContent;
export const FallbackEncoder: RequestEncoder = (&lt;/file&gt;&lt;file path=&quot;src/internal/shim-types.d.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
/**
 * Shims for types that we can&amp;apos;t always rely on being available globally.
 *
 * Note: these only exist at the type-level, there is no corresponding runtime
 * version for any of these symbols.
 */
/**
 * In order to properly access the global `NodeJS` type, if it&amp;apos;s available, we
 * need to make use of declaration shadowing. Without this, any checks for the
 * presence of `NodeJS.ReadableStream` will fail.
 */
⋮----
interface ReadableStream {}
⋮----
type HasProperties&amp;lt;T&amp;gt; = keyof T extends never ? false : true;
// @ts-ignore
type _ReadableStream&amp;lt;R = any&amp;gt; =
  // @ts-ignore
  HasProperties&amp;lt;NodeJS.ReadableStream&amp;gt; extends true ? NodeJS.ReadableStream&amp;lt;R&amp;gt; : ReadableStream&amp;lt;R&amp;gt;;
⋮----
// @ts-ignore
⋮----
// @ts-ignore&lt;/file&gt;&lt;file path=&quot;src/internal/shims.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
/**
 * This module provides internal shims and utility functions for environments where certain Node.js or global types may not be available.
 *
 * These are used to ensure we can provide a consistent behaviour between different JavaScript environments and good error
 * messages in cases where an environment isn&amp;apos;t fully supported.
 */
import { type Fetch } from &amp;apos;./builtin-types&amp;apos;;
import { type ReadableStream } from &amp;apos;./shim-types&amp;apos;;
export function getDefaultFetch(): Fetch
type ReadableStreamArgs = ConstructorParameters&amp;lt;typeof ReadableStream&amp;gt;;
export function makeReadableStream(...args: ReadableStreamArgs): ReadableStream
⋮----
// Note: All of the platforms / runtimes we officially support already define
// `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.
⋮----
export function ReadableStreamFrom&amp;lt;T&amp;gt;(iterable: Iterable&amp;lt;T&amp;gt; | AsyncIterable&amp;lt;T&amp;gt;): ReadableStream&amp;lt;T&amp;gt;
⋮----
start()
async pull(controller: any)
async cancel()
⋮----
/**
 * Most browsers don&amp;apos;t yet have async iterable support for ReadableStream,
 * and Node has a very different way of reading bytes from its &amp;quot;ReadableStream&amp;quot;.
 *
 * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490
 */
export function ReadableStreamToAsyncIterable&amp;lt;T&amp;gt;(stream: any): AsyncIterableIterator&amp;lt;T&amp;gt;
⋮----
async next()
⋮----
if (result?.done) reader.releaseLock(); // release lock when stream becomes closed
⋮----
reader.releaseLock(); // release lock when stream becomes errored
⋮----
async return()
⋮----
/**
 * Cancels a ReadableStream we don&amp;apos;t need to consume.
 * See https://undici.nodejs.org/#/?id=garbage-collection
 */
export async function CancelReadableStream(stream: any): Promise&amp;lt;void&amp;gt;&lt;/file&gt;&lt;file path=&quot;src/internal/stream-utils.ts&quot;&gt;/**
 * Most browsers don&amp;apos;t yet have async iterable support for ReadableStream,
 * and Node has a very different way of reading bytes from its &amp;quot;ReadableStream&amp;quot;.
 *
 * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490
 */
export function ReadableStreamToAsyncIterable&amp;lt;T&amp;gt;(stream: any): AsyncIterableIterator&amp;lt;T&amp;gt;
⋮----
async next()
⋮----
if (result?.done) reader.releaseLock(); // release lock when stream becomes closed
⋮----
reader.releaseLock(); // release lock when stream becomes errored
⋮----
async return()&lt;/file&gt;&lt;file path=&quot;src/internal/to-file.ts&quot;&gt;import { BlobPart, getName, makeFile, isAsyncIterable } from &amp;apos;./uploads&amp;apos;;
import type { FilePropertyBag } from &amp;apos;./builtin-types&amp;apos;;
import { checkFileSupport } from &amp;apos;./uploads&amp;apos;;
type BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | DataView;
/**
 * Intended to match DOM Blob, node-fetch Blob, node:buffer Blob, etc.
 * Don&amp;apos;t add arrayBuffer here, node-fetch doesn&amp;apos;t have it
 */
interface BlobLike {
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */
  readonly size: number;
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */
  readonly type: string;
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */
  text(): Promise&amp;lt;string&amp;gt;;
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */
  slice(start?: number, end?: number): BlobLike;
}
⋮----
/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */
⋮----
/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */
⋮----
/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */
text(): Promise&amp;lt;string&amp;gt;;
/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */
slice(start?: number, end?: number): BlobLike;
⋮----
/**
 * This check adds the arrayBuffer() method type because it is available and used at runtime
 */
const isBlobLike = (value: any): value is BlobLike &amp;amp;
/**
 * Intended to match DOM File, node:buffer File, undici File, etc.
 */
interface FileLike extends BlobLike {
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */
  readonly lastModified: number;
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */
  readonly name?: string | undefined;
}
⋮----
/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */
⋮----
/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */
⋮----
/**
 * This check adds the arrayBuffer() method type because it is available and used at runtime
 */
const isFileLike = (value: any): value is FileLike &amp;amp;
/**
 * Intended to match DOM Response, node-fetch Response, undici Response, etc.
 */
export interface ResponseLike {
  url: string;
  blob(): Promise&amp;lt;BlobLike&amp;gt;;
}
⋮----
blob(): Promise&amp;lt;BlobLike&amp;gt;;
⋮----
const isResponseLike = (value: any): value is ResponseLike
export type ToFileInput =
  | FileLike
  | ResponseLike
  | Exclude&amp;lt;BlobLikePart, string&amp;gt;
  | AsyncIterable&amp;lt;BlobLikePart&amp;gt;;
/**
 * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats
 * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s
 * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible
 * @param {Object=} options additional properties
 * @param {string=} options.type the MIME type of the content
 * @param {number=} options.lastModified the last modified timestamp
 * @returns a {@link File} with the given properties
 */
export async function toFile(
  value: ToFileInput | PromiseLike&amp;lt;ToFileInput&amp;gt;,
  name?: string | null | undefined,
  options?: FilePropertyBag | undefined,
): Promise&amp;lt;File&amp;gt;
⋮----
// If it&amp;apos;s a promise, resolve it.
⋮----
// If we&amp;apos;ve been given a `File` we don&amp;apos;t need to do anything if the name / options
// have not been customised.
⋮----
async function getBytes(value: BlobLikePart | AsyncIterable&amp;lt;BlobLikePart&amp;gt;): Promise&amp;lt;Array&amp;lt;BlobPart&amp;gt;&amp;gt;
⋮----
ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
⋮----
isAsyncIterable(value) // includes Readable, ReadableStream, etc.
⋮----
parts.push(...(await getBytes(chunk as BlobLikePart))); // TODO, consider validating?
⋮----
function propsForError(value: unknown): string&lt;/file&gt;&lt;file path=&quot;src/internal/types.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
export type PromiseOrValue&amp;lt;T&amp;gt; = T | Promise&amp;lt;T&amp;gt;;
export type HTTPMethod = &amp;apos;get&amp;apos; | &amp;apos;post&amp;apos; | &amp;apos;put&amp;apos; | &amp;apos;patch&amp;apos; | &amp;apos;delete&amp;apos;;
export type KeysEnum&amp;lt;T&amp;gt; = { [P in keyof Required&amp;lt;T&amp;gt;]: true };
export type FinalizedRequestInit = RequestInit &amp;amp; { headers: Headers };
type NotAny&amp;lt;T&amp;gt; = [unknown] extends [T] ? never : T;
/**
 * Some environments overload the global fetch function, and Parameters&amp;lt;T&amp;gt; only gets the last signature.
 */
type OverloadedParameters&amp;lt;T&amp;gt; =
  T extends (
    {
      (...args: infer A): unknown;
      (...args: infer B): unknown;
      (...args: infer C): unknown;
      (...args: infer D): unknown;
    }
  ) ?
    A | B | C | D
  : T extends (
    {
      (...args: infer A): unknown;
      (...args: infer B): unknown;
      (...args: infer C): unknown;
    }
  ) ?
    A | B | C
  : T extends (
    {
      (...args: infer A): unknown;
      (...args: infer B): unknown;
    }
  ) ?
    A | B
  : T extends (...args: infer A) =&amp;gt; unknown ? A
  : never;
/* eslint-disable */
/**
 * These imports attempt to get types from a parent package&amp;apos;s dependencies.
 * Unresolved bare specifiers can trigger [automatic type acquisition][1] in some projects, which
 * would cause typescript to show types not present at runtime. To avoid this, we import
 * directly from parent node_modules folders.
 *
 * We need to check multiple levels because we don&amp;apos;t know what directory structure we&amp;apos;ll be in.
 * For example, pnpm generates directories like this:
 * ```
 * node_modules
 * ├── .pnpm
 * │   └── pkg@1.0.0
 * │       └── node_modules
 * │           └── pkg
 * │               └── internal
 * │                   └── types.d.ts
 * ├── pkg -&amp;gt; .pnpm/pkg@1.0.0/node_modules/pkg
 * └── undici
 * ```
 *
 * [1]: https://www.typescriptlang.org/tsconfig/#typeAcquisition
 */
/** @ts-ignore For users with \@types/node */
type UndiciTypesRequestInit = NotAny&amp;lt;import(&amp;apos;../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../../../node_modules/undici-types&amp;apos;).RequestInit&amp;gt;;
/** @ts-ignore For users with undici */
type UndiciRequestInit = NotAny&amp;lt;import(&amp;apos;../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../../node_modules/undici&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../../../node_modules/undici&amp;apos;).RequestInit&amp;gt;;
/** @ts-ignore For users with \@types/bun */
type BunRequestInit = globalThis.FetchRequestInit;
/** @ts-ignore For users with node-fetch */
type NodeFetchRequestInit = NotAny&amp;lt;import(&amp;apos;../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt; | NotAny&amp;lt;import(&amp;apos;../../../../../../../../../../node_modules/node-fetch&amp;apos;).RequestInit&amp;gt;;
/** @ts-ignore For users who use Deno */
type FetchRequestInit = NonNullable&amp;lt;OverloadedParameters&amp;lt;typeof fetch&amp;gt;[1]&amp;gt;;
/* eslint-enable */
type RequestInits =
  | NotAny&amp;lt;UndiciTypesRequestInit&amp;gt;
  | NotAny&amp;lt;UndiciRequestInit&amp;gt;
  | NotAny&amp;lt;BunRequestInit&amp;gt;
  | NotAny&amp;lt;NodeFetchRequestInit&amp;gt;
  | NotAny&amp;lt;RequestInit&amp;gt;
  | NotAny&amp;lt;FetchRequestInit&amp;gt;;
/**
 * This type contains `RequestInit` options that may be available on the current runtime,
 * including per-platform extensions like `dispatcher`, `agent`, `client`, etc.
 */
export type MergedRequestInit = RequestInits &amp;amp;
  /** We don&amp;apos;t include these in the types as they&amp;apos;ll be overridden for every request. */
  Partial&amp;lt;Record&amp;lt;&amp;apos;body&amp;apos; | &amp;apos;headers&amp;apos; | &amp;apos;method&amp;apos; | &amp;apos;signal&amp;apos;, never&amp;gt;&amp;gt;;
⋮----
/** We don&amp;apos;t include these in the types as they&amp;apos;ll be overridden for every request. */&lt;/file&gt;&lt;file path=&quot;src/internal/uploads.ts&quot;&gt;import { type RequestOptions } from &amp;apos;./request-options&amp;apos;;
import type { FilePropertyBag, Fetch } from &amp;apos;./builtin-types&amp;apos;;
import type { BaseAnthropic } from &amp;apos;../client&amp;apos;;
import { ReadableStreamFrom } from &amp;apos;./shims&amp;apos;;
export type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | DataView;
type FsReadStream = AsyncIterable&amp;lt;Uint8Array&amp;gt; &amp;amp; { path: string | { toString(): string } };
// https://github.com/oven-sh/bun/issues/5980
interface BunFile extends Blob {
  readonly name?: string | undefined;
}
export const checkFileSupport = () =&amp;gt;
/**
 * Typically, this is a native &amp;quot;File&amp;quot; class.
 *
 * We provide the {@link toFile} utility to convert a variety of objects
 * into the File class.
 *
 * For convenience, you can also pass a fetch Response, or in Node,
 * the result of fs.createReadStream().
 */
export type Uploadable = File | Response | FsReadStream | BunFile;
/**
 * Construct a `File` instance. This is used to ensure a helpful error is thrown
 * for environments that don&amp;apos;t define a global `File` yet.
 */
export function makeFile(
  fileBits: BlobPart[],
  fileName: string | undefined,
  options?: FilePropertyBag,
): File
export function getName(value: any): string | undefined
export const isAsyncIterable = (value: any): value is AsyncIterable&amp;lt;any&amp;gt;
/**
 * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.
 * Otherwise returns the request as is.
 */
export const maybeMultipartFormRequestOptions = async (
  opts: RequestOptions,
  fetch: BaseAnthropic | Fetch,
): Promise&amp;lt;RequestOptions&amp;gt; =&amp;gt;
type MultipartFormRequestOptions = Omit&amp;lt;RequestOptions, &amp;apos;body&amp;apos;&amp;gt; &amp;amp; { body: unknown };
export const multipartFormRequestOptions = async (
  opts: MultipartFormRequestOptions,
  fetch: BaseAnthropic | Fetch,
): Promise&amp;lt;RequestOptions&amp;gt; =&amp;gt;
⋮----
/**
 * node-fetch doesn&amp;apos;t support the global FormData object in recent node versions. Instead of sending
 * properly-encoded form data, it just stringifies the object, resulting in a request body of &amp;quot;[object FormData]&amp;quot;.
 * This function detects if the fetch function provided supports the global FormData object to avoid
 * confusing error messages later on.
 */
function supportsFormData(fetchObject: BaseAnthropic | Fetch): Promise&amp;lt;boolean&amp;gt;
⋮----
// avoid false negatives
⋮----
export const createForm = async &amp;lt;T = Record&amp;lt;string, unknown&amp;gt;&amp;gt;(
  body: T | undefined,
  fetch: BaseAnthropic | Fetch,
): Promise&amp;lt;FormData&amp;gt; =&amp;gt;
// We check for Blob not File because Bun.File doesn&amp;apos;t inherit from File,
// but they both inherit from Blob and have a `name` property at runtime.
const isNamedBlob = (value: object): value is Blob
const isUploadable = (value: unknown)
const hasUploadableValue = (value: unknown): boolean =&amp;gt;
const addFormValue = async (form: FormData, key: string, value: unknown): Promise&amp;lt;void&amp;gt; =&amp;gt;
⋮----
// TODO: make nested formats configurable&lt;/file&gt;&lt;file path=&quot;src/internal/utils.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/lib/.keep&quot;&gt;File generated from our OpenAPI spec by Stainless.
This directory can be used to store custom files to expand the SDK.
It is ignored by Stainless code generation and its content (other than this keep file) won&amp;apos;t be touched.&lt;/file&gt;&lt;file path=&quot;src/lib/BetaMessageStream.ts&quot;&gt;import { isAbortError } from &amp;apos;../internal/errors&amp;apos;;
import { AnthropicError, APIUserAbortError } from &amp;apos;../error&amp;apos;;
import {
  type BetaContentBlock,
  Messages as BetaMessages,
  type BetaMessage,
  type BetaRawMessageStreamEvent as BetaMessageStreamEvent,
  type BetaMessageParam,
  type MessageCreateParams as BetaMessageCreateParams,
  type MessageCreateParamsBase as BetaMessageCreateParamsBase,
  type BetaTextBlock,
  type BetaTextCitation,
} from &amp;apos;../resources/beta/messages/messages&amp;apos;;
import { Stream } from &amp;apos;../streaming&amp;apos;;
import { partialParse } from &amp;apos;../_vendor/partial-json-parser/parser&amp;apos;;
import { type RequestOptions } from &amp;apos;../internal/request-options&amp;apos;;
import { type ReadableStream } from &amp;apos;../internal/shim-types&amp;apos;;
export interface MessageStreamEvents {
  connect: () =&amp;gt; void;
  streamEvent: (event: BetaMessageStreamEvent, snapshot: BetaMessage) =&amp;gt; void;
  text: (textDelta: string, textSnapshot: string) =&amp;gt; void;
  citation: (citation: BetaTextCitation, citationsSnapshot: BetaTextCitation[]) =&amp;gt; void;
  inputJson: (partialJson: string, jsonSnapshot: unknown) =&amp;gt; void;
  thinking: (thinkingDelta: string, thinkingSnapshot: string) =&amp;gt; void;
  signature: (signature: string) =&amp;gt; void;
  message: (message: BetaMessage) =&amp;gt; void;
  contentBlock: (content: BetaContentBlock) =&amp;gt; void;
  finalMessage: (message: BetaMessage) =&amp;gt; void;
  error: (error: AnthropicError) =&amp;gt; void;
  abort: (error: APIUserAbortError) =&amp;gt; void;
  end: () =&amp;gt; void;
}
type MessageStreamEventListeners&amp;lt;Event extends keyof MessageStreamEvents&amp;gt; = {
  listener: MessageStreamEvents[Event];
  once?: boolean;
}[];
⋮----
export class BetaMessageStream implements AsyncIterable&amp;lt;BetaMessageStreamEvent&amp;gt;
⋮----
constructor()
⋮----
// Don&amp;apos;t let these promises cause unhandled rejection errors.
// we will manually cause an unhandled rejection error later
// if the user hasn&amp;apos;t registered any error listener or called
// any promise-returning method.
⋮----
get response(): Response | null | undefined
get request_id(): string | null | undefined
/**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
async withResponse(): Promise&amp;lt;
/**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on(&amp;apos;message&amp;apos;)`
   * in this context.
   */
static fromReadableStream(stream: ReadableStream): BetaMessageStream
static createMessage(
    messages: BetaMessages,
    params: BetaMessageCreateParamsBase,
    options?: RequestOptions,
): BetaMessageStream
protected _run(executor: () =&amp;gt; Promise&amp;lt;any&amp;gt;)
protected _addMessageParam(message: BetaMessageParam)
protected _addMessage(message: BetaMessage, emit = true)
protected async _createMessage(
    messages: BetaMessages,
    params: BetaMessageCreateParams,
    options?: RequestOptions,
): Promise&amp;lt;void&amp;gt;
protected _connected(response: Response | null)
get ended(): boolean
get errored(): boolean
get aborted(): boolean
abort()
/**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
on&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(event: Event, listener: MessageStreamEvents[Event]): this
/**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
off&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(event: Event, listener: MessageStreamEvents[Event]): this
/**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
once&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(event: Event, listener: MessageStreamEvents[Event]): this
/**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the &amp;apos;error&amp;apos; event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted(&amp;apos;message&amp;apos;) // rejects if the stream errors
   */
emitted&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(
    event: Event,
  ): Promise&amp;lt;
    Parameters&amp;lt;MessageStreamEvents[Event]&amp;gt; extends [infer Param] ? Param
    : Parameters&amp;lt;MessageStreamEvents[Event]&amp;gt; extends [] ? void
    : Parameters&amp;lt;MessageStreamEvents[Event]&amp;gt;
  &amp;gt; {
return new Promise((resolve, reject) =&amp;gt;
async done(): Promise&amp;lt;void&amp;gt;
get currentMessage(): BetaMessage | undefined
⋮----
/**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
async finalMessage(): Promise&amp;lt;BetaMessage&amp;gt;
⋮----
/**
   * @returns a promise that resolves with the the final assistant Message&amp;apos;s text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
async finalText(): Promise&amp;lt;string&amp;gt;
⋮----
// @ts-ignore
⋮----
protected _emit&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(
    event: Event,
    ...args: Parameters&amp;lt;MessageStreamEvents[Event]&amp;gt;
)
⋮----
// make sure we don&amp;apos;t emit any MessageStreamEvents after end
⋮----
// NOTE: _emit(&amp;apos;error&amp;apos;, error) should only be called from #handleError().
⋮----
// Trigger an unhandled rejection if the user hasn&amp;apos;t registered any error handlers.
// If you are seeing stack traces here, make sure to handle errors via either:
// - runner.on(&amp;apos;error&amp;apos;, () =&amp;gt; ...)
// - await runner.done()
// - await runner.final...()
// - etc.
⋮----
protected _emitFinal()
⋮----
protected async _fromReadableStream(
    readableStream: ReadableStream,
    options?: RequestOptions,
): Promise&amp;lt;void&amp;gt;
/**
   * Mutates this.#currentMessage with the current event. Handling the accumulation of multiple messages
   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple
   * messages.
   */
⋮----
// we need to keep track of the raw JSON string as well so that we can
// re-parse it for each delta, for now we just store it as an untyped
// non-enumerable property on the snapshot
⋮----
toReadableStream(): ReadableStream
⋮----
// used to ensure exhaustive case matching without throwing a runtime error
function checkNever(x: never)&lt;/file&gt;&lt;file path=&quot;src/lib/MessageStream.ts&quot;&gt;import { isAbortError } from &amp;apos;../internal/errors&amp;apos;;
import { AnthropicError, APIUserAbortError } from &amp;apos;../error&amp;apos;;
import {
  type ContentBlock,
  Messages,
  type Message,
  type MessageStreamEvent,
  type MessageParam,
  type MessageCreateParams,
  type MessageCreateParamsBase,
  type TextBlock,
  type TextCitation,
} from &amp;apos;../resources/messages&amp;apos;;
import { Stream } from &amp;apos;../streaming&amp;apos;;
import { partialParse } from &amp;apos;../_vendor/partial-json-parser/parser&amp;apos;;
import { RequestOptions } from &amp;apos;../internal/request-options&amp;apos;;
import { type ReadableStream } from &amp;apos;../internal/shim-types&amp;apos;;
export interface MessageStreamEvents {
  connect: () =&amp;gt; void;
  streamEvent: (event: MessageStreamEvent, snapshot: Message) =&amp;gt; void;
  text: (textDelta: string, textSnapshot: string) =&amp;gt; void;
  citation: (citation: TextCitation, citationsSnapshot: TextCitation[]) =&amp;gt; void;
  inputJson: (partialJson: string, jsonSnapshot: unknown) =&amp;gt; void;
  thinking: (thinkingDelta: string, thinkingSnapshot: string) =&amp;gt; void;
  signature: (signature: string) =&amp;gt; void;
  message: (message: Message) =&amp;gt; void;
  contentBlock: (content: ContentBlock) =&amp;gt; void;
  finalMessage: (message: Message) =&amp;gt; void;
  error: (error: AnthropicError) =&amp;gt; void;
  abort: (error: APIUserAbortError) =&amp;gt; void;
  end: () =&amp;gt; void;
}
type MessageStreamEventListeners&amp;lt;Event extends keyof MessageStreamEvents&amp;gt; = {
  listener: MessageStreamEvents[Event];
  once?: boolean;
}[];
⋮----
export class MessageStream implements AsyncIterable&amp;lt;MessageStreamEvent&amp;gt;
⋮----
constructor()
⋮----
// Don&amp;apos;t let these promises cause unhandled rejection errors.
// we will manually cause an unhandled rejection error later
// if the user hasn&amp;apos;t registered any error listener or called
// any promise-returning method.
⋮----
get response(): Response | null | undefined
get request_id(): string | null | undefined
/**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
async withResponse(): Promise&amp;lt;
/**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on(&amp;apos;message&amp;apos;)`
   * in this context.
   */
static fromReadableStream(stream: ReadableStream): MessageStream
static createMessage(
    messages: Messages,
    params: MessageCreateParamsBase,
    options?: RequestOptions,
): MessageStream
protected _run(executor: () =&amp;gt; Promise&amp;lt;any&amp;gt;)
protected _addMessageParam(message: MessageParam)
protected _addMessage(message: Message, emit = true)
protected async _createMessage(
    messages: Messages,
    params: MessageCreateParams,
    options?: RequestOptions,
): Promise&amp;lt;void&amp;gt;
protected _connected(response: Response | null)
get ended(): boolean
get errored(): boolean
get aborted(): boolean
abort()
/**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
on&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(event: Event, listener: MessageStreamEvents[Event]): this
/**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
off&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(event: Event, listener: MessageStreamEvents[Event]): this
/**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
once&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(event: Event, listener: MessageStreamEvents[Event]): this
/**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the &amp;apos;error&amp;apos; event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted(&amp;apos;message&amp;apos;) // rejects if the stream errors
   */
emitted&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(
    event: Event,
  ): Promise&amp;lt;
    Parameters&amp;lt;MessageStreamEvents[Event]&amp;gt; extends [infer Param] ? Param
    : Parameters&amp;lt;MessageStreamEvents[Event]&amp;gt; extends [] ? void
    : Parameters&amp;lt;MessageStreamEvents[Event]&amp;gt;
  &amp;gt; {
return new Promise((resolve, reject) =&amp;gt;
async done(): Promise&amp;lt;void&amp;gt;
get currentMessage(): Message | undefined
⋮----
/**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
async finalMessage(): Promise&amp;lt;Message&amp;gt;
⋮----
/**
   * @returns a promise that resolves with the the final assistant Message&amp;apos;s text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
async finalText(): Promise&amp;lt;string&amp;gt;
⋮----
// @ts-ignore
⋮----
protected _emit&amp;lt;Event extends keyof MessageStreamEvents&amp;gt;(
    event: Event,
    ...args: Parameters&amp;lt;MessageStreamEvents[Event]&amp;gt;
)
⋮----
// make sure we don&amp;apos;t emit any MessageStreamEvents after end
⋮----
// NOTE: _emit(&amp;apos;error&amp;apos;, error) should only be called from #handleError().
⋮----
// Trigger an unhandled rejection if the user hasn&amp;apos;t registered any error handlers.
// If you are seeing stack traces here, make sure to handle errors via either:
// - runner.on(&amp;apos;error&amp;apos;, () =&amp;gt; ...)
// - await runner.done()
// - await runner.final...()
// - etc.
⋮----
protected _emitFinal()
⋮----
protected async _fromReadableStream(
    readableStream: ReadableStream,
    options?: RequestOptions,
): Promise&amp;lt;void&amp;gt;
/**
   * Mutates this.#currentMessage with the current event. Handling the accumulation of multiple messages
   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple
   * messages.
   */
⋮----
// Update other usage fields if they exist in the event
⋮----
// we need to keep track of the raw JSON string as well so that we can
// re-parse it for each delta, for now we just store it as an untyped
// non-enumerable property on the snapshot
⋮----
toReadableStream(): ReadableStream
⋮----
// used to ensure exhaustive case matching without throwing a runtime error
function checkNever(x: never)&lt;/file&gt;&lt;file path=&quot;src/resources/beta/messages/batches.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from &amp;apos;../../../core/resource&amp;apos;;
⋮----
import { APIPromise } from &amp;apos;../../../core/api-promise&amp;apos;;
⋮----
import { Page, type PageParams, PagePromise } from &amp;apos;../../../core/pagination&amp;apos;;
import { buildHeaders } from &amp;apos;../../../internal/headers&amp;apos;;
import { RequestOptions } from &amp;apos;../../../internal/request-options&amp;apos;;
import { JSONLDecoder } from &amp;apos;../../../internal/decoders/jsonl&amp;apos;;
import { AnthropicError } from &amp;apos;../../../error&amp;apos;;
import { path } from &amp;apos;../../../internal/utils/path&amp;apos;;
export class Batches extends APIResource
⋮----
/**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.create({
   *     requests: [
   *       {
   *         custom_id: &amp;apos;my-custom-id-1&amp;apos;,
   *         params: {
   *           max_tokens: 1024,
   *           messages: [
   *             { content: &amp;apos;Hello, world&amp;apos;, role: &amp;apos;user&amp;apos; },
   *           ],
   *           model: &amp;apos;claude-3-7-sonnet-20250219&amp;apos;,
   *         },
   *       },
   *     ],
   *   });
   * ```
   */
create(params: BatchCreateParams, options?: RequestOptions): APIPromise&amp;lt;BetaMessageBatch&amp;gt;
/**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.retrieve(
   *     &amp;apos;message_batch_id&amp;apos;,
   *   );
   * ```
   */
retrieve(
    messageBatchID: string,
    params: BatchRetrieveParams | null | undefined = {},
    options?: RequestOptions,
): APIPromise&amp;lt;BetaMessageBatch&amp;gt;
/**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaMessageBatch of client.beta.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
list(
    params: BatchListParams | null | undefined = {},
    options?: RequestOptions,
): PagePromise&amp;lt;BetaMessageBatchesPage, BetaMessageBatch&amp;gt;
/**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they&amp;apos;ve finished processing. If you&amp;apos;d
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaDeletedMessageBatch =
   *   await client.beta.messages.batches.delete(
   *     &amp;apos;message_batch_id&amp;apos;,
   *   );
   * ```
   */
delete(
    messageBatchID: string,
    params: BatchDeleteParams | null | undefined = {},
    options?: RequestOptions,
): APIPromise&amp;lt;BetaDeletedMessageBatch&amp;gt;
/**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.cancel(
   *     &amp;apos;message_batch_id&amp;apos;,
   *   );
   * ```
   */
cancel(
    messageBatchID: string,
    params: BatchCancelParams | null | undefined = {},
    options?: RequestOptions,
): APIPromise&amp;lt;BetaMessageBatch&amp;gt;
/**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatchIndividualResponse =
   *   await client.beta.messages.batches.results(
   *     &amp;apos;message_batch_id&amp;apos;,
   *   );
   * ```
   */
async results(
    messageBatchID: string,
    params: BatchResultsParams | undefined = {},
    options?: RequestOptions,
): Promise&amp;lt;JSONLDecoder&amp;lt;BetaMessageBatchIndividualResponse&amp;gt;&amp;gt;
⋮----
export type BetaMessageBatchesPage = Page&amp;lt;BetaMessageBatch&amp;gt;;
export interface BetaDeletedMessageBatch {
  /**
   * ID of the Message Batch.
   */
  id: string;
  /**
   * Deleted object type.
   *
   * For Message Batches, this is always `&amp;quot;message_batch_deleted&amp;quot;`.
   */
  type: &amp;apos;message_batch_deleted&amp;apos;;
}
⋮----
/**
   * ID of the Message Batch.
   */
⋮----
/**
   * Deleted object type.
   *
   * For Message Batches, this is always `&amp;quot;message_batch_deleted&amp;quot;`.
   */
⋮----
export interface BetaMessageBatch {
  /**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
  id: string;
  /**
   * RFC 3339 datetime string representing the time at which the Message Batch was
   * archived and its results became unavailable.
   */
  archived_at: string | null;
  /**
   * RFC 3339 datetime string representing the time at which cancellation was
   * initiated for the Message Batch. Specified only if cancellation was initiated.
   */
  cancel_initiated_at: string | null;
  /**
   * RFC 3339 datetime string representing the time at which the Message Batch was
   * created.
   */
  created_at: string;
  /**
   * RFC 3339 datetime string representing the time at which processing for the
   * Message Batch ended. Specified only once processing ends.
   *
   * Processing ends when every request in a Message Batch has either succeeded,
   * errored, canceled, or expired.
   */
  ended_at: string | null;
  /**
   * RFC 3339 datetime string representing the time at which the Message Batch will
   * expire and end processing, which is 24 hours after creation.
   */
  expires_at: string;
  /**
   * Processing status of the Message Batch.
   */
  processing_status: &amp;apos;in_progress&amp;apos; | &amp;apos;canceling&amp;apos; | &amp;apos;ended&amp;apos;;
  /**
   * Tallies requests within the Message Batch, categorized by their status.
   *
   * Requests start as `processing` and move to one of the other statuses only once
   * processing of the entire batch ends. The sum of all values always matches the
   * total number of requests in the batch.
   */
  request_counts: BetaMessageBatchRequestCounts;
  /**
   * URL to a `.jsonl` file containing the results of the Message Batch requests.
   * Specified only once processing ends.
   *
   * Results in the file are not guaranteed to be in the same order as requests. Use
   * the `custom_id` field to match results to requests.
   */
  results_url: string | null;
  /**
   * Object type.
   *
   * For Message Batches, this is always `&amp;quot;message_batch&amp;quot;`.
   */
  type: &amp;apos;message_batch&amp;apos;;
}
⋮----
/**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which the Message Batch was
   * archived and its results became unavailable.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which cancellation was
   * initiated for the Message Batch. Specified only if cancellation was initiated.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which the Message Batch was
   * created.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which processing for the
   * Message Batch ended. Specified only once processing ends.
   *
   * Processing ends when every request in a Message Batch has either succeeded,
   * errored, canceled, or expired.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which the Message Batch will
   * expire and end processing, which is 24 hours after creation.
   */
⋮----
/**
   * Processing status of the Message Batch.
   */
⋮----
/**
   * Tallies requests within the Message Batch, categorized by their status.
   *
   * Requests start as `processing` and move to one of the other statuses only once
   * processing of the entire batch ends. The sum of all values always matches the
   * total number of requests in the batch.
   */
⋮----
/**
   * URL to a `.jsonl` file containing the results of the Message Batch requests.
   * Specified only once processing ends.
   *
   * Results in the file are not guaranteed to be in the same order as requests. Use
   * the `custom_id` field to match results to requests.
   */
⋮----
/**
   * Object type.
   *
   * For Message Batches, this is always `&amp;quot;message_batch&amp;quot;`.
   */
⋮----
export interface BetaMessageBatchCanceledResult {
  type: &amp;apos;canceled&amp;apos;;
}
export interface BetaMessageBatchErroredResult {
  error: BetaAPI.BetaErrorResponse;
  type: &amp;apos;errored&amp;apos;;
}
export interface BetaMessageBatchExpiredResult {
  type: &amp;apos;expired&amp;apos;;
}
/**
 * This is a single line in the response `.jsonl` file and does not represent the
 * response as a whole.
 */
export interface BetaMessageBatchIndividualResponse {
  /**
   * Developer-provided ID created for each request in a Message Batch. Useful for
   * matching results to requests, as results may be given out of request order.
   *
   * Must be unique for each request within the Message Batch.
   */
  custom_id: string;
  /**
   * Processing result for this request.
   *
   * Contains a Message output if processing was successful, an error response if
   * processing failed, or the reason why processing was not attempted, such as
   * cancellation or expiration.
   */
  result: BetaMessageBatchResult;
}
⋮----
/**
   * Developer-provided ID created for each request in a Message Batch. Useful for
   * matching results to requests, as results may be given out of request order.
   *
   * Must be unique for each request within the Message Batch.
   */
⋮----
/**
   * Processing result for this request.
   *
   * Contains a Message output if processing was successful, an error response if
   * processing failed, or the reason why processing was not attempted, such as
   * cancellation or expiration.
   */
⋮----
export interface BetaMessageBatchRequestCounts {
  /**
   * Number of requests in the Message Batch that have been canceled.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
  canceled: number;
  /**
   * Number of requests in the Message Batch that encountered an error.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
  errored: number;
  /**
   * Number of requests in the Message Batch that have expired.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
  expired: number;
  /**
   * Number of requests in the Message Batch that are processing.
   */
  processing: number;
  /**
   * Number of requests in the Message Batch that have completed successfully.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
  succeeded: number;
}
⋮----
/**
   * Number of requests in the Message Batch that have been canceled.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
⋮----
/**
   * Number of requests in the Message Batch that encountered an error.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
⋮----
/**
   * Number of requests in the Message Batch that have expired.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
⋮----
/**
   * Number of requests in the Message Batch that are processing.
   */
⋮----
/**
   * Number of requests in the Message Batch that have completed successfully.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
⋮----
/**
 * Processing result for this request.
 *
 * Contains a Message output if processing was successful, an error response if
 * processing failed, or the reason why processing was not attempted, such as
 * cancellation or expiration.
 */
export type BetaMessageBatchResult =
  | BetaMessageBatchSucceededResult
  | BetaMessageBatchErroredResult
  | BetaMessageBatchCanceledResult
  | BetaMessageBatchExpiredResult;
export interface BetaMessageBatchSucceededResult {
  message: BetaMessagesAPI.BetaMessage;
  type: &amp;apos;succeeded&amp;apos;;
}
export interface BatchCreateParams {
  /**
   * Body param: List of requests for prompt completion. Each is an individual
   * request to create a Message.
   */
  requests: Array&amp;lt;BatchCreateParams.Request&amp;gt;;
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Body param: List of requests for prompt completion. Each is an individual
   * request to create a Message.
   */
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface Request {
    /**
     * Developer-provided ID created for each request in a Message Batch. Useful for
     * matching results to requests, as results may be given out of request order.
     *
     * Must be unique for each request within the Message Batch.
     */
    custom_id: string;
    /**
     * Messages API creation parameters for the individual request.
     *
     * See the [Messages API reference](/en/api/messages) for full documentation on
     * available parameters.
     */
    params: Omit&amp;lt;BetaMessagesAPI.MessageCreateParamsNonStreaming, &amp;apos;betas&amp;apos;&amp;gt;;
  }
⋮----
/**
     * Developer-provided ID created for each request in a Message Batch. Useful for
     * matching results to requests, as results may be given out of request order.
     *
     * Must be unique for each request within the Message Batch.
     */
⋮----
/**
     * Messages API creation parameters for the individual request.
     *
     * See the [Messages API reference](/en/api/messages) for full documentation on
     * available parameters.
     */
⋮----
export interface BatchRetrieveParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface BatchListParams extends PageParams {
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface BatchDeleteParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface BatchCancelParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface BatchResultsParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */&lt;/file&gt;&lt;file path=&quot;src/resources/beta/messages/index.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/resources/beta/messages/messages.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from &amp;apos;../../../core/resource&amp;apos;;
⋮----
import {
  BatchCancelParams,
  BatchCreateParams,
  BatchDeleteParams,
  BatchListParams,
  BatchResultsParams,
  BatchRetrieveParams,
  Batches,
  BetaDeletedMessageBatch,
  BetaMessageBatch,
  BetaMessageBatchCanceledResult,
  BetaMessageBatchErroredResult,
  BetaMessageBatchExpiredResult,
  BetaMessageBatchIndividualResponse,
  BetaMessageBatchRequestCounts,
  BetaMessageBatchResult,
  BetaMessageBatchSucceededResult,
  BetaMessageBatchesPage,
} from &amp;apos;./batches&amp;apos;;
import { APIPromise } from &amp;apos;../../../core/api-promise&amp;apos;;
import { Stream } from &amp;apos;../../../core/streaming&amp;apos;;
import { buildHeaders } from &amp;apos;../../../internal/headers&amp;apos;;
import { RequestOptions } from &amp;apos;../../../internal/request-options&amp;apos;;
import type { Model } from &amp;apos;../../messages/messages&amp;apos;;
import { BetaMessageStream } from &amp;apos;../../../lib/BetaMessageStream&amp;apos;;
⋮----
import { MODEL_NONSTREAMING_TOKENS } from &amp;apos;../../../internal/constants&amp;apos;;
export class Messages extends APIResource
⋮----
/**
   * Send a structured list of input messages with text and/or image content, and the
   * model will generate the next message in the conversation.
   *
   * The Messages API can be used for either single queries or stateless multi-turn
   * conversations.
   *
   * Learn more about the Messages API in our [user guide](/en/docs/initial-setup)
   *
   * @example
   * ```ts
   * const betaMessage = await client.beta.messages.create({
   *   max_tokens: 1024,
   *   messages: [{ content: &amp;apos;Hello, world&amp;apos;, role: &amp;apos;user&amp;apos; }],
   *   model: &amp;apos;claude-3-7-sonnet-20250219&amp;apos;,
   * });
   * ```
   */
create(params: MessageCreateParamsNonStreaming, options?: RequestOptions): APIPromise&amp;lt;BetaMessage&amp;gt;;
create(
    params: MessageCreateParamsStreaming,
    options?: RequestOptions,
  ): APIPromise&amp;lt;Stream&amp;lt;BetaRawMessageStreamEvent&amp;gt;&amp;gt;;
create(
    params: MessageCreateParamsBase,
    options?: RequestOptions,
  ): APIPromise&amp;lt;Stream&amp;lt;BetaRawMessageStreamEvent&amp;gt; | BetaMessage&amp;gt;;
create(
    params: MessageCreateParams,
    options?: RequestOptions,
): APIPromise&amp;lt;BetaMessage&amp;gt; | APIPromise&amp;lt;Stream&amp;lt;BetaRawMessageStreamEvent&amp;gt;&amp;gt;
/**
   * Create a Message stream
   */
stream(body: BetaMessageStreamParams, options?: RequestOptions): BetaMessageStream
/**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const betaMessageTokensCount =
   *   await client.beta.messages.countTokens({
   *     messages: [{ content: &amp;apos;string&amp;apos;, role: &amp;apos;user&amp;apos; }],
   *     model: &amp;apos;claude-3-7-sonnet-latest&amp;apos;,
   *   });
   * ```
   */
countTokens(
    params: MessageCountTokensParams,
    options?: RequestOptions,
): APIPromise&amp;lt;BetaMessageTokensCount&amp;gt;
⋮----
export type BetaMessageStreamParams = MessageCreateParamsBase;
export interface BetaBase64ImageSource {
  data: string;
  media_type: &amp;apos;image/jpeg&amp;apos; | &amp;apos;image/png&amp;apos; | &amp;apos;image/gif&amp;apos; | &amp;apos;image/webp&amp;apos;;
  type: &amp;apos;base64&amp;apos;;
}
export interface BetaBase64PDFBlock {
  source:
    | BetaBase64PDFSource
    | BetaPlainTextSource
    | BetaContentBlockSource
    | BetaURLPDFSource
    | BetaFileDocumentSource;
  type: &amp;apos;document&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
  citations?: BetaCitationsConfigParam;
  context?: string | null;
  title?: string | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaBase64PDFSource {
  data: string;
  media_type: &amp;apos;application/pdf&amp;apos;;
  type: &amp;apos;base64&amp;apos;;
}
export interface BetaCacheControlEphemeral {
  type: &amp;apos;ephemeral&amp;apos;;
  /**
   * The time-to-live for the cache control breakpoint.
   *
   * This may be one the following values:
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`.
   */
  ttl?: &amp;apos;5m&amp;apos; | &amp;apos;1h&amp;apos;;
}
⋮----
/**
   * The time-to-live for the cache control breakpoint.
   *
   * This may be one the following values:
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`.
   */
⋮----
export interface BetaCacheCreation {
  /**
   * The number of input tokens used to create the 1 hour cache entry.
   */
  ephemeral_1h_input_tokens: number;
  /**
   * The number of input tokens used to create the 5 minute cache entry.
   */
  ephemeral_5m_input_tokens: number;
}
⋮----
/**
   * The number of input tokens used to create the 1 hour cache entry.
   */
⋮----
/**
   * The number of input tokens used to create the 5 minute cache entry.
   */
⋮----
export interface BetaCitationCharLocation {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_char_index: number;
  start_char_index: number;
  type: &amp;apos;char_location&amp;apos;;
}
export interface BetaCitationCharLocationParam {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_char_index: number;
  start_char_index: number;
  type: &amp;apos;char_location&amp;apos;;
}
export interface BetaCitationContentBlockLocation {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_block_index: number;
  start_block_index: number;
  type: &amp;apos;content_block_location&amp;apos;;
}
export interface BetaCitationContentBlockLocationParam {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_block_index: number;
  start_block_index: number;
  type: &amp;apos;content_block_location&amp;apos;;
}
export interface BetaCitationPageLocation {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_page_number: number;
  start_page_number: number;
  type: &amp;apos;page_location&amp;apos;;
}
export interface BetaCitationPageLocationParam {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_page_number: number;
  start_page_number: number;
  type: &amp;apos;page_location&amp;apos;;
}
export interface BetaCitationWebSearchResultLocationParam {
  cited_text: string;
  encrypted_index: string;
  title: string | null;
  type: &amp;apos;web_search_result_location&amp;apos;;
  url: string;
}
export interface BetaCitationsConfigParam {
  enabled?: boolean;
}
export interface BetaCitationsDelta {
  citation:
    | BetaCitationCharLocation
    | BetaCitationPageLocation
    | BetaCitationContentBlockLocation
    | BetaCitationsWebSearchResultLocation;
  type: &amp;apos;citations_delta&amp;apos;;
}
export interface BetaCitationsWebSearchResultLocation {
  cited_text: string;
  encrypted_index: string;
  title: string | null;
  type: &amp;apos;web_search_result_location&amp;apos;;
  url: string;
}
export interface BetaCodeExecutionOutputBlock {
  file_id: string;
  type: &amp;apos;code_execution_output&amp;apos;;
}
export interface BetaCodeExecutionOutputBlockParam {
  file_id: string;
  type: &amp;apos;code_execution_output&amp;apos;;
}
export interface BetaCodeExecutionResultBlock {
  content: Array&amp;lt;BetaCodeExecutionOutputBlock&amp;gt;;
  return_code: number;
  stderr: string;
  stdout: string;
  type: &amp;apos;code_execution_result&amp;apos;;
}
export interface BetaCodeExecutionResultBlockParam {
  content: Array&amp;lt;BetaCodeExecutionOutputBlockParam&amp;gt;;
  return_code: number;
  stderr: string;
  stdout: string;
  type: &amp;apos;code_execution_result&amp;apos;;
}
export interface BetaCodeExecutionTool20250522 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;code_execution&amp;apos;;
  type: &amp;apos;code_execution_20250522&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaCodeExecutionToolResultBlock {
  content: BetaCodeExecutionToolResultBlockContent;
  tool_use_id: string;
  type: &amp;apos;code_execution_tool_result&amp;apos;;
}
export type BetaCodeExecutionToolResultBlockContent =
  | BetaCodeExecutionToolResultError
  | BetaCodeExecutionResultBlock;
export interface BetaCodeExecutionToolResultBlockParam {
  content: BetaCodeExecutionToolResultBlockParamContent;
  tool_use_id: string;
  type: &amp;apos;code_execution_tool_result&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export type BetaCodeExecutionToolResultBlockParamContent =
  | BetaCodeExecutionToolResultErrorParam
  | BetaCodeExecutionResultBlockParam;
export interface BetaCodeExecutionToolResultError {
  error_code: BetaCodeExecutionToolResultErrorCode;
  type: &amp;apos;code_execution_tool_result_error&amp;apos;;
}
export type BetaCodeExecutionToolResultErrorCode =
  | &amp;apos;invalid_tool_input&amp;apos;
  | &amp;apos;unavailable&amp;apos;
  | &amp;apos;too_many_requests&amp;apos;
  | &amp;apos;execution_time_exceeded&amp;apos;;
export interface BetaCodeExecutionToolResultErrorParam {
  error_code: BetaCodeExecutionToolResultErrorCode;
  type: &amp;apos;code_execution_tool_result_error&amp;apos;;
}
/**
 * Information about the container used in the request (for the code execution
 * tool)
 */
export interface BetaContainer {
  /**
   * Identifier for the container used in this request
   */
  id: string;
  /**
   * The time at which the container will expire.
   */
  expires_at: string;
}
⋮----
/**
   * Identifier for the container used in this request
   */
⋮----
/**
   * The time at which the container will expire.
   */
⋮----
/**
 * Response model for a file uploaded to the container.
 */
export interface BetaContainerUploadBlock {
  file_id: string;
  type: &amp;apos;container_upload&amp;apos;;
}
/**
 * A content block that represents a file to be uploaded to the container Files
 * uploaded via this block will be available in the container&amp;apos;s input directory.
 */
export interface BetaContainerUploadBlockParam {
  file_id: string;
  type: &amp;apos;container_upload&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
 * Response model for a file uploaded to the container.
 */
export type BetaContentBlock =
  | BetaTextBlock
  | BetaToolUseBlock
  | BetaServerToolUseBlock
  | BetaWebSearchToolResultBlock
  | BetaCodeExecutionToolResultBlock
  | BetaMCPToolUseBlock
  | BetaMCPToolResultBlock
  | BetaContainerUploadBlock
  | BetaThinkingBlock
  | BetaRedactedThinkingBlock;
/**
 * Regular text content.
 */
export type BetaContentBlockParam =
  | BetaServerToolUseBlockParam
  | BetaWebSearchToolResultBlockParam
  | BetaCodeExecutionToolResultBlockParam
  | BetaMCPToolUseBlockParam
  | BetaRequestMCPToolResultBlockParam
  | BetaTextBlockParam
  | BetaImageBlockParam
  | BetaToolUseBlockParam
  | BetaToolResultBlockParam
  | BetaBase64PDFBlock
  | BetaThinkingBlockParam
  | BetaRedactedThinkingBlockParam
  | BetaContainerUploadBlockParam;
export interface BetaContentBlockSource {
  content: string | Array&amp;lt;BetaContentBlockSourceContent&amp;gt;;
  type: &amp;apos;content&amp;apos;;
}
export type BetaContentBlockSourceContent = BetaTextBlockParam | BetaImageBlockParam;
export interface BetaFileDocumentSource {
  file_id: string;
  type: &amp;apos;file&amp;apos;;
}
export interface BetaFileImageSource {
  file_id: string;
  type: &amp;apos;file&amp;apos;;
}
export interface BetaImageBlockParam {
  source: BetaBase64ImageSource | BetaURLImageSource | BetaFileImageSource;
  type: &amp;apos;image&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaInputJSONDelta {
  partial_json: string;
  type: &amp;apos;input_json_delta&amp;apos;;
}
export interface BetaMCPToolResultBlock {
  content: string | Array&amp;lt;BetaTextBlock&amp;gt;;
  is_error: boolean;
  tool_use_id: string;
  type: &amp;apos;mcp_tool_result&amp;apos;;
}
export interface BetaMCPToolUseBlock {
  id: string;
  input: unknown;
  /**
   * The name of the MCP tool
   */
  name: string;
  /**
   * The name of the MCP server
   */
  server_name: string;
  type: &amp;apos;mcp_tool_use&amp;apos;;
}
⋮----
/**
   * The name of the MCP tool
   */
⋮----
/**
   * The name of the MCP server
   */
⋮----
export interface BetaMCPToolUseBlockParam {
  id: string;
  input: unknown;
  name: string;
  /**
   * The name of the MCP server
   */
  server_name: string;
  type: &amp;apos;mcp_tool_use&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * The name of the MCP server
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaMessage {
  /**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
  id: string;
  /**
   * Information about the container used in the request (for the code execution
   * tool)
   */
  container: BetaContainer | null;
  /**
   * Content generated by the model.
   *
   * This is an array of content blocks, each of which has a `type` that determines
   * its shape.
   *
   * Example:
   *
   * ```json
   * [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude.&amp;quot; }]
   * ```
   *
   * If the request input `messages` ended with an `assistant` turn, then the
   * response `content` will continue directly from that last turn. You can use this
   * to constrain the model&amp;apos;s output.
   *
   * For example, if the input `messages` were:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Then the response `content` might be:
   *
   * ```json
   * [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;B)&amp;quot; }]
   * ```
   */
  content: Array&amp;lt;BetaContentBlock&amp;gt;;
  /**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
  model: MessagesAPI.Model;
  /**
   * Conversational role of the generated message.
   *
   * This will always be `&amp;quot;assistant&amp;quot;`.
   */
  role: &amp;apos;assistant&amp;apos;;
  /**
   * The reason that we stopped.
   *
   * This may be one the following values:
   *
   * - `&amp;quot;end_turn&amp;quot;`: the model reached a natural stopping point
   * - `&amp;quot;max_tokens&amp;quot;`: we exceeded the requested `max_tokens` or the model&amp;apos;s maximum
   * - `&amp;quot;stop_sequence&amp;quot;`: one of your provided custom `stop_sequences` was generated
   * - `&amp;quot;tool_use&amp;quot;`: the model invoked one or more tools
   *
   * In non-streaming mode this value is always non-null. In streaming mode, it is
   * null in the `message_start` event and non-null otherwise.
   */
  stop_reason: BetaStopReason | null;
  /**
   * Which custom stop sequence was generated, if any.
   *
   * This value will be a non-null string if one of your custom stop sequences was
   * generated.
   */
  stop_sequence: string | null;
  /**
   * Object type.
   *
   * For Messages, this is always `&amp;quot;message&amp;quot;`.
   */
  type: &amp;apos;message&amp;apos;;
  /**
   * Billing and rate-limit usage.
   *
   * Anthropic&amp;apos;s API bills and rate-limits by token counts, as tokens represent the
   * underlying cost to our systems.
   *
   * Under the hood, the API transforms requests into a format suitable for the
   * model. The model&amp;apos;s output then goes through a parsing stage before becoming an
   * API response. As a result, the token counts in `usage` will not match one-to-one
   * with the exact visible content of an API request or response.
   *
   * For example, `output_tokens` will be non-zero, even for an empty string response
   * from Claude.
   *
   * Total input tokens in a request is the summation of `input_tokens`,
   * `cache_creation_input_tokens`, and `cache_read_input_tokens`.
   */
  usage: BetaUsage;
}
⋮----
/**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
⋮----
/**
   * Information about the container used in the request (for the code execution
   * tool)
   */
⋮----
/**
   * Content generated by the model.
   *
   * This is an array of content blocks, each of which has a `type` that determines
   * its shape.
   *
   * Example:
   *
   * ```json
   * [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude.&amp;quot; }]
   * ```
   *
   * If the request input `messages` ended with an `assistant` turn, then the
   * response `content` will continue directly from that last turn. You can use this
   * to constrain the model&amp;apos;s output.
   *
   * For example, if the input `messages` were:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Then the response `content` might be:
   *
   * ```json
   * [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;B)&amp;quot; }]
   * ```
   */
⋮----
/**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
⋮----
/**
   * Conversational role of the generated message.
   *
   * This will always be `&amp;quot;assistant&amp;quot;`.
   */
⋮----
/**
   * The reason that we stopped.
   *
   * This may be one the following values:
   *
   * - `&amp;quot;end_turn&amp;quot;`: the model reached a natural stopping point
   * - `&amp;quot;max_tokens&amp;quot;`: we exceeded the requested `max_tokens` or the model&amp;apos;s maximum
   * - `&amp;quot;stop_sequence&amp;quot;`: one of your provided custom `stop_sequences` was generated
   * - `&amp;quot;tool_use&amp;quot;`: the model invoked one or more tools
   *
   * In non-streaming mode this value is always non-null. In streaming mode, it is
   * null in the `message_start` event and non-null otherwise.
   */
⋮----
/**
   * Which custom stop sequence was generated, if any.
   *
   * This value will be a non-null string if one of your custom stop sequences was
   * generated.
   */
⋮----
/**
   * Object type.
   *
   * For Messages, this is always `&amp;quot;message&amp;quot;`.
   */
⋮----
/**
   * Billing and rate-limit usage.
   *
   * Anthropic&amp;apos;s API bills and rate-limits by token counts, as tokens represent the
   * underlying cost to our systems.
   *
   * Under the hood, the API transforms requests into a format suitable for the
   * model. The model&amp;apos;s output then goes through a parsing stage before becoming an
   * API response. As a result, the token counts in `usage` will not match one-to-one
   * with the exact visible content of an API request or response.
   *
   * For example, `output_tokens` will be non-zero, even for an empty string response
   * from Claude.
   *
   * Total input tokens in a request is the summation of `input_tokens`,
   * `cache_creation_input_tokens`, and `cache_read_input_tokens`.
   */
⋮----
export interface BetaMessageDeltaUsage {
  /**
   * The cumulative number of input tokens used to create the cache entry.
   */
  cache_creation_input_tokens: number | null;
  /**
   * The cumulative number of input tokens read from the cache.
   */
  cache_read_input_tokens: number | null;
  /**
   * The cumulative number of input tokens which were used.
   */
  input_tokens: number | null;
  /**
   * The cumulative number of output tokens which were used.
   */
  output_tokens: number;
  /**
   * The number of server tool requests.
   */
  server_tool_use: BetaServerToolUsage | null;
}
⋮----
/**
   * The cumulative number of input tokens used to create the cache entry.
   */
⋮----
/**
   * The cumulative number of input tokens read from the cache.
   */
⋮----
/**
   * The cumulative number of input tokens which were used.
   */
⋮----
/**
   * The cumulative number of output tokens which were used.
   */
⋮----
/**
   * The number of server tool requests.
   */
⋮----
export interface BetaMessageParam {
  content: string | Array&amp;lt;BetaContentBlockParam&amp;gt;;
  role: &amp;apos;user&amp;apos; | &amp;apos;assistant&amp;apos;;
}
export interface BetaMessageTokensCount {
  /**
   * The total number of tokens across the provided list of messages, system prompt,
   * and tools.
   */
  input_tokens: number;
}
⋮----
/**
   * The total number of tokens across the provided list of messages, system prompt,
   * and tools.
   */
⋮----
export interface BetaMetadata {
  /**
   * An external identifier for the user who is associated with the request.
   *
   * This should be a uuid, hash value, or other opaque identifier. Anthropic may use
   * this id to help detect abuse. Do not include any identifying information such as
   * name, email address, or phone number.
   */
  user_id?: string | null;
}
⋮----
/**
   * An external identifier for the user who is associated with the request.
   *
   * This should be a uuid, hash value, or other opaque identifier. Anthropic may use
   * this id to help detect abuse. Do not include any identifying information such as
   * name, email address, or phone number.
   */
⋮----
export interface BetaPlainTextSource {
  data: string;
  media_type: &amp;apos;text/plain&amp;apos;;
  type: &amp;apos;text&amp;apos;;
}
export type BetaRawContentBlockDelta =
  | BetaTextDelta
  | BetaInputJSONDelta
  | BetaCitationsDelta
  | BetaThinkingDelta
  | BetaSignatureDelta;
export interface BetaRawContentBlockDeltaEvent {
  delta: BetaRawContentBlockDelta;
  index: number;
  type: &amp;apos;content_block_delta&amp;apos;;
}
export interface BetaRawContentBlockStartEvent {
  /**
   * Response model for a file uploaded to the container.
   */
  content_block:
    | BetaTextBlock
    | BetaToolUseBlock
    | BetaServerToolUseBlock
    | BetaWebSearchToolResultBlock
    | BetaCodeExecutionToolResultBlock
    | BetaMCPToolUseBlock
    | BetaMCPToolResultBlock
    | BetaContainerUploadBlock
    | BetaThinkingBlock
    | BetaRedactedThinkingBlock;
  index: number;
  type: &amp;apos;content_block_start&amp;apos;;
}
⋮----
/**
   * Response model for a file uploaded to the container.
   */
⋮----
export interface BetaRawContentBlockStopEvent {
  index: number;
  type: &amp;apos;content_block_stop&amp;apos;;
}
export interface BetaRawMessageDeltaEvent {
  delta: BetaRawMessageDeltaEvent.Delta;
  type: &amp;apos;message_delta&amp;apos;;
  /**
   * Billing and rate-limit usage.
   *
   * Anthropic&amp;apos;s API bills and rate-limits by token counts, as tokens represent the
   * underlying cost to our systems.
   *
   * Under the hood, the API transforms requests into a format suitable for the
   * model. The model&amp;apos;s output then goes through a parsing stage before becoming an
   * API response. As a result, the token counts in `usage` will not match one-to-one
   * with the exact visible content of an API request or response.
   *
   * For example, `output_tokens` will be non-zero, even for an empty string response
   * from Claude.
   *
   * Total input tokens in a request is the summation of `input_tokens`,
   * `cache_creation_input_tokens`, and `cache_read_input_tokens`.
   */
  usage: BetaMessageDeltaUsage;
}
⋮----
/**
   * Billing and rate-limit usage.
   *
   * Anthropic&amp;apos;s API bills and rate-limits by token counts, as tokens represent the
   * underlying cost to our systems.
   *
   * Under the hood, the API transforms requests into a format suitable for the
   * model. The model&amp;apos;s output then goes through a parsing stage before becoming an
   * API response. As a result, the token counts in `usage` will not match one-to-one
   * with the exact visible content of an API request or response.
   *
   * For example, `output_tokens` will be non-zero, even for an empty string response
   * from Claude.
   *
   * Total input tokens in a request is the summation of `input_tokens`,
   * `cache_creation_input_tokens`, and `cache_read_input_tokens`.
   */
⋮----
export interface Delta {
    /**
     * Information about the container used in the request (for the code execution
     * tool)
     */
    container: MessagesMessagesAPI.BetaContainer | null;
    stop_reason: MessagesMessagesAPI.BetaStopReason | null;
    stop_sequence: string | null;
  }
⋮----
/**
     * Information about the container used in the request (for the code execution
     * tool)
     */
⋮----
export interface BetaRawMessageStartEvent {
  message: BetaMessage;
  type: &amp;apos;message_start&amp;apos;;
}
export interface BetaRawMessageStopEvent {
  type: &amp;apos;message_stop&amp;apos;;
}
export type BetaRawMessageStreamEvent =
  | BetaRawMessageStartEvent
  | BetaRawMessageDeltaEvent
  | BetaRawMessageStopEvent
  | BetaRawContentBlockStartEvent
  | BetaRawContentBlockDeltaEvent
  | BetaRawContentBlockStopEvent;
export interface BetaRedactedThinkingBlock {
  data: string;
  type: &amp;apos;redacted_thinking&amp;apos;;
}
export interface BetaRedactedThinkingBlockParam {
  data: string;
  type: &amp;apos;redacted_thinking&amp;apos;;
}
export interface BetaRequestMCPServerToolConfiguration {
  allowed_tools?: Array&amp;lt;string&amp;gt; | null;
  enabled?: boolean | null;
}
export interface BetaRequestMCPServerURLDefinition {
  name: string;
  type: &amp;apos;url&amp;apos;;
  url: string;
  authorization_token?: string | null;
  tool_configuration?: BetaRequestMCPServerToolConfiguration | null;
}
export interface BetaRequestMCPToolResultBlockParam {
  tool_use_id: string;
  type: &amp;apos;mcp_tool_result&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
  content?: string | Array&amp;lt;BetaTextBlockParam&amp;gt;;
  is_error?: boolean;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaServerToolUsage {
  /**
   * The number of web search tool requests.
   */
  web_search_requests: number;
}
⋮----
/**
   * The number of web search tool requests.
   */
⋮----
export interface BetaServerToolUseBlock {
  id: string;
  input: unknown;
  name: &amp;apos;web_search&amp;apos; | &amp;apos;code_execution&amp;apos;;
  type: &amp;apos;server_tool_use&amp;apos;;
}
export interface BetaServerToolUseBlockParam {
  id: string;
  input: unknown;
  name: &amp;apos;web_search&amp;apos; | &amp;apos;code_execution&amp;apos;;
  type: &amp;apos;server_tool_use&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaSignatureDelta {
  signature: string;
  type: &amp;apos;signature_delta&amp;apos;;
}
export type BetaStopReason =
  | &amp;apos;end_turn&amp;apos;
  | &amp;apos;max_tokens&amp;apos;
  | &amp;apos;stop_sequence&amp;apos;
  | &amp;apos;tool_use&amp;apos;
  | &amp;apos;pause_turn&amp;apos;
  | &amp;apos;refusal&amp;apos;;
export interface BetaTextBlock {
  /**
   * Citations supporting the text block.
   *
   * The type of citation returned will depend on the type of document being cited.
   * Citing a PDF results in `page_location`, plain text results in `char_location`,
   * and content document results in `content_block_location`.
   */
  citations: Array&amp;lt;BetaTextCitation&amp;gt; | null;
  text: string;
  type: &amp;apos;text&amp;apos;;
}
⋮----
/**
   * Citations supporting the text block.
   *
   * The type of citation returned will depend on the type of document being cited.
   * Citing a PDF results in `page_location`, plain text results in `char_location`,
   * and content document results in `content_block_location`.
   */
⋮----
export interface BetaTextBlockParam {
  text: string;
  type: &amp;apos;text&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
  citations?: Array&amp;lt;BetaTextCitationParam&amp;gt; | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export type BetaTextCitation =
  | BetaCitationCharLocation
  | BetaCitationPageLocation
  | BetaCitationContentBlockLocation
  | BetaCitationsWebSearchResultLocation;
export type BetaTextCitationParam =
  | BetaCitationCharLocationParam
  | BetaCitationPageLocationParam
  | BetaCitationContentBlockLocationParam
  | BetaCitationWebSearchResultLocationParam;
export interface BetaTextDelta {
  text: string;
  type: &amp;apos;text_delta&amp;apos;;
}
export interface BetaThinkingBlock {
  signature: string;
  thinking: string;
  type: &amp;apos;thinking&amp;apos;;
}
export interface BetaThinkingBlockParam {
  signature: string;
  thinking: string;
  type: &amp;apos;thinking&amp;apos;;
}
export interface BetaThinkingConfigDisabled {
  type: &amp;apos;disabled&amp;apos;;
}
export interface BetaThinkingConfigEnabled {
  /**
   * Determines how many tokens Claude can use for its internal reasoning process.
   * Larger budgets can enable more thorough analysis for complex problems, improving
   * response quality.
   *
   * Must be ≥1024 and less than `max_tokens`.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
  budget_tokens: number;
  type: &amp;apos;enabled&amp;apos;;
}
⋮----
/**
   * Determines how many tokens Claude can use for its internal reasoning process.
   * Larger budgets can enable more thorough analysis for complex problems, improving
   * response quality.
   *
   * Must be ≥1024 and less than `max_tokens`.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
⋮----
/**
 * Configuration for enabling Claude&amp;apos;s extended thinking.
 *
 * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
 * thinking process before the final answer. Requires a minimum budget of 1,024
 * tokens and counts towards your `max_tokens` limit.
 *
 * See
 * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
 * for details.
 */
export type BetaThinkingConfigParam = BetaThinkingConfigEnabled | BetaThinkingConfigDisabled;
export interface BetaThinkingDelta {
  thinking: string;
  type: &amp;apos;thinking_delta&amp;apos;;
}
export interface BetaTool {
  /**
   * [JSON schema](https://json-schema.org/draft/2020-12) for this tool&amp;apos;s input.
   *
   * This defines the shape of the `input` that your tool accepts and that the model
   * will produce.
   */
  input_schema: BetaTool.InputSchema;
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: string;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
  /**
   * Description of what this tool does.
   *
   * Tool descriptions should be as detailed as possible. The more information that
   * the model has about what the tool is and how to use it, the better it will
   * perform. You can use natural language descriptions to reinforce important
   * aspects of the tool input JSON schema.
   */
  description?: string;
  type?: &amp;apos;custom&amp;apos; | null;
}
⋮----
/**
   * [JSON schema](https://json-schema.org/draft/2020-12) for this tool&amp;apos;s input.
   *
   * This defines the shape of the `input` that your tool accepts and that the model
   * will produce.
   */
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
   * Description of what this tool does.
   *
   * Tool descriptions should be as detailed as possible. The more information that
   * the model has about what the tool is and how to use it, the better it will
   * perform. You can use natural language descriptions to reinforce important
   * aspects of the tool input JSON schema.
   */
⋮----
/**
   * [JSON schema](https://json-schema.org/draft/2020-12) for this tool&amp;apos;s input.
   *
   * This defines the shape of the `input` that your tool accepts and that the model
   * will produce.
   */
export interface InputSchema {
    type: &amp;apos;object&amp;apos;;
    properties?: unknown | null;
    [k: string]: unknown;
  }
⋮----
export interface BetaToolBash20241022 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;bash&amp;apos;;
  type: &amp;apos;bash_20241022&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaToolBash20250124 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;bash&amp;apos;;
  type: &amp;apos;bash_20250124&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
 * How the model should use the provided tools. The model can use a specific tool,
 * any available tool, decide by itself, or not use tools at all.
 */
export type BetaToolChoice = BetaToolChoiceAuto | BetaToolChoiceAny | BetaToolChoiceTool | BetaToolChoiceNone;
/**
 * The model will use any available tools.
 */
export interface BetaToolChoiceAny {
  type: &amp;apos;any&amp;apos;;
  /**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output exactly one tool
   * use.
   */
  disable_parallel_tool_use?: boolean;
}
⋮----
/**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output exactly one tool
   * use.
   */
⋮----
/**
 * The model will automatically decide whether to use tools.
 */
export interface BetaToolChoiceAuto {
  type: &amp;apos;auto&amp;apos;;
  /**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output at most one tool
   * use.
   */
  disable_parallel_tool_use?: boolean;
}
⋮----
/**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output at most one tool
   * use.
   */
⋮----
/**
 * The model will not be allowed to use tools.
 */
export interface BetaToolChoiceNone {
  type: &amp;apos;none&amp;apos;;
}
/**
 * The model will use the specified tool with `tool_choice.name`.
 */
export interface BetaToolChoiceTool {
  /**
   * The name of the tool to use.
   */
  name: string;
  type: &amp;apos;tool&amp;apos;;
  /**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output exactly one tool
   * use.
   */
  disable_parallel_tool_use?: boolean;
}
⋮----
/**
   * The name of the tool to use.
   */
⋮----
/**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output exactly one tool
   * use.
   */
⋮----
export interface BetaToolComputerUse20241022 {
  /**
   * The height of the display in pixels.
   */
  display_height_px: number;
  /**
   * The width of the display in pixels.
   */
  display_width_px: number;
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;computer&amp;apos;;
  type: &amp;apos;computer_20241022&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
  /**
   * The X11 display number (e.g. 0, 1) for the display.
   */
  display_number?: number | null;
}
⋮----
/**
   * The height of the display in pixels.
   */
⋮----
/**
   * The width of the display in pixels.
   */
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
   * The X11 display number (e.g. 0, 1) for the display.
   */
⋮----
export interface BetaToolComputerUse20250124 {
  /**
   * The height of the display in pixels.
   */
  display_height_px: number;
  /**
   * The width of the display in pixels.
   */
  display_width_px: number;
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;computer&amp;apos;;
  type: &amp;apos;computer_20250124&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
  /**
   * The X11 display number (e.g. 0, 1) for the display.
   */
  display_number?: number | null;
}
⋮----
/**
   * The height of the display in pixels.
   */
⋮----
/**
   * The width of the display in pixels.
   */
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
   * The X11 display number (e.g. 0, 1) for the display.
   */
⋮----
export interface BetaToolResultBlockParam {
  tool_use_id: string;
  type: &amp;apos;tool_result&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
  content?: string | Array&amp;lt;BetaTextBlockParam | BetaImageBlockParam&amp;gt;;
  is_error?: boolean;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaToolTextEditor20241022 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;str_replace_editor&amp;apos;;
  type: &amp;apos;text_editor_20241022&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaToolTextEditor20250124 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;str_replace_editor&amp;apos;;
  type: &amp;apos;text_editor_20250124&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaToolTextEditor20250429 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;str_replace_based_edit_tool&amp;apos;;
  type: &amp;apos;text_editor_20250429&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export type BetaToolUnion =
  | BetaTool
  | BetaToolComputerUse20241022
  | BetaToolBash20241022
  | BetaToolTextEditor20241022
  | BetaToolComputerUse20250124
  | BetaToolBash20250124
  | BetaToolTextEditor20250124
  | BetaToolTextEditor20250429
  | BetaWebSearchTool20250305
  | BetaCodeExecutionTool20250522;
export interface BetaToolUseBlock {
  id: string;
  input: unknown;
  name: string;
  type: &amp;apos;tool_use&amp;apos;;
}
export interface BetaToolUseBlockParam {
  id: string;
  input: unknown;
  name: string;
  type: &amp;apos;tool_use&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface BetaURLImageSource {
  type: &amp;apos;url&amp;apos;;
  url: string;
}
export interface BetaURLPDFSource {
  type: &amp;apos;url&amp;apos;;
  url: string;
}
export interface BetaUsage {
  /**
   * Breakdown of cached tokens by TTL
   */
  cache_creation: BetaCacheCreation | null;
  /**
   * The number of input tokens used to create the cache entry.
   */
  cache_creation_input_tokens: number | null;
  /**
   * The number of input tokens read from the cache.
   */
  cache_read_input_tokens: number | null;
  /**
   * The number of input tokens which were used.
   */
  input_tokens: number;
  /**
   * The number of output tokens which were used.
   */
  output_tokens: number;
  /**
   * The number of server tool requests.
   */
  server_tool_use: BetaServerToolUsage | null;
  /**
   * If the request used the priority, standard, or batch tier.
   */
  service_tier: &amp;apos;standard&amp;apos; | &amp;apos;priority&amp;apos; | &amp;apos;batch&amp;apos; | null;
}
⋮----
/**
   * Breakdown of cached tokens by TTL
   */
⋮----
/**
   * The number of input tokens used to create the cache entry.
   */
⋮----
/**
   * The number of input tokens read from the cache.
   */
⋮----
/**
   * The number of input tokens which were used.
   */
⋮----
/**
   * The number of output tokens which were used.
   */
⋮----
/**
   * The number of server tool requests.
   */
⋮----
/**
   * If the request used the priority, standard, or batch tier.
   */
⋮----
export interface BetaWebSearchResultBlock {
  encrypted_content: string;
  page_age: string | null;
  title: string;
  type: &amp;apos;web_search_result&amp;apos;;
  url: string;
}
export interface BetaWebSearchResultBlockParam {
  encrypted_content: string;
  title: string;
  type: &amp;apos;web_search_result&amp;apos;;
  url: string;
  page_age?: string | null;
}
export interface BetaWebSearchTool20250305 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;web_search&amp;apos;;
  type: &amp;apos;web_search_20250305&amp;apos;;
  /**
   * If provided, only these domains will be included in results. Cannot be used
   * alongside `blocked_domains`.
   */
  allowed_domains?: Array&amp;lt;string&amp;gt; | null;
  /**
   * If provided, these domains will never appear in results. Cannot be used
   * alongside `allowed_domains`.
   */
  blocked_domains?: Array&amp;lt;string&amp;gt; | null;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
  /**
   * Maximum number of times the tool can be used in the API request.
   */
  max_uses?: number | null;
  /**
   * Parameters for the user&amp;apos;s location. Used to provide more relevant search
   * results.
   */
  user_location?: BetaWebSearchTool20250305.UserLocation | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * If provided, only these domains will be included in results. Cannot be used
   * alongside `blocked_domains`.
   */
⋮----
/**
   * If provided, these domains will never appear in results. Cannot be used
   * alongside `allowed_domains`.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
   * Maximum number of times the tool can be used in the API request.
   */
⋮----
/**
   * Parameters for the user&amp;apos;s location. Used to provide more relevant search
   * results.
   */
⋮----
/**
   * Parameters for the user&amp;apos;s location. Used to provide more relevant search
   * results.
   */
export interface UserLocation {
    type: &amp;apos;approximate&amp;apos;;
    /**
     * The city of the user.
     */
    city?: string | null;
    /**
     * The two letter
     * [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
     * user.
     */
    country?: string | null;
    /**
     * The region of the user.
     */
    region?: string | null;
    /**
     * The [IANA timezone](https://nodatime.org/TimeZones) of the user.
     */
    timezone?: string | null;
  }
⋮----
/**
     * The city of the user.
     */
⋮----
/**
     * The two letter
     * [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
     * user.
     */
⋮----
/**
     * The region of the user.
     */
⋮----
/**
     * The [IANA timezone](https://nodatime.org/TimeZones) of the user.
     */
⋮----
export interface BetaWebSearchToolRequestError {
  error_code: BetaWebSearchToolResultErrorCode;
  type: &amp;apos;web_search_tool_result_error&amp;apos;;
}
export interface BetaWebSearchToolResultBlock {
  content: BetaWebSearchToolResultBlockContent;
  tool_use_id: string;
  type: &amp;apos;web_search_tool_result&amp;apos;;
}
export type BetaWebSearchToolResultBlockContent =
  | BetaWebSearchToolResultError
  | Array&amp;lt;BetaWebSearchResultBlock&amp;gt;;
export interface BetaWebSearchToolResultBlockParam {
  content: BetaWebSearchToolResultBlockParamContent;
  tool_use_id: string;
  type: &amp;apos;web_search_tool_result&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: BetaCacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export type BetaWebSearchToolResultBlockParamContent =
  | Array&amp;lt;BetaWebSearchResultBlockParam&amp;gt;
  | BetaWebSearchToolRequestError;
export interface BetaWebSearchToolResultError {
  error_code: BetaWebSearchToolResultErrorCode;
  type: &amp;apos;web_search_tool_result_error&amp;apos;;
}
export type BetaWebSearchToolResultErrorCode =
  | &amp;apos;invalid_tool_input&amp;apos;
  | &amp;apos;unavailable&amp;apos;
  | &amp;apos;max_uses_exceeded&amp;apos;
  | &amp;apos;too_many_requests&amp;apos;
  | &amp;apos;query_too_long&amp;apos;;
export type MessageCreateParams = MessageCreateParamsNonStreaming | MessageCreateParamsStreaming;
export interface MessageCreateParamsBase {
  /**
   * Body param: The maximum number of tokens to generate before stopping.
   *
   * Note that our models may stop _before_ reaching this maximum. This parameter
   * only specifies the absolute maximum number of tokens to generate.
   *
   * Different models have different maximum values for this parameter. See
   * [models](https://docs.anthropic.com/en/docs/models-overview) for details.
   */
  max_tokens: number;
  /**
   * Body param: Input messages.
   *
   * Our models are trained to operate on alternating `user` and `assistant`
   * conversational turns. When creating a new `Message`, you specify the prior
   * conversational turns with the `messages` parameter, and the model then generates
   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns
   * in your request will be combined into a single turn.
   *
   * Each input message must be an object with a `role` and `content`. You can
   * specify a single `user`-role message, or you can include multiple `user` and
   * `assistant` messages.
   *
   * If the final message uses the `assistant` role, the response content will
   * continue immediately from the content in that message. This can be used to
   * constrain part of the model&amp;apos;s response.
   *
   * Example with a single `user` message:
   *
   * ```json
   * [{ &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }]
   * ```
   *
   * Example with multiple conversational turns:
   *
   * ```json
   * [
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello there.&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude. How can I help you?&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Can you explain LLMs in plain English?&amp;quot; }
   * ]
   * ```
   *
   * Example with a partially-filled response from Claude:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Each input message `content` may be either a single `string` or an array of
   * content blocks, where each block has a specific `type`. Using a `string` for
   * `content` is shorthand for an array of one content block of type `&amp;quot;text&amp;quot;`. The
   * following input messages are equivalent:
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }
   * ```
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }] }
   * ```
   *
   * Starting with Claude 3 models, you can also send image content blocks:
   *
   * ```json
   * {
   *   &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *   &amp;quot;content&amp;quot;: [
   *     {
   *       &amp;quot;type&amp;quot;: &amp;quot;image&amp;quot;,
   *       &amp;quot;source&amp;quot;: {
   *         &amp;quot;type&amp;quot;: &amp;quot;base64&amp;quot;,
   *         &amp;quot;media_type&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
   *         &amp;quot;data&amp;quot;: &amp;quot;/9j/4AAQSkZJRg...&amp;quot;
   *       }
   *     },
   *     { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;What is in this image?&amp;quot; }
   *   ]
   * }
   * ```
   *
   * We currently support the `base64` source type for images, and the `image/jpeg`,
   * `image/png`, `image/gif`, and `image/webp` media types.
   *
   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
   * more input examples.
   *
   * Note that if you want to include a
   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
   * the top-level `system` parameter — there is no `&amp;quot;system&amp;quot;` role for input
   * messages in the Messages API.
   *
   * There is a limit of 100000 messages in a single request.
   */
  messages: Array&amp;lt;BetaMessageParam&amp;gt;;
  /**
   * Body param: The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
  model: MessagesAPI.Model;
  /**
   * Body param: Container identifier for reuse across requests.
   */
  container?: string | null;
  /**
   * Body param: MCP servers to be utilized in this request
   */
  mcp_servers?: Array&amp;lt;BetaRequestMCPServerURLDefinition&amp;gt;;
  /**
   * Body param: An object describing metadata about the request.
   */
  metadata?: BetaMetadata;
  /**
   * Body param: Determines whether to use priority capacity (if available) or
   * standard capacity for this request.
   *
   * Anthropic offers different levels of service for your API requests. See
   * [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
   */
  service_tier?: &amp;apos;auto&amp;apos; | &amp;apos;standard_only&amp;apos;;
  /**
   * Body param: Custom text sequences that will cause the model to stop generating.
   *
   * Our models will normally stop when they have naturally completed their turn,
   * which will result in a response `stop_reason` of `&amp;quot;end_turn&amp;quot;`.
   *
   * If you want the model to stop generating when it encounters custom strings of
   * text, you can use the `stop_sequences` parameter. If the model encounters one of
   * the custom sequences, the response `stop_reason` value will be `&amp;quot;stop_sequence&amp;quot;`
   * and the response `stop_sequence` value will contain the matched stop sequence.
   */
  stop_sequences?: Array&amp;lt;string&amp;gt;;
  /**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
  stream?: boolean;
  /**
   * Body param: System prompt.
   *
   * A system prompt is a way of providing context and instructions to Claude, such
   * as specifying a particular goal or role. See our
   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
   */
  system?: string | Array&amp;lt;BetaTextBlockParam&amp;gt;;
  /**
   * Body param: Amount of randomness injected into the response.
   *
   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
   * for analytical / multiple choice, and closer to `1.0` for creative and
   * generative tasks.
   *
   * Note that even with `temperature` of `0.0`, the results will not be fully
   * deterministic.
   */
  temperature?: number;
  /**
   * Body param: Configuration for enabling Claude&amp;apos;s extended thinking.
   *
   * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
   * thinking process before the final answer. Requires a minimum budget of 1,024
   * tokens and counts towards your `max_tokens` limit.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
  thinking?: BetaThinkingConfigParam;
  /**
   * Body param: How the model should use the provided tools. The model can use a
   * specific tool, any available tool, decide by itself, or not use tools at all.
   */
  tool_choice?: BetaToolChoice;
  /**
   * Body param: Definitions of tools that the model may use.
   *
   * If you include `tools` in your API request, the model may return `tool_use`
   * content blocks that represent the model&amp;apos;s use of those tools. You can then run
   * those tools using the tool input generated by the model and then optionally
   * return results back to the model using `tool_result` content blocks.
   *
   * Each tool definition includes:
   *
   * - `name`: Name of the tool.
   * - `description`: Optional, but strongly-recommended description of the tool.
   * - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
   *   tool `input` shape that the model will produce in `tool_use` output content
   *   blocks.
   *
   * For example, if you defined `tools` as:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;description&amp;quot;: &amp;quot;Get the current stock price for a given ticker symbol.&amp;quot;,
   *     &amp;quot;input_schema&amp;quot;: {
   *       &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
   *       &amp;quot;properties&amp;quot;: {
   *         &amp;quot;ticker&amp;quot;: {
   *           &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
   *           &amp;quot;description&amp;quot;: &amp;quot;The stock ticker symbol, e.g. AAPL for Apple Inc.&amp;quot;
   *         }
   *       },
   *       &amp;quot;required&amp;quot;: [&amp;quot;ticker&amp;quot;]
   *     }
   *   }
   * ]
   * ```
   *
   * And then asked the model &amp;quot;What&amp;apos;s the S&amp;amp;P 500 at today?&amp;quot;, the model might produce
   * `tool_use` content blocks in the response like this:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_use&amp;quot;,
   *     &amp;quot;id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;input&amp;quot;: { &amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot; }
   *   }
   * ]
   * ```
   *
   * You might then run your `get_stock_price` tool with `{&amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot;}` as an
   * input, and return the following back to the model in a subsequent `user`
   * message:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_result&amp;quot;,
   *     &amp;quot;tool_use_id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;259.75 USD&amp;quot;
   *   }
   * ]
   * ```
   *
   * Tools can be used for workflows that include running client-side tools and
   * functions, or more generally whenever you want the model to produce a particular
   * JSON structure of output.
   *
   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
   */
  tools?: Array&amp;lt;BetaToolUnion&amp;gt;;
  /**
   * Body param: Only sample from the top K options for each subsequent token.
   *
   * Used to remove &amp;quot;long tail&amp;quot; low probability responses.
   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
  top_k?: number;
  /**
   * Body param: Use nucleus sampling.
   *
   * In nucleus sampling, we compute the cumulative distribution over all the options
   * for each subsequent token in decreasing probability order and cut it off once it
   * reaches a particular probability specified by `top_p`. You should either alter
   * `temperature` or `top_p`, but not both.
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
  top_p?: number;
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Body param: The maximum number of tokens to generate before stopping.
   *
   * Note that our models may stop _before_ reaching this maximum. This parameter
   * only specifies the absolute maximum number of tokens to generate.
   *
   * Different models have different maximum values for this parameter. See
   * [models](https://docs.anthropic.com/en/docs/models-overview) for details.
   */
⋮----
/**
   * Body param: Input messages.
   *
   * Our models are trained to operate on alternating `user` and `assistant`
   * conversational turns. When creating a new `Message`, you specify the prior
   * conversational turns with the `messages` parameter, and the model then generates
   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns
   * in your request will be combined into a single turn.
   *
   * Each input message must be an object with a `role` and `content`. You can
   * specify a single `user`-role message, or you can include multiple `user` and
   * `assistant` messages.
   *
   * If the final message uses the `assistant` role, the response content will
   * continue immediately from the content in that message. This can be used to
   * constrain part of the model&amp;apos;s response.
   *
   * Example with a single `user` message:
   *
   * ```json
   * [{ &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }]
   * ```
   *
   * Example with multiple conversational turns:
   *
   * ```json
   * [
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello there.&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude. How can I help you?&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Can you explain LLMs in plain English?&amp;quot; }
   * ]
   * ```
   *
   * Example with a partially-filled response from Claude:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Each input message `content` may be either a single `string` or an array of
   * content blocks, where each block has a specific `type`. Using a `string` for
   * `content` is shorthand for an array of one content block of type `&amp;quot;text&amp;quot;`. The
   * following input messages are equivalent:
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }
   * ```
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }] }
   * ```
   *
   * Starting with Claude 3 models, you can also send image content blocks:
   *
   * ```json
   * {
   *   &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *   &amp;quot;content&amp;quot;: [
   *     {
   *       &amp;quot;type&amp;quot;: &amp;quot;image&amp;quot;,
   *       &amp;quot;source&amp;quot;: {
   *         &amp;quot;type&amp;quot;: &amp;quot;base64&amp;quot;,
   *         &amp;quot;media_type&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
   *         &amp;quot;data&amp;quot;: &amp;quot;/9j/4AAQSkZJRg...&amp;quot;
   *       }
   *     },
   *     { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;What is in this image?&amp;quot; }
   *   ]
   * }
   * ```
   *
   * We currently support the `base64` source type for images, and the `image/jpeg`,
   * `image/png`, `image/gif`, and `image/webp` media types.
   *
   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
   * more input examples.
   *
   * Note that if you want to include a
   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
   * the top-level `system` parameter — there is no `&amp;quot;system&amp;quot;` role for input
   * messages in the Messages API.
   *
   * There is a limit of 100000 messages in a single request.
   */
⋮----
/**
   * Body param: The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
⋮----
/**
   * Body param: Container identifier for reuse across requests.
   */
⋮----
/**
   * Body param: MCP servers to be utilized in this request
   */
⋮----
/**
   * Body param: An object describing metadata about the request.
   */
⋮----
/**
   * Body param: Determines whether to use priority capacity (if available) or
   * standard capacity for this request.
   *
   * Anthropic offers different levels of service for your API requests. See
   * [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
   */
⋮----
/**
   * Body param: Custom text sequences that will cause the model to stop generating.
   *
   * Our models will normally stop when they have naturally completed their turn,
   * which will result in a response `stop_reason` of `&amp;quot;end_turn&amp;quot;`.
   *
   * If you want the model to stop generating when it encounters custom strings of
   * text, you can use the `stop_sequences` parameter. If the model encounters one of
   * the custom sequences, the response `stop_reason` value will be `&amp;quot;stop_sequence&amp;quot;`
   * and the response `stop_sequence` value will contain the matched stop sequence.
   */
⋮----
/**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
⋮----
/**
   * Body param: System prompt.
   *
   * A system prompt is a way of providing context and instructions to Claude, such
   * as specifying a particular goal or role. See our
   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
   */
⋮----
/**
   * Body param: Amount of randomness injected into the response.
   *
   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
   * for analytical / multiple choice, and closer to `1.0` for creative and
   * generative tasks.
   *
   * Note that even with `temperature` of `0.0`, the results will not be fully
   * deterministic.
   */
⋮----
/**
   * Body param: Configuration for enabling Claude&amp;apos;s extended thinking.
   *
   * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
   * thinking process before the final answer. Requires a minimum budget of 1,024
   * tokens and counts towards your `max_tokens` limit.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
⋮----
/**
   * Body param: How the model should use the provided tools. The model can use a
   * specific tool, any available tool, decide by itself, or not use tools at all.
   */
⋮----
/**
   * Body param: Definitions of tools that the model may use.
   *
   * If you include `tools` in your API request, the model may return `tool_use`
   * content blocks that represent the model&amp;apos;s use of those tools. You can then run
   * those tools using the tool input generated by the model and then optionally
   * return results back to the model using `tool_result` content blocks.
   *
   * Each tool definition includes:
   *
   * - `name`: Name of the tool.
   * - `description`: Optional, but strongly-recommended description of the tool.
   * - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
   *   tool `input` shape that the model will produce in `tool_use` output content
   *   blocks.
   *
   * For example, if you defined `tools` as:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;description&amp;quot;: &amp;quot;Get the current stock price for a given ticker symbol.&amp;quot;,
   *     &amp;quot;input_schema&amp;quot;: {
   *       &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
   *       &amp;quot;properties&amp;quot;: {
   *         &amp;quot;ticker&amp;quot;: {
   *           &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
   *           &amp;quot;description&amp;quot;: &amp;quot;The stock ticker symbol, e.g. AAPL for Apple Inc.&amp;quot;
   *         }
   *       },
   *       &amp;quot;required&amp;quot;: [&amp;quot;ticker&amp;quot;]
   *     }
   *   }
   * ]
   * ```
   *
   * And then asked the model &amp;quot;What&amp;apos;s the S&amp;amp;P 500 at today?&amp;quot;, the model might produce
   * `tool_use` content blocks in the response like this:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_use&amp;quot;,
   *     &amp;quot;id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;input&amp;quot;: { &amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot; }
   *   }
   * ]
   * ```
   *
   * You might then run your `get_stock_price` tool with `{&amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot;}` as an
   * input, and return the following back to the model in a subsequent `user`
   * message:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_result&amp;quot;,
   *     &amp;quot;tool_use_id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;259.75 USD&amp;quot;
   *   }
   * ]
   * ```
   *
   * Tools can be used for workflows that include running client-side tools and
   * functions, or more generally whenever you want the model to produce a particular
   * JSON structure of output.
   *
   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
   */
⋮----
/**
   * Body param: Only sample from the top K options for each subsequent token.
   *
   * Used to remove &amp;quot;long tail&amp;quot; low probability responses.
   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
⋮----
/**
   * Body param: Use nucleus sampling.
   *
   * In nucleus sampling, we compute the cumulative distribution over all the options
   * for each subsequent token in decreasing probability order and cut it off once it
   * reaches a particular probability specified by `top_p`. You should either alter
   * `temperature` or `top_p`, but not both.
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
⋮----
export type MessageCreateParamsNonStreaming = MessagesMessagesAPI.MessageCreateParamsNonStreaming;
export type MessageCreateParamsStreaming = MessagesMessagesAPI.MessageCreateParamsStreaming;
⋮----
export interface MessageCreateParamsNonStreaming extends MessageCreateParamsBase {
  /**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
  stream?: false;
}
⋮----
/**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
⋮----
export interface MessageCreateParamsStreaming extends MessageCreateParamsBase {
  /**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
  stream: true;
}
⋮----
/**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
⋮----
export interface MessageCountTokensParams {
  /**
   * Body param: Input messages.
   *
   * Our models are trained to operate on alternating `user` and `assistant`
   * conversational turns. When creating a new `Message`, you specify the prior
   * conversational turns with the `messages` parameter, and the model then generates
   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns
   * in your request will be combined into a single turn.
   *
   * Each input message must be an object with a `role` and `content`. You can
   * specify a single `user`-role message, or you can include multiple `user` and
   * `assistant` messages.
   *
   * If the final message uses the `assistant` role, the response content will
   * continue immediately from the content in that message. This can be used to
   * constrain part of the model&amp;apos;s response.
   *
   * Example with a single `user` message:
   *
   * ```json
   * [{ &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }]
   * ```
   *
   * Example with multiple conversational turns:
   *
   * ```json
   * [
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello there.&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude. How can I help you?&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Can you explain LLMs in plain English?&amp;quot; }
   * ]
   * ```
   *
   * Example with a partially-filled response from Claude:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Each input message `content` may be either a single `string` or an array of
   * content blocks, where each block has a specific `type`. Using a `string` for
   * `content` is shorthand for an array of one content block of type `&amp;quot;text&amp;quot;`. The
   * following input messages are equivalent:
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }
   * ```
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }] }
   * ```
   *
   * Starting with Claude 3 models, you can also send image content blocks:
   *
   * ```json
   * {
   *   &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *   &amp;quot;content&amp;quot;: [
   *     {
   *       &amp;quot;type&amp;quot;: &amp;quot;image&amp;quot;,
   *       &amp;quot;source&amp;quot;: {
   *         &amp;quot;type&amp;quot;: &amp;quot;base64&amp;quot;,
   *         &amp;quot;media_type&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
   *         &amp;quot;data&amp;quot;: &amp;quot;/9j/4AAQSkZJRg...&amp;quot;
   *       }
   *     },
   *     { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;What is in this image?&amp;quot; }
   *   ]
   * }
   * ```
   *
   * We currently support the `base64` source type for images, and the `image/jpeg`,
   * `image/png`, `image/gif`, and `image/webp` media types.
   *
   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
   * more input examples.
   *
   * Note that if you want to include a
   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
   * the top-level `system` parameter — there is no `&amp;quot;system&amp;quot;` role for input
   * messages in the Messages API.
   *
   * There is a limit of 100000 messages in a single request.
   */
  messages: Array&amp;lt;BetaMessageParam&amp;gt;;
  /**
   * Body param: The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
  model: MessagesAPI.Model;
  /**
   * Body param: MCP servers to be utilized in this request
   */
  mcp_servers?: Array&amp;lt;BetaRequestMCPServerURLDefinition&amp;gt;;
  /**
   * Body param: System prompt.
   *
   * A system prompt is a way of providing context and instructions to Claude, such
   * as specifying a particular goal or role. See our
   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
   */
  system?: string | Array&amp;lt;BetaTextBlockParam&amp;gt;;
  /**
   * Body param: Configuration for enabling Claude&amp;apos;s extended thinking.
   *
   * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
   * thinking process before the final answer. Requires a minimum budget of 1,024
   * tokens and counts towards your `max_tokens` limit.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
  thinking?: BetaThinkingConfigParam;
  /**
   * Body param: How the model should use the provided tools. The model can use a
   * specific tool, any available tool, decide by itself, or not use tools at all.
   */
  tool_choice?: BetaToolChoice;
  /**
   * Body param: Definitions of tools that the model may use.
   *
   * If you include `tools` in your API request, the model may return `tool_use`
   * content blocks that represent the model&amp;apos;s use of those tools. You can then run
   * those tools using the tool input generated by the model and then optionally
   * return results back to the model using `tool_result` content blocks.
   *
   * Each tool definition includes:
   *
   * - `name`: Name of the tool.
   * - `description`: Optional, but strongly-recommended description of the tool.
   * - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
   *   tool `input` shape that the model will produce in `tool_use` output content
   *   blocks.
   *
   * For example, if you defined `tools` as:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;description&amp;quot;: &amp;quot;Get the current stock price for a given ticker symbol.&amp;quot;,
   *     &amp;quot;input_schema&amp;quot;: {
   *       &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
   *       &amp;quot;properties&amp;quot;: {
   *         &amp;quot;ticker&amp;quot;: {
   *           &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
   *           &amp;quot;description&amp;quot;: &amp;quot;The stock ticker symbol, e.g. AAPL for Apple Inc.&amp;quot;
   *         }
   *       },
   *       &amp;quot;required&amp;quot;: [&amp;quot;ticker&amp;quot;]
   *     }
   *   }
   * ]
   * ```
   *
   * And then asked the model &amp;quot;What&amp;apos;s the S&amp;amp;P 500 at today?&amp;quot;, the model might produce
   * `tool_use` content blocks in the response like this:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_use&amp;quot;,
   *     &amp;quot;id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;input&amp;quot;: { &amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot; }
   *   }
   * ]
   * ```
   *
   * You might then run your `get_stock_price` tool with `{&amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot;}` as an
   * input, and return the following back to the model in a subsequent `user`
   * message:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_result&amp;quot;,
   *     &amp;quot;tool_use_id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;259.75 USD&amp;quot;
   *   }
   * ]
   * ```
   *
   * Tools can be used for workflows that include running client-side tools and
   * functions, or more generally whenever you want the model to produce a particular
   * JSON structure of output.
   *
   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
   */
  tools?: Array&amp;lt;
    | BetaTool
    | BetaToolComputerUse20241022
    | BetaToolBash20241022
    | BetaToolTextEditor20241022
    | BetaToolComputerUse20250124
    | BetaToolBash20250124
    | BetaToolTextEditor20250124
    | BetaToolTextEditor20250429
    | BetaWebSearchTool20250305
    | BetaCodeExecutionTool20250522
  &amp;gt;;
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Body param: Input messages.
   *
   * Our models are trained to operate on alternating `user` and `assistant`
   * conversational turns. When creating a new `Message`, you specify the prior
   * conversational turns with the `messages` parameter, and the model then generates
   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns
   * in your request will be combined into a single turn.
   *
   * Each input message must be an object with a `role` and `content`. You can
   * specify a single `user`-role message, or you can include multiple `user` and
   * `assistant` messages.
   *
   * If the final message uses the `assistant` role, the response content will
   * continue immediately from the content in that message. This can be used to
   * constrain part of the model&amp;apos;s response.
   *
   * Example with a single `user` message:
   *
   * ```json
   * [{ &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }]
   * ```
   *
   * Example with multiple conversational turns:
   *
   * ```json
   * [
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello there.&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude. How can I help you?&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Can you explain LLMs in plain English?&amp;quot; }
   * ]
   * ```
   *
   * Example with a partially-filled response from Claude:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Each input message `content` may be either a single `string` or an array of
   * content blocks, where each block has a specific `type`. Using a `string` for
   * `content` is shorthand for an array of one content block of type `&amp;quot;text&amp;quot;`. The
   * following input messages are equivalent:
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }
   * ```
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }] }
   * ```
   *
   * Starting with Claude 3 models, you can also send image content blocks:
   *
   * ```json
   * {
   *   &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *   &amp;quot;content&amp;quot;: [
   *     {
   *       &amp;quot;type&amp;quot;: &amp;quot;image&amp;quot;,
   *       &amp;quot;source&amp;quot;: {
   *         &amp;quot;type&amp;quot;: &amp;quot;base64&amp;quot;,
   *         &amp;quot;media_type&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
   *         &amp;quot;data&amp;quot;: &amp;quot;/9j/4AAQSkZJRg...&amp;quot;
   *       }
   *     },
   *     { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;What is in this image?&amp;quot; }
   *   ]
   * }
   * ```
   *
   * We currently support the `base64` source type for images, and the `image/jpeg`,
   * `image/png`, `image/gif`, and `image/webp` media types.
   *
   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
   * more input examples.
   *
   * Note that if you want to include a
   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
   * the top-level `system` parameter — there is no `&amp;quot;system&amp;quot;` role for input
   * messages in the Messages API.
   *
   * There is a limit of 100000 messages in a single request.
   */
⋮----
/**
   * Body param: The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
⋮----
/**
   * Body param: MCP servers to be utilized in this request
   */
⋮----
/**
   * Body param: System prompt.
   *
   * A system prompt is a way of providing context and instructions to Claude, such
   * as specifying a particular goal or role. See our
   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
   */
⋮----
/**
   * Body param: Configuration for enabling Claude&amp;apos;s extended thinking.
   *
   * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
   * thinking process before the final answer. Requires a minimum budget of 1,024
   * tokens and counts towards your `max_tokens` limit.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
⋮----
/**
   * Body param: How the model should use the provided tools. The model can use a
   * specific tool, any available tool, decide by itself, or not use tools at all.
   */
⋮----
/**
   * Body param: Definitions of tools that the model may use.
   *
   * If you include `tools` in your API request, the model may return `tool_use`
   * content blocks that represent the model&amp;apos;s use of those tools. You can then run
   * those tools using the tool input generated by the model and then optionally
   * return results back to the model using `tool_result` content blocks.
   *
   * Each tool definition includes:
   *
   * - `name`: Name of the tool.
   * - `description`: Optional, but strongly-recommended description of the tool.
   * - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
   *   tool `input` shape that the model will produce in `tool_use` output content
   *   blocks.
   *
   * For example, if you defined `tools` as:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;description&amp;quot;: &amp;quot;Get the current stock price for a given ticker symbol.&amp;quot;,
   *     &amp;quot;input_schema&amp;quot;: {
   *       &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
   *       &amp;quot;properties&amp;quot;: {
   *         &amp;quot;ticker&amp;quot;: {
   *           &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
   *           &amp;quot;description&amp;quot;: &amp;quot;The stock ticker symbol, e.g. AAPL for Apple Inc.&amp;quot;
   *         }
   *       },
   *       &amp;quot;required&amp;quot;: [&amp;quot;ticker&amp;quot;]
   *     }
   *   }
   * ]
   * ```
   *
   * And then asked the model &amp;quot;What&amp;apos;s the S&amp;amp;P 500 at today?&amp;quot;, the model might produce
   * `tool_use` content blocks in the response like this:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_use&amp;quot;,
   *     &amp;quot;id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;input&amp;quot;: { &amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot; }
   *   }
   * ]
   * ```
   *
   * You might then run your `get_stock_price` tool with `{&amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot;}` as an
   * input, and return the following back to the model in a subsequent `user`
   * message:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_result&amp;quot;,
   *     &amp;quot;tool_use_id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;259.75 USD&amp;quot;
   *   }
   * ]
   * ```
   *
   * Tools can be used for workflows that include running client-side tools and
   * functions, or more generally whenever you want the model to produce a particular
   * JSON structure of output.
   *
   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
   */
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */&lt;/file&gt;&lt;file path=&quot;src/resources/beta/beta.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from &amp;apos;../../core/resource&amp;apos;;
⋮----
import {
  DeletedFile,
  FileDeleteParams,
  FileDownloadParams,
  FileListParams,
  FileMetadata,
  FileMetadataPage,
  FileRetrieveMetadataParams,
  FileUploadParams,
  Files,
} from &amp;apos;./files&amp;apos;;
⋮----
import { BetaModelInfo, BetaModelInfosPage, ModelListParams, ModelRetrieveParams, Models } from &amp;apos;./models&amp;apos;;
⋮----
import {
  BetaBase64ImageSource,
  BetaBase64PDFBlock,
  BetaBase64PDFSource,
  BetaCacheControlEphemeral,
  BetaCacheCreation,
  BetaCitationCharLocation,
  BetaCitationCharLocationParam,
  BetaCitationContentBlockLocation,
  BetaCitationContentBlockLocationParam,
  BetaCitationPageLocation,
  BetaCitationPageLocationParam,
  BetaCitationWebSearchResultLocationParam,
  BetaCitationsConfigParam,
  BetaCitationsDelta,
  BetaCitationsWebSearchResultLocation,
  BetaCodeExecutionOutputBlock,
  BetaCodeExecutionOutputBlockParam,
  BetaCodeExecutionResultBlock,
  BetaCodeExecutionResultBlockParam,
  BetaCodeExecutionTool20250522,
  BetaCodeExecutionToolResultBlock,
  BetaCodeExecutionToolResultBlockContent,
  BetaCodeExecutionToolResultBlockParam,
  BetaCodeExecutionToolResultBlockParamContent,
  BetaCodeExecutionToolResultError,
  BetaCodeExecutionToolResultErrorCode,
  BetaCodeExecutionToolResultErrorParam,
  BetaContainer,
  BetaContainerUploadBlock,
  BetaContainerUploadBlockParam,
  BetaContentBlock,
  BetaContentBlockParam,
  BetaContentBlockSource,
  BetaContentBlockSourceContent,
  BetaFileDocumentSource,
  BetaFileImageSource,
  BetaImageBlockParam,
  BetaInputJSONDelta,
  BetaMCPToolResultBlock,
  BetaMCPToolUseBlock,
  BetaMCPToolUseBlockParam,
  BetaMessage,
  BetaMessageDeltaUsage,
  BetaMessageParam,
  BetaMessageTokensCount,
  BetaMetadata,
  BetaPlainTextSource,
  BetaRawContentBlockDelta,
  BetaRawContentBlockDeltaEvent,
  BetaRawContentBlockStartEvent,
  BetaRawContentBlockStopEvent,
  BetaRawMessageDeltaEvent,
  BetaRawMessageStartEvent,
  BetaRawMessageStopEvent,
  BetaRawMessageStreamEvent,
  BetaRedactedThinkingBlock,
  BetaRedactedThinkingBlockParam,
  BetaRequestMCPServerToolConfiguration,
  BetaRequestMCPServerURLDefinition,
  BetaRequestMCPToolResultBlockParam,
  BetaServerToolUsage,
  BetaServerToolUseBlock,
  BetaServerToolUseBlockParam,
  BetaSignatureDelta,
  BetaStopReason,
  BetaTextBlock,
  BetaTextBlockParam,
  BetaTextCitation,
  BetaTextCitationParam,
  BetaTextDelta,
  BetaThinkingBlock,
  BetaThinkingBlockParam,
  BetaThinkingConfigDisabled,
  BetaThinkingConfigEnabled,
  BetaThinkingConfigParam,
  BetaThinkingDelta,
  BetaTool,
  BetaToolBash20241022,
  BetaToolBash20250124,
  BetaToolChoice,
  BetaToolChoiceAny,
  BetaToolChoiceAuto,
  BetaToolChoiceNone,
  BetaToolChoiceTool,
  BetaToolComputerUse20241022,
  BetaToolComputerUse20250124,
  BetaToolResultBlockParam,
  BetaToolTextEditor20241022,
  BetaToolTextEditor20250124,
  BetaToolTextEditor20250429,
  BetaToolUnion,
  BetaToolUseBlock,
  BetaToolUseBlockParam,
  BetaURLImageSource,
  BetaURLPDFSource,
  BetaUsage,
  BetaWebSearchResultBlock,
  BetaWebSearchResultBlockParam,
  BetaWebSearchTool20250305,
  BetaWebSearchToolRequestError,
  BetaWebSearchToolResultBlock,
  BetaWebSearchToolResultBlockContent,
  BetaWebSearchToolResultBlockParam,
  BetaWebSearchToolResultBlockParamContent,
  BetaWebSearchToolResultError,
  BetaWebSearchToolResultErrorCode,
  MessageCountTokensParams,
  MessageCreateParams,
  MessageCreateParamsNonStreaming,
  MessageCreateParamsStreaming,
  Messages,
} from &amp;apos;./messages/messages&amp;apos;;
export class Beta extends APIResource
export type AnthropicBeta =
  | (string &amp;amp; {})
  | &amp;apos;message-batches-2024-09-24&amp;apos;
  | &amp;apos;prompt-caching-2024-07-31&amp;apos;
  | &amp;apos;computer-use-2024-10-22&amp;apos;
  | &amp;apos;computer-use-2025-01-24&amp;apos;
  | &amp;apos;pdfs-2024-09-25&amp;apos;
  | &amp;apos;token-counting-2024-11-01&amp;apos;
  | &amp;apos;token-efficient-tools-2025-02-19&amp;apos;
  | &amp;apos;output-128k-2025-02-19&amp;apos;
  | &amp;apos;files-api-2025-04-14&amp;apos;
  | &amp;apos;mcp-client-2025-04-04&amp;apos;
  | &amp;apos;dev-full-thinking-2025-05-14&amp;apos;
  | &amp;apos;interleaved-thinking-2025-05-14&amp;apos;
  | &amp;apos;code-execution-2025-05-22&amp;apos;
  | &amp;apos;extended-cache-ttl-2025-04-11&amp;apos;;
export interface BetaAPIError {
  message: string;
  type: &amp;apos;api_error&amp;apos;;
}
export interface BetaAuthenticationError {
  message: string;
  type: &amp;apos;authentication_error&amp;apos;;
}
export interface BetaBillingError {
  message: string;
  type: &amp;apos;billing_error&amp;apos;;
}
export type BetaError =
  | BetaInvalidRequestError
  | BetaAuthenticationError
  | BetaBillingError
  | BetaPermissionError
  | BetaNotFoundError
  | BetaRateLimitError
  | BetaGatewayTimeoutError
  | BetaAPIError
  | BetaOverloadedError;
export interface BetaErrorResponse {
  error: BetaError;
  type: &amp;apos;error&amp;apos;;
}
export interface BetaGatewayTimeoutError {
  message: string;
  type: &amp;apos;timeout_error&amp;apos;;
}
export interface BetaInvalidRequestError {
  message: string;
  type: &amp;apos;invalid_request_error&amp;apos;;
}
export interface BetaNotFoundError {
  message: string;
  type: &amp;apos;not_found_error&amp;apos;;
}
export interface BetaOverloadedError {
  message: string;
  type: &amp;apos;overloaded_error&amp;apos;;
}
export interface BetaPermissionError {
  message: string;
  type: &amp;apos;permission_error&amp;apos;;
}
export interface BetaRateLimitError {
  message: string;
  type: &amp;apos;rate_limit_error&amp;apos;;
}&lt;/file&gt;&lt;file path=&quot;src/resources/beta/files.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from &amp;apos;../../core/resource&amp;apos;;
⋮----
import { APIPromise } from &amp;apos;../../core/api-promise&amp;apos;;
import { Page, type PageParams, PagePromise } from &amp;apos;../../core/pagination&amp;apos;;
import { type Uploadable } from &amp;apos;../../core/uploads&amp;apos;;
import { buildHeaders } from &amp;apos;../../internal/headers&amp;apos;;
import { RequestOptions } from &amp;apos;../../internal/request-options&amp;apos;;
import { multipartFormRequestOptions } from &amp;apos;../../internal/uploads&amp;apos;;
import { path } from &amp;apos;../../internal/utils/path&amp;apos;;
export class Files extends APIResource
⋮----
/**
   * List Files
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fileMetadata of client.beta.files.list()) {
   *   // ...
   * }
   * ```
   */
list(
    params: FileListParams | null | undefined = {},
    options?: RequestOptions,
): PagePromise&amp;lt;FileMetadataPage, FileMetadata&amp;gt;
/**
   * Delete File
   *
   * @example
   * ```ts
   * const deletedFile = await client.beta.files.delete(
   *   &amp;apos;file_id&amp;apos;,
   * );
   * ```
   */
delete(
    fileID: string,
    params: FileDeleteParams | null | undefined = {},
    options?: RequestOptions,
): APIPromise&amp;lt;DeletedFile&amp;gt;
/**
   * Download File
   *
   * @example
   * ```ts
   * const response = await client.beta.files.download(
   *   &amp;apos;file_id&amp;apos;,
   * );
   *
   * const content = await response.blob();
   * console.log(content);
   * ```
   */
download(
    fileID: string,
    params: FileDownloadParams | null | undefined = {},
    options?: RequestOptions,
): APIPromise&amp;lt;Response&amp;gt;
/**
   * Get File Metadata
   *
   * @example
   * ```ts
   * const fileMetadata =
   *   await client.beta.files.retrieveMetadata(&amp;apos;file_id&amp;apos;);
   * ```
   */
retrieveMetadata(
    fileID: string,
    params: FileRetrieveMetadataParams | null | undefined = {},
    options?: RequestOptions,
): APIPromise&amp;lt;FileMetadata&amp;gt;
/**
   * Upload File
   *
   * @example
   * ```ts
   * const fileMetadata = await client.beta.files.upload({
   *   file: fs.createReadStream(&amp;apos;path/to/file&amp;apos;),
   * });
   * ```
   */
upload(params: FileUploadParams, options?: RequestOptions): APIPromise&amp;lt;FileMetadata&amp;gt;
⋮----
export type FileMetadataPage = Page&amp;lt;FileMetadata&amp;gt;;
export interface DeletedFile {
  /**
   * ID of the deleted file.
   */
  id: string;
  /**
   * Deleted object type.
   *
   * For file deletion, this is always `&amp;quot;file_deleted&amp;quot;`.
   */
  type?: &amp;apos;file_deleted&amp;apos;;
}
⋮----
/**
   * ID of the deleted file.
   */
⋮----
/**
   * Deleted object type.
   *
   * For file deletion, this is always `&amp;quot;file_deleted&amp;quot;`.
   */
⋮----
export interface FileMetadata {
  /**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
  id: string;
  /**
   * RFC 3339 datetime string representing when the file was created.
   */
  created_at: string;
  /**
   * Original filename of the uploaded file.
   */
  filename: string;
  /**
   * MIME type of the file.
   */
  mime_type: string;
  /**
   * Size of the file in bytes.
   */
  size_bytes: number;
  /**
   * Object type.
   *
   * For files, this is always `&amp;quot;file&amp;quot;`.
   */
  type: &amp;apos;file&amp;apos;;
  /**
   * Whether the file can be downloaded.
   */
  downloadable?: boolean;
}
⋮----
/**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
⋮----
/**
   * RFC 3339 datetime string representing when the file was created.
   */
⋮----
/**
   * Original filename of the uploaded file.
   */
⋮----
/**
   * MIME type of the file.
   */
⋮----
/**
   * Size of the file in bytes.
   */
⋮----
/**
   * Object type.
   *
   * For files, this is always `&amp;quot;file&amp;quot;`.
   */
⋮----
/**
   * Whether the file can be downloaded.
   */
⋮----
export interface FileListParams extends PageParams {
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface FileDeleteParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface FileDownloadParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface FileRetrieveMetadataParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface FileUploadParams {
  /**
   * Body param: The file to upload
   */
  file: Uploadable;
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Body param: The file to upload
   */
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */&lt;/file&gt;&lt;file path=&quot;src/resources/beta/index.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/resources/beta/messages.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/resources/beta/models.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from &amp;apos;../../core/resource&amp;apos;;
⋮----
import { APIPromise } from &amp;apos;../../core/api-promise&amp;apos;;
import { Page, type PageParams, PagePromise } from &amp;apos;../../core/pagination&amp;apos;;
import { buildHeaders } from &amp;apos;../../internal/headers&amp;apos;;
import { RequestOptions } from &amp;apos;../../internal/request-options&amp;apos;;
import { path } from &amp;apos;../../internal/utils/path&amp;apos;;
export class Models extends APIResource
⋮----
/**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   *
   * @example
   * ```ts
   * const betaModelInfo = await client.beta.models.retrieve(
   *   &amp;apos;model_id&amp;apos;,
   * );
   * ```
   */
retrieve(
    modelID: string,
    params: ModelRetrieveParams | null | undefined = {},
    options?: RequestOptions,
): APIPromise&amp;lt;BetaModelInfo&amp;gt;
/**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaModelInfo of client.beta.models.list()) {
   *   // ...
   * }
   * ```
   */
list(
    params: ModelListParams | null | undefined = {},
    options?: RequestOptions,
): PagePromise&amp;lt;BetaModelInfosPage, BetaModelInfo&amp;gt;
⋮----
export type BetaModelInfosPage = Page&amp;lt;BetaModelInfo&amp;gt;;
export interface BetaModelInfo {
  /**
   * Unique model identifier.
   */
  id: string;
  /**
   * RFC 3339 datetime string representing the time at which the model was released.
   * May be set to an epoch value if the release date is unknown.
   */
  created_at: string;
  /**
   * A human-readable name for the model.
   */
  display_name: string;
  /**
   * Object type.
   *
   * For Models, this is always `&amp;quot;model&amp;quot;`.
   */
  type: &amp;apos;model&amp;apos;;
}
⋮----
/**
   * Unique model identifier.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which the model was released.
   * May be set to an epoch value if the release date is unknown.
   */
⋮----
/**
   * A human-readable name for the model.
   */
⋮----
/**
   * Object type.
   *
   * For Models, this is always `&amp;quot;model&amp;quot;`.
   */
⋮----
export interface ModelRetrieveParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface ModelListParams extends PageParams {
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */&lt;/file&gt;&lt;file path=&quot;src/resources/messages/batches.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from &amp;apos;../../core/resource&amp;apos;;
⋮----
import { APIPromise } from &amp;apos;../../core/api-promise&amp;apos;;
import { Page, type PageParams, PagePromise } from &amp;apos;../../core/pagination&amp;apos;;
import { buildHeaders } from &amp;apos;../../internal/headers&amp;apos;;
import { RequestOptions } from &amp;apos;../../internal/request-options&amp;apos;;
import { JSONLDecoder } from &amp;apos;../../internal/decoders/jsonl&amp;apos;;
import { AnthropicError } from &amp;apos;../../error&amp;apos;;
import { path } from &amp;apos;../../internal/utils/path&amp;apos;;
export class Batches extends APIResource
⋮----
/**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.create({
   *   requests: [
   *     {
   *       custom_id: &amp;apos;my-custom-id-1&amp;apos;,
   *       params: {
   *         max_tokens: 1024,
   *         messages: [
   *           { content: &amp;apos;Hello, world&amp;apos;, role: &amp;apos;user&amp;apos; },
   *         ],
   *         model: &amp;apos;claude-3-7-sonnet-20250219&amp;apos;,
   *       },
   *     },
   *   ],
   * });
   * ```
   */
create(body: BatchCreateParams, options?: RequestOptions): APIPromise&amp;lt;MessageBatch&amp;gt;
/**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.retrieve(
   *   &amp;apos;message_batch_id&amp;apos;,
   * );
   * ```
   */
retrieve(messageBatchID: string, options?: RequestOptions): APIPromise&amp;lt;MessageBatch&amp;gt;
/**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const messageBatch of client.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
list(
    query: BatchListParams | null | undefined = {},
    options?: RequestOptions,
): PagePromise&amp;lt;MessageBatchesPage, MessageBatch&amp;gt;
/**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they&amp;apos;ve finished processing. If you&amp;apos;d
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const deletedMessageBatch =
   *   await client.messages.batches.delete(&amp;apos;message_batch_id&amp;apos;);
   * ```
   */
delete(messageBatchID: string, options?: RequestOptions): APIPromise&amp;lt;DeletedMessageBatch&amp;gt;
/**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.cancel(
   *   &amp;apos;message_batch_id&amp;apos;,
   * );
   * ```
   */
cancel(messageBatchID: string, options?: RequestOptions): APIPromise&amp;lt;MessageBatch&amp;gt;
/**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatchIndividualResponse =
   *   await client.messages.batches.results(&amp;apos;message_batch_id&amp;apos;);
   * ```
   */
async results(
    messageBatchID: string,
    options?: RequestOptions,
): Promise&amp;lt;JSONLDecoder&amp;lt;MessageBatchIndividualResponse&amp;gt;&amp;gt;
⋮----
export type MessageBatchesPage = Page&amp;lt;MessageBatch&amp;gt;;
export interface DeletedMessageBatch {
  /**
   * ID of the Message Batch.
   */
  id: string;
  /**
   * Deleted object type.
   *
   * For Message Batches, this is always `&amp;quot;message_batch_deleted&amp;quot;`.
   */
  type: &amp;apos;message_batch_deleted&amp;apos;;
}
⋮----
/**
   * ID of the Message Batch.
   */
⋮----
/**
   * Deleted object type.
   *
   * For Message Batches, this is always `&amp;quot;message_batch_deleted&amp;quot;`.
   */
⋮----
export interface MessageBatch {
  /**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
  id: string;
  /**
   * RFC 3339 datetime string representing the time at which the Message Batch was
   * archived and its results became unavailable.
   */
  archived_at: string | null;
  /**
   * RFC 3339 datetime string representing the time at which cancellation was
   * initiated for the Message Batch. Specified only if cancellation was initiated.
   */
  cancel_initiated_at: string | null;
  /**
   * RFC 3339 datetime string representing the time at which the Message Batch was
   * created.
   */
  created_at: string;
  /**
   * RFC 3339 datetime string representing the time at which processing for the
   * Message Batch ended. Specified only once processing ends.
   *
   * Processing ends when every request in a Message Batch has either succeeded,
   * errored, canceled, or expired.
   */
  ended_at: string | null;
  /**
   * RFC 3339 datetime string representing the time at which the Message Batch will
   * expire and end processing, which is 24 hours after creation.
   */
  expires_at: string;
  /**
   * Processing status of the Message Batch.
   */
  processing_status: &amp;apos;in_progress&amp;apos; | &amp;apos;canceling&amp;apos; | &amp;apos;ended&amp;apos;;
  /**
   * Tallies requests within the Message Batch, categorized by their status.
   *
   * Requests start as `processing` and move to one of the other statuses only once
   * processing of the entire batch ends. The sum of all values always matches the
   * total number of requests in the batch.
   */
  request_counts: MessageBatchRequestCounts;
  /**
   * URL to a `.jsonl` file containing the results of the Message Batch requests.
   * Specified only once processing ends.
   *
   * Results in the file are not guaranteed to be in the same order as requests. Use
   * the `custom_id` field to match results to requests.
   */
  results_url: string | null;
  /**
   * Object type.
   *
   * For Message Batches, this is always `&amp;quot;message_batch&amp;quot;`.
   */
  type: &amp;apos;message_batch&amp;apos;;
}
⋮----
/**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which the Message Batch was
   * archived and its results became unavailable.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which cancellation was
   * initiated for the Message Batch. Specified only if cancellation was initiated.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which the Message Batch was
   * created.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which processing for the
   * Message Batch ended. Specified only once processing ends.
   *
   * Processing ends when every request in a Message Batch has either succeeded,
   * errored, canceled, or expired.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which the Message Batch will
   * expire and end processing, which is 24 hours after creation.
   */
⋮----
/**
   * Processing status of the Message Batch.
   */
⋮----
/**
   * Tallies requests within the Message Batch, categorized by their status.
   *
   * Requests start as `processing` and move to one of the other statuses only once
   * processing of the entire batch ends. The sum of all values always matches the
   * total number of requests in the batch.
   */
⋮----
/**
   * URL to a `.jsonl` file containing the results of the Message Batch requests.
   * Specified only once processing ends.
   *
   * Results in the file are not guaranteed to be in the same order as requests. Use
   * the `custom_id` field to match results to requests.
   */
⋮----
/**
   * Object type.
   *
   * For Message Batches, this is always `&amp;quot;message_batch&amp;quot;`.
   */
⋮----
export interface MessageBatchCanceledResult {
  type: &amp;apos;canceled&amp;apos;;
}
export interface MessageBatchErroredResult {
  error: Shared.ErrorResponse;
  type: &amp;apos;errored&amp;apos;;
}
export interface MessageBatchExpiredResult {
  type: &amp;apos;expired&amp;apos;;
}
/**
 * This is a single line in the response `.jsonl` file and does not represent the
 * response as a whole.
 */
export interface MessageBatchIndividualResponse {
  /**
   * Developer-provided ID created for each request in a Message Batch. Useful for
   * matching results to requests, as results may be given out of request order.
   *
   * Must be unique for each request within the Message Batch.
   */
  custom_id: string;
  /**
   * Processing result for this request.
   *
   * Contains a Message output if processing was successful, an error response if
   * processing failed, or the reason why processing was not attempted, such as
   * cancellation or expiration.
   */
  result: MessageBatchResult;
}
⋮----
/**
   * Developer-provided ID created for each request in a Message Batch. Useful for
   * matching results to requests, as results may be given out of request order.
   *
   * Must be unique for each request within the Message Batch.
   */
⋮----
/**
   * Processing result for this request.
   *
   * Contains a Message output if processing was successful, an error response if
   * processing failed, or the reason why processing was not attempted, such as
   * cancellation or expiration.
   */
⋮----
export interface MessageBatchRequestCounts {
  /**
   * Number of requests in the Message Batch that have been canceled.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
  canceled: number;
  /**
   * Number of requests in the Message Batch that encountered an error.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
  errored: number;
  /**
   * Number of requests in the Message Batch that have expired.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
  expired: number;
  /**
   * Number of requests in the Message Batch that are processing.
   */
  processing: number;
  /**
   * Number of requests in the Message Batch that have completed successfully.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
  succeeded: number;
}
⋮----
/**
   * Number of requests in the Message Batch that have been canceled.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
⋮----
/**
   * Number of requests in the Message Batch that encountered an error.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
⋮----
/**
   * Number of requests in the Message Batch that have expired.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
⋮----
/**
   * Number of requests in the Message Batch that are processing.
   */
⋮----
/**
   * Number of requests in the Message Batch that have completed successfully.
   *
   * This is zero until processing of the entire Message Batch has ended.
   */
⋮----
/**
 * Processing result for this request.
 *
 * Contains a Message output if processing was successful, an error response if
 * processing failed, or the reason why processing was not attempted, such as
 * cancellation or expiration.
 */
export type MessageBatchResult =
  | MessageBatchSucceededResult
  | MessageBatchErroredResult
  | MessageBatchCanceledResult
  | MessageBatchExpiredResult;
export interface MessageBatchSucceededResult {
  message: MessagesAPI.Message;
  type: &amp;apos;succeeded&amp;apos;;
}
export interface BatchCreateParams {
  /**
   * List of requests for prompt completion. Each is an individual request to create
   * a Message.
   */
  requests: Array&amp;lt;BatchCreateParams.Request&amp;gt;;
}
⋮----
/**
   * List of requests for prompt completion. Each is an individual request to create
   * a Message.
   */
⋮----
export interface Request {
    /**
     * Developer-provided ID created for each request in a Message Batch. Useful for
     * matching results to requests, as results may be given out of request order.
     *
     * Must be unique for each request within the Message Batch.
     */
    custom_id: string;
    /**
     * Messages API creation parameters for the individual request.
     *
     * See the [Messages API reference](/en/api/messages) for full documentation on
     * available parameters.
     */
    params: MessagesAPI.MessageCreateParamsNonStreaming;
  }
⋮----
/**
     * Developer-provided ID created for each request in a Message Batch. Useful for
     * matching results to requests, as results may be given out of request order.
     *
     * Must be unique for each request within the Message Batch.
     */
⋮----
/**
     * Messages API creation parameters for the individual request.
     *
     * See the [Messages API reference](/en/api/messages) for full documentation on
     * available parameters.
     */
⋮----
export interface BatchListParams extends PageParams {}&lt;/file&gt;&lt;file path=&quot;src/resources/messages/index.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/resources/messages/messages.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIPromise } from &amp;apos;../../core/api-promise&amp;apos;;
import { APIResource } from &amp;apos;../../core/resource&amp;apos;;
import { Stream } from &amp;apos;../../core/streaming&amp;apos;;
import { RequestOptions } from &amp;apos;../../internal/request-options&amp;apos;;
import { MessageStream } from &amp;apos;../../lib/MessageStream&amp;apos;;
⋮----
import {
  BatchCreateParams,
  BatchListParams,
  Batches,
  DeletedMessageBatch,
  MessageBatch,
  MessageBatchCanceledResult,
  MessageBatchErroredResult,
  MessageBatchExpiredResult,
  MessageBatchIndividualResponse,
  MessageBatchRequestCounts,
  MessageBatchResult,
  MessageBatchSucceededResult,
  MessageBatchesPage,
} from &amp;apos;./batches&amp;apos;;
⋮----
import { MODEL_NONSTREAMING_TOKENS } from &amp;apos;../../internal/constants&amp;apos;;
export class Messages extends APIResource
⋮----
/**
   * Send a structured list of input messages with text and/or image content, and the
   * model will generate the next message in the conversation.
   *
   * The Messages API can be used for either single queries or stateless multi-turn
   * conversations.
   *
   * Learn more about the Messages API in our [user guide](/en/docs/initial-setup)
   *
   * @example
   * ```ts
   * const message = await client.messages.create({
   *   max_tokens: 1024,
   *   messages: [{ content: &amp;apos;Hello, world&amp;apos;, role: &amp;apos;user&amp;apos; }],
   *   model: &amp;apos;claude-3-7-sonnet-20250219&amp;apos;,
   * });
   * ```
   */
create(body: MessageCreateParamsNonStreaming, options?: RequestOptions): APIPromise&amp;lt;Message&amp;gt;;
create(
    body: MessageCreateParamsStreaming,
    options?: RequestOptions,
  ): APIPromise&amp;lt;Stream&amp;lt;RawMessageStreamEvent&amp;gt;&amp;gt;;
create(
    body: MessageCreateParamsBase,
    options?: RequestOptions,
  ): APIPromise&amp;lt;Stream&amp;lt;RawMessageStreamEvent&amp;gt; | Message&amp;gt;;
create(
    body: MessageCreateParams,
    options?: RequestOptions,
): APIPromise&amp;lt;Message&amp;gt; | APIPromise&amp;lt;Stream&amp;lt;RawMessageStreamEvent&amp;gt;&amp;gt;
/**
   * Create a Message stream
   */
stream(body: MessageStreamParams, options?: RequestOptions): MessageStream
/**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const messageTokensCount =
   *   await client.messages.countTokens({
   *     messages: [{ content: &amp;apos;string&amp;apos;, role: &amp;apos;user&amp;apos; }],
   *     model: &amp;apos;claude-3-7-sonnet-latest&amp;apos;,
   *   });
   * ```
   */
countTokens(body: MessageCountTokensParams, options?: RequestOptions): APIPromise&amp;lt;MessageTokensCount&amp;gt;
⋮----
export interface Base64ImageSource {
  data: string;
  media_type: &amp;apos;image/jpeg&amp;apos; | &amp;apos;image/png&amp;apos; | &amp;apos;image/gif&amp;apos; | &amp;apos;image/webp&amp;apos;;
  type: &amp;apos;base64&amp;apos;;
}
export interface Base64PDFSource {
  data: string;
  media_type: &amp;apos;application/pdf&amp;apos;;
  type: &amp;apos;base64&amp;apos;;
}
export interface CacheControlEphemeral {
  type: &amp;apos;ephemeral&amp;apos;;
}
export interface CitationCharLocation {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_char_index: number;
  start_char_index: number;
  type: &amp;apos;char_location&amp;apos;;
}
export interface CitationCharLocationParam {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_char_index: number;
  start_char_index: number;
  type: &amp;apos;char_location&amp;apos;;
}
export interface CitationContentBlockLocation {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_block_index: number;
  start_block_index: number;
  type: &amp;apos;content_block_location&amp;apos;;
}
export interface CitationContentBlockLocationParam {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_block_index: number;
  start_block_index: number;
  type: &amp;apos;content_block_location&amp;apos;;
}
export interface CitationPageLocation {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_page_number: number;
  start_page_number: number;
  type: &amp;apos;page_location&amp;apos;;
}
export interface CitationPageLocationParam {
  cited_text: string;
  document_index: number;
  document_title: string | null;
  end_page_number: number;
  start_page_number: number;
  type: &amp;apos;page_location&amp;apos;;
}
export interface CitationWebSearchResultLocationParam {
  cited_text: string;
  encrypted_index: string;
  title: string | null;
  type: &amp;apos;web_search_result_location&amp;apos;;
  url: string;
}
export interface CitationsConfigParam {
  enabled?: boolean;
}
export interface CitationsDelta {
  citation:
    | CitationCharLocation
    | CitationPageLocation
    | CitationContentBlockLocation
    | CitationsWebSearchResultLocation;
  type: &amp;apos;citations_delta&amp;apos;;
}
export interface CitationsWebSearchResultLocation {
  cited_text: string;
  encrypted_index: string;
  title: string | null;
  type: &amp;apos;web_search_result_location&amp;apos;;
  url: string;
}
export type ContentBlock =
  | TextBlock
  | ToolUseBlock
  | ServerToolUseBlock
  | WebSearchToolResultBlock
  | ThinkingBlock
  | RedactedThinkingBlock;
/**
 * Regular text content.
 */
export type ContentBlockParam =
  | ServerToolUseBlockParam
  | WebSearchToolResultBlockParam
  | TextBlockParam
  | ImageBlockParam
  | ToolUseBlockParam
  | ToolResultBlockParam
  | DocumentBlockParam
  | ThinkingBlockParam
  | RedactedThinkingBlockParam;
export interface ContentBlockSource {
  content: string | Array&amp;lt;ContentBlockSourceContent&amp;gt;;
  type: &amp;apos;content&amp;apos;;
}
export type ContentBlockSourceContent = TextBlockParam | ImageBlockParam;
export interface DocumentBlockParam {
  source: Base64PDFSource | PlainTextSource | ContentBlockSource | URLPDFSource;
  type: &amp;apos;document&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
  citations?: CitationsConfigParam;
  context?: string | null;
  title?: string | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface ImageBlockParam {
  source: Base64ImageSource | URLImageSource;
  type: &amp;apos;image&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface InputJSONDelta {
  partial_json: string;
  type: &amp;apos;input_json_delta&amp;apos;;
}
export interface Message {
  /**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
  id: string;
  /**
   * Content generated by the model.
   *
   * This is an array of content blocks, each of which has a `type` that determines
   * its shape.
   *
   * Example:
   *
   * ```json
   * [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude.&amp;quot; }]
   * ```
   *
   * If the request input `messages` ended with an `assistant` turn, then the
   * response `content` will continue directly from that last turn. You can use this
   * to constrain the model&amp;apos;s output.
   *
   * For example, if the input `messages` were:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Then the response `content` might be:
   *
   * ```json
   * [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;B)&amp;quot; }]
   * ```
   */
  content: Array&amp;lt;ContentBlock&amp;gt;;
  /**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
  model: Model;
  /**
   * Conversational role of the generated message.
   *
   * This will always be `&amp;quot;assistant&amp;quot;`.
   */
  role: &amp;apos;assistant&amp;apos;;
  /**
   * The reason that we stopped.
   *
   * This may be one the following values:
   *
   * - `&amp;quot;end_turn&amp;quot;`: the model reached a natural stopping point
   * - `&amp;quot;max_tokens&amp;quot;`: we exceeded the requested `max_tokens` or the model&amp;apos;s maximum
   * - `&amp;quot;stop_sequence&amp;quot;`: one of your provided custom `stop_sequences` was generated
   * - `&amp;quot;tool_use&amp;quot;`: the model invoked one or more tools
   *
   * In non-streaming mode this value is always non-null. In streaming mode, it is
   * null in the `message_start` event and non-null otherwise.
   */
  stop_reason: StopReason | null;
  /**
   * Which custom stop sequence was generated, if any.
   *
   * This value will be a non-null string if one of your custom stop sequences was
   * generated.
   */
  stop_sequence: string | null;
  /**
   * Object type.
   *
   * For Messages, this is always `&amp;quot;message&amp;quot;`.
   */
  type: &amp;apos;message&amp;apos;;
  /**
   * Billing and rate-limit usage.
   *
   * Anthropic&amp;apos;s API bills and rate-limits by token counts, as tokens represent the
   * underlying cost to our systems.
   *
   * Under the hood, the API transforms requests into a format suitable for the
   * model. The model&amp;apos;s output then goes through a parsing stage before becoming an
   * API response. As a result, the token counts in `usage` will not match one-to-one
   * with the exact visible content of an API request or response.
   *
   * For example, `output_tokens` will be non-zero, even for an empty string response
   * from Claude.
   *
   * Total input tokens in a request is the summation of `input_tokens`,
   * `cache_creation_input_tokens`, and `cache_read_input_tokens`.
   */
  usage: Usage;
}
⋮----
/**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
⋮----
/**
   * Content generated by the model.
   *
   * This is an array of content blocks, each of which has a `type` that determines
   * its shape.
   *
   * Example:
   *
   * ```json
   * [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude.&amp;quot; }]
   * ```
   *
   * If the request input `messages` ended with an `assistant` turn, then the
   * response `content` will continue directly from that last turn. You can use this
   * to constrain the model&amp;apos;s output.
   *
   * For example, if the input `messages` were:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Then the response `content` might be:
   *
   * ```json
   * [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;B)&amp;quot; }]
   * ```
   */
⋮----
/**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
⋮----
/**
   * Conversational role of the generated message.
   *
   * This will always be `&amp;quot;assistant&amp;quot;`.
   */
⋮----
/**
   * The reason that we stopped.
   *
   * This may be one the following values:
   *
   * - `&amp;quot;end_turn&amp;quot;`: the model reached a natural stopping point
   * - `&amp;quot;max_tokens&amp;quot;`: we exceeded the requested `max_tokens` or the model&amp;apos;s maximum
   * - `&amp;quot;stop_sequence&amp;quot;`: one of your provided custom `stop_sequences` was generated
   * - `&amp;quot;tool_use&amp;quot;`: the model invoked one or more tools
   *
   * In non-streaming mode this value is always non-null. In streaming mode, it is
   * null in the `message_start` event and non-null otherwise.
   */
⋮----
/**
   * Which custom stop sequence was generated, if any.
   *
   * This value will be a non-null string if one of your custom stop sequences was
   * generated.
   */
⋮----
/**
   * Object type.
   *
   * For Messages, this is always `&amp;quot;message&amp;quot;`.
   */
⋮----
/**
   * Billing and rate-limit usage.
   *
   * Anthropic&amp;apos;s API bills and rate-limits by token counts, as tokens represent the
   * underlying cost to our systems.
   *
   * Under the hood, the API transforms requests into a format suitable for the
   * model. The model&amp;apos;s output then goes through a parsing stage before becoming an
   * API response. As a result, the token counts in `usage` will not match one-to-one
   * with the exact visible content of an API request or response.
   *
   * For example, `output_tokens` will be non-zero, even for an empty string response
   * from Claude.
   *
   * Total input tokens in a request is the summation of `input_tokens`,
   * `cache_creation_input_tokens`, and `cache_read_input_tokens`.
   */
⋮----
export type MessageCountTokensTool = Tool | ToolBash20250124 | ToolTextEditor20250124 | WebSearchTool20250305;
export interface MessageDeltaUsage {
  /**
   * The cumulative number of input tokens used to create the cache entry.
   */
  cache_creation_input_tokens: number | null;
  /**
   * The cumulative number of input tokens read from the cache.
   */
  cache_read_input_tokens: number | null;
  /**
   * The cumulative number of input tokens which were used.
   */
  input_tokens: number | null;
  /**
   * The cumulative number of output tokens which were used.
   */
  output_tokens: number;
  /**
   * The number of server tool requests.
   */
  server_tool_use: ServerToolUsage | null;
}
⋮----
/**
   * The cumulative number of input tokens used to create the cache entry.
   */
⋮----
/**
   * The cumulative number of input tokens read from the cache.
   */
⋮----
/**
   * The cumulative number of input tokens which were used.
   */
⋮----
/**
   * The cumulative number of output tokens which were used.
   */
⋮----
/**
   * The number of server tool requests.
   */
⋮----
export interface MessageParam {
  content: string | Array&amp;lt;ContentBlockParam&amp;gt;;
  role: &amp;apos;user&amp;apos; | &amp;apos;assistant&amp;apos;;
}
export interface MessageTokensCount {
  /**
   * The total number of tokens across the provided list of messages, system prompt,
   * and tools.
   */
  input_tokens: number;
}
⋮----
/**
   * The total number of tokens across the provided list of messages, system prompt,
   * and tools.
   */
⋮----
export interface Metadata {
  /**
   * An external identifier for the user who is associated with the request.
   *
   * This should be a uuid, hash value, or other opaque identifier. Anthropic may use
   * this id to help detect abuse. Do not include any identifying information such as
   * name, email address, or phone number.
   */
  user_id?: string | null;
}
⋮----
/**
   * An external identifier for the user who is associated with the request.
   *
   * This should be a uuid, hash value, or other opaque identifier. Anthropic may use
   * this id to help detect abuse. Do not include any identifying information such as
   * name, email address, or phone number.
   */
⋮----
/**
 * The model that will complete your prompt.\n\nSee
 * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
 * details and options.
 */
export type Model =
  | &amp;apos;claude-3-7-sonnet-latest&amp;apos;
  | &amp;apos;claude-3-7-sonnet-20250219&amp;apos;
  | &amp;apos;claude-3-5-haiku-latest&amp;apos;
  | &amp;apos;claude-3-5-haiku-20241022&amp;apos;
  | &amp;apos;claude-sonnet-4-20250514&amp;apos;
  | &amp;apos;claude-sonnet-4-0&amp;apos;
  | &amp;apos;claude-4-sonnet-20250514&amp;apos;
  | &amp;apos;claude-3-5-sonnet-latest&amp;apos;
  | &amp;apos;claude-3-5-sonnet-20241022&amp;apos;
  | &amp;apos;claude-3-5-sonnet-20240620&amp;apos;
  | &amp;apos;claude-opus-4-0&amp;apos;
  | &amp;apos;claude-opus-4-20250514&amp;apos;
  | &amp;apos;claude-4-opus-20250514&amp;apos;
  | &amp;apos;claude-3-opus-latest&amp;apos;
  | &amp;apos;claude-3-opus-20240229&amp;apos;
  | &amp;apos;claude-3-sonnet-20240229&amp;apos;
  | &amp;apos;claude-3-haiku-20240307&amp;apos;
  | &amp;apos;claude-2.1&amp;apos;
  | &amp;apos;claude-2.0&amp;apos;
  | (string &amp;amp; {});
⋮----
export interface PlainTextSource {
  data: string;
  media_type: &amp;apos;text/plain&amp;apos;;
  type: &amp;apos;text&amp;apos;;
}
export type RawContentBlockDelta =
  | TextDelta
  | InputJSONDelta
  | CitationsDelta
  | ThinkingDelta
  | SignatureDelta;
export interface RawContentBlockDeltaEvent {
  delta: RawContentBlockDelta;
  index: number;
  type: &amp;apos;content_block_delta&amp;apos;;
}
export interface RawContentBlockStartEvent {
  content_block:
    | TextBlock
    | ToolUseBlock
    | ServerToolUseBlock
    | WebSearchToolResultBlock
    | ThinkingBlock
    | RedactedThinkingBlock;
  index: number;
  type: &amp;apos;content_block_start&amp;apos;;
}
export interface RawContentBlockStopEvent {
  index: number;
  type: &amp;apos;content_block_stop&amp;apos;;
}
export interface RawMessageDeltaEvent {
  delta: RawMessageDeltaEvent.Delta;
  type: &amp;apos;message_delta&amp;apos;;
  /**
   * Billing and rate-limit usage.
   *
   * Anthropic&amp;apos;s API bills and rate-limits by token counts, as tokens represent the
   * underlying cost to our systems.
   *
   * Under the hood, the API transforms requests into a format suitable for the
   * model. The model&amp;apos;s output then goes through a parsing stage before becoming an
   * API response. As a result, the token counts in `usage` will not match one-to-one
   * with the exact visible content of an API request or response.
   *
   * For example, `output_tokens` will be non-zero, even for an empty string response
   * from Claude.
   *
   * Total input tokens in a request is the summation of `input_tokens`,
   * `cache_creation_input_tokens`, and `cache_read_input_tokens`.
   */
  usage: MessageDeltaUsage;
}
⋮----
/**
   * Billing and rate-limit usage.
   *
   * Anthropic&amp;apos;s API bills and rate-limits by token counts, as tokens represent the
   * underlying cost to our systems.
   *
   * Under the hood, the API transforms requests into a format suitable for the
   * model. The model&amp;apos;s output then goes through a parsing stage before becoming an
   * API response. As a result, the token counts in `usage` will not match one-to-one
   * with the exact visible content of an API request or response.
   *
   * For example, `output_tokens` will be non-zero, even for an empty string response
   * from Claude.
   *
   * Total input tokens in a request is the summation of `input_tokens`,
   * `cache_creation_input_tokens`, and `cache_read_input_tokens`.
   */
⋮----
export interface Delta {
    stop_reason: MessagesAPI.StopReason | null;
    stop_sequence: string | null;
  }
⋮----
export interface RawMessageStartEvent {
  message: Message;
  type: &amp;apos;message_start&amp;apos;;
}
export interface RawMessageStopEvent {
  type: &amp;apos;message_stop&amp;apos;;
}
export type RawMessageStreamEvent =
  | RawMessageStartEvent
  | RawMessageDeltaEvent
  | RawMessageStopEvent
  | RawContentBlockStartEvent
  | RawContentBlockDeltaEvent
  | RawContentBlockStopEvent;
export interface RedactedThinkingBlock {
  data: string;
  type: &amp;apos;redacted_thinking&amp;apos;;
}
export interface RedactedThinkingBlockParam {
  data: string;
  type: &amp;apos;redacted_thinking&amp;apos;;
}
export interface ServerToolUsage {
  /**
   * The number of web search tool requests.
   */
  web_search_requests: number;
}
⋮----
/**
   * The number of web search tool requests.
   */
⋮----
export interface ServerToolUseBlock {
  id: string;
  input: unknown;
  name: &amp;apos;web_search&amp;apos;;
  type: &amp;apos;server_tool_use&amp;apos;;
}
export interface ServerToolUseBlockParam {
  id: string;
  input: unknown;
  name: &amp;apos;web_search&amp;apos;;
  type: &amp;apos;server_tool_use&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface SignatureDelta {
  signature: string;
  type: &amp;apos;signature_delta&amp;apos;;
}
export type StopReason = &amp;apos;end_turn&amp;apos; | &amp;apos;max_tokens&amp;apos; | &amp;apos;stop_sequence&amp;apos; | &amp;apos;tool_use&amp;apos; | &amp;apos;pause_turn&amp;apos; | &amp;apos;refusal&amp;apos;;
export interface TextBlock {
  /**
   * Citations supporting the text block.
   *
   * The type of citation returned will depend on the type of document being cited.
   * Citing a PDF results in `page_location`, plain text results in `char_location`,
   * and content document results in `content_block_location`.
   */
  citations: Array&amp;lt;TextCitation&amp;gt; | null;
  text: string;
  type: &amp;apos;text&amp;apos;;
}
⋮----
/**
   * Citations supporting the text block.
   *
   * The type of citation returned will depend on the type of document being cited.
   * Citing a PDF results in `page_location`, plain text results in `char_location`,
   * and content document results in `content_block_location`.
   */
⋮----
export interface TextBlockParam {
  text: string;
  type: &amp;apos;text&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
  citations?: Array&amp;lt;TextCitationParam&amp;gt; | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export type TextCitation =
  | CitationCharLocation
  | CitationPageLocation
  | CitationContentBlockLocation
  | CitationsWebSearchResultLocation;
export type TextCitationParam =
  | CitationCharLocationParam
  | CitationPageLocationParam
  | CitationContentBlockLocationParam
  | CitationWebSearchResultLocationParam;
export interface TextDelta {
  text: string;
  type: &amp;apos;text_delta&amp;apos;;
}
export interface ThinkingBlock {
  signature: string;
  thinking: string;
  type: &amp;apos;thinking&amp;apos;;
}
export interface ThinkingBlockParam {
  signature: string;
  thinking: string;
  type: &amp;apos;thinking&amp;apos;;
}
export interface ThinkingConfigDisabled {
  type: &amp;apos;disabled&amp;apos;;
}
export interface ThinkingConfigEnabled {
  /**
   * Determines how many tokens Claude can use for its internal reasoning process.
   * Larger budgets can enable more thorough analysis for complex problems, improving
   * response quality.
   *
   * Must be ≥1024 and less than `max_tokens`.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
  budget_tokens: number;
  type: &amp;apos;enabled&amp;apos;;
}
⋮----
/**
   * Determines how many tokens Claude can use for its internal reasoning process.
   * Larger budgets can enable more thorough analysis for complex problems, improving
   * response quality.
   *
   * Must be ≥1024 and less than `max_tokens`.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
⋮----
/**
 * Configuration for enabling Claude&amp;apos;s extended thinking.
 *
 * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
 * thinking process before the final answer. Requires a minimum budget of 1,024
 * tokens and counts towards your `max_tokens` limit.
 *
 * See
 * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
 * for details.
 */
export type ThinkingConfigParam = ThinkingConfigEnabled | ThinkingConfigDisabled;
export interface ThinkingDelta {
  thinking: string;
  type: &amp;apos;thinking_delta&amp;apos;;
}
export interface Tool {
  /**
   * [JSON schema](https://json-schema.org/draft/2020-12) for this tool&amp;apos;s input.
   *
   * This defines the shape of the `input` that your tool accepts and that the model
   * will produce.
   */
  input_schema: Tool.InputSchema;
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: string;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
  /**
   * Description of what this tool does.
   *
   * Tool descriptions should be as detailed as possible. The more information that
   * the model has about what the tool is and how to use it, the better it will
   * perform. You can use natural language descriptions to reinforce important
   * aspects of the tool input JSON schema.
   */
  description?: string;
  type?: &amp;apos;custom&amp;apos; | null;
}
⋮----
/**
   * [JSON schema](https://json-schema.org/draft/2020-12) for this tool&amp;apos;s input.
   *
   * This defines the shape of the `input` that your tool accepts and that the model
   * will produce.
   */
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
   * Description of what this tool does.
   *
   * Tool descriptions should be as detailed as possible. The more information that
   * the model has about what the tool is and how to use it, the better it will
   * perform. You can use natural language descriptions to reinforce important
   * aspects of the tool input JSON schema.
   */
⋮----
/**
   * [JSON schema](https://json-schema.org/draft/2020-12) for this tool&amp;apos;s input.
   *
   * This defines the shape of the `input` that your tool accepts and that the model
   * will produce.
   */
export interface InputSchema {
    type: &amp;apos;object&amp;apos;;
    properties?: unknown | null;
    [k: string]: unknown;
  }
⋮----
export interface ToolBash20250124 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;bash&amp;apos;;
  type: &amp;apos;bash_20250124&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
 * How the model should use the provided tools. The model can use a specific tool,
 * any available tool, decide by itself, or not use tools at all.
 */
export type ToolChoice = ToolChoiceAuto | ToolChoiceAny | ToolChoiceTool | ToolChoiceNone;
/**
 * The model will use any available tools.
 */
export interface ToolChoiceAny {
  type: &amp;apos;any&amp;apos;;
  /**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output exactly one tool
   * use.
   */
  disable_parallel_tool_use?: boolean;
}
⋮----
/**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output exactly one tool
   * use.
   */
⋮----
/**
 * The model will automatically decide whether to use tools.
 */
export interface ToolChoiceAuto {
  type: &amp;apos;auto&amp;apos;;
  /**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output at most one tool
   * use.
   */
  disable_parallel_tool_use?: boolean;
}
⋮----
/**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output at most one tool
   * use.
   */
⋮----
/**
 * The model will not be allowed to use tools.
 */
export interface ToolChoiceNone {
  type: &amp;apos;none&amp;apos;;
}
/**
 * The model will use the specified tool with `tool_choice.name`.
 */
export interface ToolChoiceTool {
  /**
   * The name of the tool to use.
   */
  name: string;
  type: &amp;apos;tool&amp;apos;;
  /**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output exactly one tool
   * use.
   */
  disable_parallel_tool_use?: boolean;
}
⋮----
/**
   * The name of the tool to use.
   */
⋮----
/**
   * Whether to disable parallel tool use.
   *
   * Defaults to `false`. If set to `true`, the model will output exactly one tool
   * use.
   */
⋮----
export interface ToolResultBlockParam {
  tool_use_id: string;
  type: &amp;apos;tool_result&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
  content?: string | Array&amp;lt;TextBlockParam | ImageBlockParam&amp;gt;;
  is_error?: boolean;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface ToolTextEditor20250124 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;str_replace_editor&amp;apos;;
  type: &amp;apos;text_editor_20250124&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export type ToolUnion = Tool | ToolBash20250124 | ToolTextEditor20250124 | WebSearchTool20250305;
export interface ToolUseBlock {
  id: string;
  input: unknown;
  name: string;
  type: &amp;apos;tool_use&amp;apos;;
}
export interface ToolUseBlockParam {
  id: string;
  input: unknown;
  name: string;
  type: &amp;apos;tool_use&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export interface URLImageSource {
  type: &amp;apos;url&amp;apos;;
  url: string;
}
export interface URLPDFSource {
  type: &amp;apos;url&amp;apos;;
  url: string;
}
export interface Usage {
  /**
   * The number of input tokens used to create the cache entry.
   */
  cache_creation_input_tokens: number | null;
  /**
   * The number of input tokens read from the cache.
   */
  cache_read_input_tokens: number | null;
  /**
   * The number of input tokens which were used.
   */
  input_tokens: number;
  /**
   * The number of output tokens which were used.
   */
  output_tokens: number;
  /**
   * The number of server tool requests.
   */
  server_tool_use: ServerToolUsage | null;
  /**
   * If the request used the priority, standard, or batch tier.
   */
  service_tier: &amp;apos;standard&amp;apos; | &amp;apos;priority&amp;apos; | &amp;apos;batch&amp;apos; | null;
}
⋮----
/**
   * The number of input tokens used to create the cache entry.
   */
⋮----
/**
   * The number of input tokens read from the cache.
   */
⋮----
/**
   * The number of input tokens which were used.
   */
⋮----
/**
   * The number of output tokens which were used.
   */
⋮----
/**
   * The number of server tool requests.
   */
⋮----
/**
   * If the request used the priority, standard, or batch tier.
   */
⋮----
export interface WebSearchResultBlock {
  encrypted_content: string;
  page_age: string | null;
  title: string;
  type: &amp;apos;web_search_result&amp;apos;;
  url: string;
}
export interface WebSearchResultBlockParam {
  encrypted_content: string;
  title: string;
  type: &amp;apos;web_search_result&amp;apos;;
  url: string;
  page_age?: string | null;
}
export interface WebSearchTool20250305 {
  /**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
  name: &amp;apos;web_search&amp;apos;;
  type: &amp;apos;web_search_20250305&amp;apos;;
  /**
   * If provided, only these domains will be included in results. Cannot be used
   * alongside `blocked_domains`.
   */
  allowed_domains?: Array&amp;lt;string&amp;gt; | null;
  /**
   * If provided, these domains will never appear in results. Cannot be used
   * alongside `allowed_domains`.
   */
  blocked_domains?: Array&amp;lt;string&amp;gt; | null;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
  /**
   * Maximum number of times the tool can be used in the API request.
   */
  max_uses?: number | null;
  /**
   * Parameters for the user&amp;apos;s location. Used to provide more relevant search
   * results.
   */
  user_location?: WebSearchTool20250305.UserLocation | null;
}
⋮----
/**
   * Name of the tool.
   *
   * This is how the tool will be called by the model and in `tool_use` blocks.
   */
⋮----
/**
   * If provided, only these domains will be included in results. Cannot be used
   * alongside `blocked_domains`.
   */
⋮----
/**
   * If provided, these domains will never appear in results. Cannot be used
   * alongside `allowed_domains`.
   */
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
/**
   * Maximum number of times the tool can be used in the API request.
   */
⋮----
/**
   * Parameters for the user&amp;apos;s location. Used to provide more relevant search
   * results.
   */
⋮----
/**
   * Parameters for the user&amp;apos;s location. Used to provide more relevant search
   * results.
   */
export interface UserLocation {
    type: &amp;apos;approximate&amp;apos;;
    /**
     * The city of the user.
     */
    city?: string | null;
    /**
     * The two letter
     * [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
     * user.
     */
    country?: string | null;
    /**
     * The region of the user.
     */
    region?: string | null;
    /**
     * The [IANA timezone](https://nodatime.org/TimeZones) of the user.
     */
    timezone?: string | null;
  }
⋮----
/**
     * The city of the user.
     */
⋮----
/**
     * The two letter
     * [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
     * user.
     */
⋮----
/**
     * The region of the user.
     */
⋮----
/**
     * The [IANA timezone](https://nodatime.org/TimeZones) of the user.
     */
⋮----
export interface WebSearchToolRequestError {
  error_code:
    | &amp;apos;invalid_tool_input&amp;apos;
    | &amp;apos;unavailable&amp;apos;
    | &amp;apos;max_uses_exceeded&amp;apos;
    | &amp;apos;too_many_requests&amp;apos;
    | &amp;apos;query_too_long&amp;apos;;
  type: &amp;apos;web_search_tool_result_error&amp;apos;;
}
export interface WebSearchToolResultBlock {
  content: WebSearchToolResultBlockContent;
  tool_use_id: string;
  type: &amp;apos;web_search_tool_result&amp;apos;;
}
export type WebSearchToolResultBlockContent = WebSearchToolResultError | Array&amp;lt;WebSearchResultBlock&amp;gt;;
export interface WebSearchToolResultBlockParam {
  content: WebSearchToolResultBlockParamContent;
  tool_use_id: string;
  type: &amp;apos;web_search_tool_result&amp;apos;;
  /**
   * Create a cache control breakpoint at this content block.
   */
  cache_control?: CacheControlEphemeral | null;
}
⋮----
/**
   * Create a cache control breakpoint at this content block.
   */
⋮----
export type WebSearchToolResultBlockParamContent =
  | Array&amp;lt;WebSearchResultBlockParam&amp;gt;
  | WebSearchToolRequestError;
export interface WebSearchToolResultError {
  error_code:
    | &amp;apos;invalid_tool_input&amp;apos;
    | &amp;apos;unavailable&amp;apos;
    | &amp;apos;max_uses_exceeded&amp;apos;
    | &amp;apos;too_many_requests&amp;apos;
    | &amp;apos;query_too_long&amp;apos;;
  type: &amp;apos;web_search_tool_result_error&amp;apos;;
}
export type MessageStreamEvent = RawMessageStreamEvent;
export type MessageStartEvent = RawMessageStartEvent;
export type MessageDeltaEvent = RawMessageDeltaEvent;
export type MessageStopEvent = RawMessageStopEvent;
export type ContentBlockStartEvent = RawContentBlockStartEvent;
export type ContentBlockDeltaEvent = RawContentBlockDeltaEvent;
export type ContentBlockStopEvent = RawContentBlockStopEvent;
export type MessageCreateParams = MessageCreateParamsNonStreaming | MessageCreateParamsStreaming;
export interface MessageCreateParamsBase {
  /**
   * The maximum number of tokens to generate before stopping.
   *
   * Note that our models may stop _before_ reaching this maximum. This parameter
   * only specifies the absolute maximum number of tokens to generate.
   *
   * Different models have different maximum values for this parameter. See
   * [models](https://docs.anthropic.com/en/docs/models-overview) for details.
   */
  max_tokens: number;
  /**
   * Input messages.
   *
   * Our models are trained to operate on alternating `user` and `assistant`
   * conversational turns. When creating a new `Message`, you specify the prior
   * conversational turns with the `messages` parameter, and the model then generates
   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns
   * in your request will be combined into a single turn.
   *
   * Each input message must be an object with a `role` and `content`. You can
   * specify a single `user`-role message, or you can include multiple `user` and
   * `assistant` messages.
   *
   * If the final message uses the `assistant` role, the response content will
   * continue immediately from the content in that message. This can be used to
   * constrain part of the model&amp;apos;s response.
   *
   * Example with a single `user` message:
   *
   * ```json
   * [{ &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }]
   * ```
   *
   * Example with multiple conversational turns:
   *
   * ```json
   * [
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello there.&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude. How can I help you?&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Can you explain LLMs in plain English?&amp;quot; }
   * ]
   * ```
   *
   * Example with a partially-filled response from Claude:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Each input message `content` may be either a single `string` or an array of
   * content blocks, where each block has a specific `type`. Using a `string` for
   * `content` is shorthand for an array of one content block of type `&amp;quot;text&amp;quot;`. The
   * following input messages are equivalent:
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }
   * ```
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }] }
   * ```
   *
   * Starting with Claude 3 models, you can also send image content blocks:
   *
   * ```json
   * {
   *   &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *   &amp;quot;content&amp;quot;: [
   *     {
   *       &amp;quot;type&amp;quot;: &amp;quot;image&amp;quot;,
   *       &amp;quot;source&amp;quot;: {
   *         &amp;quot;type&amp;quot;: &amp;quot;base64&amp;quot;,
   *         &amp;quot;media_type&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
   *         &amp;quot;data&amp;quot;: &amp;quot;/9j/4AAQSkZJRg...&amp;quot;
   *       }
   *     },
   *     { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;What is in this image?&amp;quot; }
   *   ]
   * }
   * ```
   *
   * We currently support the `base64` source type for images, and the `image/jpeg`,
   * `image/png`, `image/gif`, and `image/webp` media types.
   *
   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
   * more input examples.
   *
   * Note that if you want to include a
   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
   * the top-level `system` parameter — there is no `&amp;quot;system&amp;quot;` role for input
   * messages in the Messages API.
   *
   * There is a limit of 100000 messages in a single request.
   */
  messages: Array&amp;lt;MessageParam&amp;gt;;
  /**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
  model: Model;
  /**
   * An object describing metadata about the request.
   */
  metadata?: Metadata;
  /**
   * Determines whether to use priority capacity (if available) or standard capacity
   * for this request.
   *
   * Anthropic offers different levels of service for your API requests. See
   * [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
   */
  service_tier?: &amp;apos;auto&amp;apos; | &amp;apos;standard_only&amp;apos;;
  /**
   * Custom text sequences that will cause the model to stop generating.
   *
   * Our models will normally stop when they have naturally completed their turn,
   * which will result in a response `stop_reason` of `&amp;quot;end_turn&amp;quot;`.
   *
   * If you want the model to stop generating when it encounters custom strings of
   * text, you can use the `stop_sequences` parameter. If the model encounters one of
   * the custom sequences, the response `stop_reason` value will be `&amp;quot;stop_sequence&amp;quot;`
   * and the response `stop_sequence` value will contain the matched stop sequence.
   */
  stop_sequences?: Array&amp;lt;string&amp;gt;;
  /**
   * Whether to incrementally stream the response using server-sent events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
  stream?: boolean;
  /**
   * System prompt.
   *
   * A system prompt is a way of providing context and instructions to Claude, such
   * as specifying a particular goal or role. See our
   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
   */
  system?: string | Array&amp;lt;TextBlockParam&amp;gt;;
  /**
   * Amount of randomness injected into the response.
   *
   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
   * for analytical / multiple choice, and closer to `1.0` for creative and
   * generative tasks.
   *
   * Note that even with `temperature` of `0.0`, the results will not be fully
   * deterministic.
   */
  temperature?: number;
  /**
   * Configuration for enabling Claude&amp;apos;s extended thinking.
   *
   * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
   * thinking process before the final answer. Requires a minimum budget of 1,024
   * tokens and counts towards your `max_tokens` limit.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
  thinking?: ThinkingConfigParam;
  /**
   * How the model should use the provided tools. The model can use a specific tool,
   * any available tool, decide by itself, or not use tools at all.
   */
  tool_choice?: ToolChoice;
  /**
   * Definitions of tools that the model may use.
   *
   * If you include `tools` in your API request, the model may return `tool_use`
   * content blocks that represent the model&amp;apos;s use of those tools. You can then run
   * those tools using the tool input generated by the model and then optionally
   * return results back to the model using `tool_result` content blocks.
   *
   * Each tool definition includes:
   *
   * - `name`: Name of the tool.
   * - `description`: Optional, but strongly-recommended description of the tool.
   * - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
   *   tool `input` shape that the model will produce in `tool_use` output content
   *   blocks.
   *
   * For example, if you defined `tools` as:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;description&amp;quot;: &amp;quot;Get the current stock price for a given ticker symbol.&amp;quot;,
   *     &amp;quot;input_schema&amp;quot;: {
   *       &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
   *       &amp;quot;properties&amp;quot;: {
   *         &amp;quot;ticker&amp;quot;: {
   *           &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
   *           &amp;quot;description&amp;quot;: &amp;quot;The stock ticker symbol, e.g. AAPL for Apple Inc.&amp;quot;
   *         }
   *       },
   *       &amp;quot;required&amp;quot;: [&amp;quot;ticker&amp;quot;]
   *     }
   *   }
   * ]
   * ```
   *
   * And then asked the model &amp;quot;What&amp;apos;s the S&amp;amp;P 500 at today?&amp;quot;, the model might produce
   * `tool_use` content blocks in the response like this:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_use&amp;quot;,
   *     &amp;quot;id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;input&amp;quot;: { &amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot; }
   *   }
   * ]
   * ```
   *
   * You might then run your `get_stock_price` tool with `{&amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot;}` as an
   * input, and return the following back to the model in a subsequent `user`
   * message:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_result&amp;quot;,
   *     &amp;quot;tool_use_id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;259.75 USD&amp;quot;
   *   }
   * ]
   * ```
   *
   * Tools can be used for workflows that include running client-side tools and
   * functions, or more generally whenever you want the model to produce a particular
   * JSON structure of output.
   *
   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
   */
  tools?: Array&amp;lt;ToolUnion&amp;gt;;
  /**
   * Only sample from the top K options for each subsequent token.
   *
   * Used to remove &amp;quot;long tail&amp;quot; low probability responses.
   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
  top_k?: number;
  /**
   * Use nucleus sampling.
   *
   * In nucleus sampling, we compute the cumulative distribution over all the options
   * for each subsequent token in decreasing probability order and cut it off once it
   * reaches a particular probability specified by `top_p`. You should either alter
   * `temperature` or `top_p`, but not both.
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
  top_p?: number;
}
⋮----
/**
   * The maximum number of tokens to generate before stopping.
   *
   * Note that our models may stop _before_ reaching this maximum. This parameter
   * only specifies the absolute maximum number of tokens to generate.
   *
   * Different models have different maximum values for this parameter. See
   * [models](https://docs.anthropic.com/en/docs/models-overview) for details.
   */
⋮----
/**
   * Input messages.
   *
   * Our models are trained to operate on alternating `user` and `assistant`
   * conversational turns. When creating a new `Message`, you specify the prior
   * conversational turns with the `messages` parameter, and the model then generates
   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns
   * in your request will be combined into a single turn.
   *
   * Each input message must be an object with a `role` and `content`. You can
   * specify a single `user`-role message, or you can include multiple `user` and
   * `assistant` messages.
   *
   * If the final message uses the `assistant` role, the response content will
   * continue immediately from the content in that message. This can be used to
   * constrain part of the model&amp;apos;s response.
   *
   * Example with a single `user` message:
   *
   * ```json
   * [{ &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }]
   * ```
   *
   * Example with multiple conversational turns:
   *
   * ```json
   * [
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello there.&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude. How can I help you?&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Can you explain LLMs in plain English?&amp;quot; }
   * ]
   * ```
   *
   * Example with a partially-filled response from Claude:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Each input message `content` may be either a single `string` or an array of
   * content blocks, where each block has a specific `type`. Using a `string` for
   * `content` is shorthand for an array of one content block of type `&amp;quot;text&amp;quot;`. The
   * following input messages are equivalent:
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }
   * ```
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }] }
   * ```
   *
   * Starting with Claude 3 models, you can also send image content blocks:
   *
   * ```json
   * {
   *   &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *   &amp;quot;content&amp;quot;: [
   *     {
   *       &amp;quot;type&amp;quot;: &amp;quot;image&amp;quot;,
   *       &amp;quot;source&amp;quot;: {
   *         &amp;quot;type&amp;quot;: &amp;quot;base64&amp;quot;,
   *         &amp;quot;media_type&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
   *         &amp;quot;data&amp;quot;: &amp;quot;/9j/4AAQSkZJRg...&amp;quot;
   *       }
   *     },
   *     { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;What is in this image?&amp;quot; }
   *   ]
   * }
   * ```
   *
   * We currently support the `base64` source type for images, and the `image/jpeg`,
   * `image/png`, `image/gif`, and `image/webp` media types.
   *
   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
   * more input examples.
   *
   * Note that if you want to include a
   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
   * the top-level `system` parameter — there is no `&amp;quot;system&amp;quot;` role for input
   * messages in the Messages API.
   *
   * There is a limit of 100000 messages in a single request.
   */
⋮----
/**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
⋮----
/**
   * An object describing metadata about the request.
   */
⋮----
/**
   * Determines whether to use priority capacity (if available) or standard capacity
   * for this request.
   *
   * Anthropic offers different levels of service for your API requests. See
   * [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
   */
⋮----
/**
   * Custom text sequences that will cause the model to stop generating.
   *
   * Our models will normally stop when they have naturally completed their turn,
   * which will result in a response `stop_reason` of `&amp;quot;end_turn&amp;quot;`.
   *
   * If you want the model to stop generating when it encounters custom strings of
   * text, you can use the `stop_sequences` parameter. If the model encounters one of
   * the custom sequences, the response `stop_reason` value will be `&amp;quot;stop_sequence&amp;quot;`
   * and the response `stop_sequence` value will contain the matched stop sequence.
   */
⋮----
/**
   * Whether to incrementally stream the response using server-sent events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
⋮----
/**
   * System prompt.
   *
   * A system prompt is a way of providing context and instructions to Claude, such
   * as specifying a particular goal or role. See our
   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
   */
⋮----
/**
   * Amount of randomness injected into the response.
   *
   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
   * for analytical / multiple choice, and closer to `1.0` for creative and
   * generative tasks.
   *
   * Note that even with `temperature` of `0.0`, the results will not be fully
   * deterministic.
   */
⋮----
/**
   * Configuration for enabling Claude&amp;apos;s extended thinking.
   *
   * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
   * thinking process before the final answer. Requires a minimum budget of 1,024
   * tokens and counts towards your `max_tokens` limit.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
⋮----
/**
   * How the model should use the provided tools. The model can use a specific tool,
   * any available tool, decide by itself, or not use tools at all.
   */
⋮----
/**
   * Definitions of tools that the model may use.
   *
   * If you include `tools` in your API request, the model may return `tool_use`
   * content blocks that represent the model&amp;apos;s use of those tools. You can then run
   * those tools using the tool input generated by the model and then optionally
   * return results back to the model using `tool_result` content blocks.
   *
   * Each tool definition includes:
   *
   * - `name`: Name of the tool.
   * - `description`: Optional, but strongly-recommended description of the tool.
   * - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
   *   tool `input` shape that the model will produce in `tool_use` output content
   *   blocks.
   *
   * For example, if you defined `tools` as:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;description&amp;quot;: &amp;quot;Get the current stock price for a given ticker symbol.&amp;quot;,
   *     &amp;quot;input_schema&amp;quot;: {
   *       &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
   *       &amp;quot;properties&amp;quot;: {
   *         &amp;quot;ticker&amp;quot;: {
   *           &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
   *           &amp;quot;description&amp;quot;: &amp;quot;The stock ticker symbol, e.g. AAPL for Apple Inc.&amp;quot;
   *         }
   *       },
   *       &amp;quot;required&amp;quot;: [&amp;quot;ticker&amp;quot;]
   *     }
   *   }
   * ]
   * ```
   *
   * And then asked the model &amp;quot;What&amp;apos;s the S&amp;amp;P 500 at today?&amp;quot;, the model might produce
   * `tool_use` content blocks in the response like this:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_use&amp;quot;,
   *     &amp;quot;id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;input&amp;quot;: { &amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot; }
   *   }
   * ]
   * ```
   *
   * You might then run your `get_stock_price` tool with `{&amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot;}` as an
   * input, and return the following back to the model in a subsequent `user`
   * message:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_result&amp;quot;,
   *     &amp;quot;tool_use_id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;259.75 USD&amp;quot;
   *   }
   * ]
   * ```
   *
   * Tools can be used for workflows that include running client-side tools and
   * functions, or more generally whenever you want the model to produce a particular
   * JSON structure of output.
   *
   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
   */
⋮----
/**
   * Only sample from the top K options for each subsequent token.
   *
   * Used to remove &amp;quot;long tail&amp;quot; low probability responses.
   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
⋮----
/**
   * Use nucleus sampling.
   *
   * In nucleus sampling, we compute the cumulative distribution over all the options
   * for each subsequent token in decreasing probability order and cut it off once it
   * reaches a particular probability specified by `top_p`. You should either alter
   * `temperature` or `top_p`, but not both.
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
⋮----
export type MessageCreateParamsNonStreaming = MessagesAPI.MessageCreateParamsNonStreaming;
export type MessageCreateParamsStreaming = MessagesAPI.MessageCreateParamsStreaming;
⋮----
export interface MessageCreateParamsNonStreaming extends MessageCreateParamsBase {
  /**
   * Whether to incrementally stream the response using server-sent events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
  stream?: false;
}
⋮----
/**
   * Whether to incrementally stream the response using server-sent events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
⋮----
export interface MessageCreateParamsStreaming extends MessageCreateParamsBase {
  /**
   * Whether to incrementally stream the response using server-sent events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
  stream: true;
}
⋮----
/**
   * Whether to incrementally stream the response using server-sent events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
   * details.
   */
⋮----
export type MessageStreamParams = MessageCreateParamsBase;
export interface MessageCountTokensParams {
  /**
   * Input messages.
   *
   * Our models are trained to operate on alternating `user` and `assistant`
   * conversational turns. When creating a new `Message`, you specify the prior
   * conversational turns with the `messages` parameter, and the model then generates
   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns
   * in your request will be combined into a single turn.
   *
   * Each input message must be an object with a `role` and `content`. You can
   * specify a single `user`-role message, or you can include multiple `user` and
   * `assistant` messages.
   *
   * If the final message uses the `assistant` role, the response content will
   * continue immediately from the content in that message. This can be used to
   * constrain part of the model&amp;apos;s response.
   *
   * Example with a single `user` message:
   *
   * ```json
   * [{ &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }]
   * ```
   *
   * Example with multiple conversational turns:
   *
   * ```json
   * [
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello there.&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude. How can I help you?&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Can you explain LLMs in plain English?&amp;quot; }
   * ]
   * ```
   *
   * Example with a partially-filled response from Claude:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Each input message `content` may be either a single `string` or an array of
   * content blocks, where each block has a specific `type`. Using a `string` for
   * `content` is shorthand for an array of one content block of type `&amp;quot;text&amp;quot;`. The
   * following input messages are equivalent:
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }
   * ```
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }] }
   * ```
   *
   * Starting with Claude 3 models, you can also send image content blocks:
   *
   * ```json
   * {
   *   &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *   &amp;quot;content&amp;quot;: [
   *     {
   *       &amp;quot;type&amp;quot;: &amp;quot;image&amp;quot;,
   *       &amp;quot;source&amp;quot;: {
   *         &amp;quot;type&amp;quot;: &amp;quot;base64&amp;quot;,
   *         &amp;quot;media_type&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
   *         &amp;quot;data&amp;quot;: &amp;quot;/9j/4AAQSkZJRg...&amp;quot;
   *       }
   *     },
   *     { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;What is in this image?&amp;quot; }
   *   ]
   * }
   * ```
   *
   * We currently support the `base64` source type for images, and the `image/jpeg`,
   * `image/png`, `image/gif`, and `image/webp` media types.
   *
   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
   * more input examples.
   *
   * Note that if you want to include a
   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
   * the top-level `system` parameter — there is no `&amp;quot;system&amp;quot;` role for input
   * messages in the Messages API.
   *
   * There is a limit of 100000 messages in a single request.
   */
  messages: Array&amp;lt;MessageParam&amp;gt;;
  /**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
  model: Model;
  /**
   * System prompt.
   *
   * A system prompt is a way of providing context and instructions to Claude, such
   * as specifying a particular goal or role. See our
   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
   */
  system?: string | Array&amp;lt;TextBlockParam&amp;gt;;
  /**
   * Configuration for enabling Claude&amp;apos;s extended thinking.
   *
   * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
   * thinking process before the final answer. Requires a minimum budget of 1,024
   * tokens and counts towards your `max_tokens` limit.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
  thinking?: ThinkingConfigParam;
  /**
   * How the model should use the provided tools. The model can use a specific tool,
   * any available tool, decide by itself, or not use tools at all.
   */
  tool_choice?: ToolChoice;
  /**
   * Definitions of tools that the model may use.
   *
   * If you include `tools` in your API request, the model may return `tool_use`
   * content blocks that represent the model&amp;apos;s use of those tools. You can then run
   * those tools using the tool input generated by the model and then optionally
   * return results back to the model using `tool_result` content blocks.
   *
   * Each tool definition includes:
   *
   * - `name`: Name of the tool.
   * - `description`: Optional, but strongly-recommended description of the tool.
   * - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
   *   tool `input` shape that the model will produce in `tool_use` output content
   *   blocks.
   *
   * For example, if you defined `tools` as:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;description&amp;quot;: &amp;quot;Get the current stock price for a given ticker symbol.&amp;quot;,
   *     &amp;quot;input_schema&amp;quot;: {
   *       &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
   *       &amp;quot;properties&amp;quot;: {
   *         &amp;quot;ticker&amp;quot;: {
   *           &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
   *           &amp;quot;description&amp;quot;: &amp;quot;The stock ticker symbol, e.g. AAPL for Apple Inc.&amp;quot;
   *         }
   *       },
   *       &amp;quot;required&amp;quot;: [&amp;quot;ticker&amp;quot;]
   *     }
   *   }
   * ]
   * ```
   *
   * And then asked the model &amp;quot;What&amp;apos;s the S&amp;amp;P 500 at today?&amp;quot;, the model might produce
   * `tool_use` content blocks in the response like this:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_use&amp;quot;,
   *     &amp;quot;id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;input&amp;quot;: { &amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot; }
   *   }
   * ]
   * ```
   *
   * You might then run your `get_stock_price` tool with `{&amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot;}` as an
   * input, and return the following back to the model in a subsequent `user`
   * message:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_result&amp;quot;,
   *     &amp;quot;tool_use_id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;259.75 USD&amp;quot;
   *   }
   * ]
   * ```
   *
   * Tools can be used for workflows that include running client-side tools and
   * functions, or more generally whenever you want the model to produce a particular
   * JSON structure of output.
   *
   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
   */
  tools?: Array&amp;lt;MessageCountTokensTool&amp;gt;;
}
⋮----
/**
   * Input messages.
   *
   * Our models are trained to operate on alternating `user` and `assistant`
   * conversational turns. When creating a new `Message`, you specify the prior
   * conversational turns with the `messages` parameter, and the model then generates
   * the next `Message` in the conversation. Consecutive `user` or `assistant` turns
   * in your request will be combined into a single turn.
   *
   * Each input message must be an object with a `role` and `content`. You can
   * specify a single `user`-role message, or you can include multiple `user` and
   * `assistant` messages.
   *
   * If the final message uses the `assistant` role, the response content will
   * continue immediately from the content in that message. This can be used to
   * constrain part of the model&amp;apos;s response.
   *
   * Example with a single `user` message:
   *
   * ```json
   * [{ &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }]
   * ```
   *
   * Example with multiple conversational turns:
   *
   * ```json
   * [
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello there.&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hi, I&amp;apos;m Claude. How can I help you?&amp;quot; },
   *   { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Can you explain LLMs in plain English?&amp;quot; }
   * ]
   * ```
   *
   * Example with a partially-filled response from Claude:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;What&amp;apos;s the Greek name for Sun? (A) Sol (B) Helios (C) Sun&amp;quot;
   *   },
   *   { &amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;The best answer is (&amp;quot; }
   * ]
   * ```
   *
   * Each input message `content` may be either a single `string` or an array of
   * content blocks, where each block has a specific `type`. Using a `string` for
   * `content` is shorthand for an array of one content block of type `&amp;quot;text&amp;quot;`. The
   * following input messages are equivalent:
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }
   * ```
   *
   * ```json
   * { &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: [{ &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello, Claude&amp;quot; }] }
   * ```
   *
   * Starting with Claude 3 models, you can also send image content blocks:
   *
   * ```json
   * {
   *   &amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;,
   *   &amp;quot;content&amp;quot;: [
   *     {
   *       &amp;quot;type&amp;quot;: &amp;quot;image&amp;quot;,
   *       &amp;quot;source&amp;quot;: {
   *         &amp;quot;type&amp;quot;: &amp;quot;base64&amp;quot;,
   *         &amp;quot;media_type&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
   *         &amp;quot;data&amp;quot;: &amp;quot;/9j/4AAQSkZJRg...&amp;quot;
   *       }
   *     },
   *     { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;What is in this image?&amp;quot; }
   *   ]
   * }
   * ```
   *
   * We currently support the `base64` source type for images, and the `image/jpeg`,
   * `image/png`, `image/gif`, and `image/webp` media types.
   *
   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
   * more input examples.
   *
   * Note that if you want to include a
   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
   * the top-level `system` parameter — there is no `&amp;quot;system&amp;quot;` role for input
   * messages in the Messages API.
   *
   * There is a limit of 100000 messages in a single request.
   */
⋮----
/**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
⋮----
/**
   * System prompt.
   *
   * A system prompt is a way of providing context and instructions to Claude, such
   * as specifying a particular goal or role. See our
   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
   */
⋮----
/**
   * Configuration for enabling Claude&amp;apos;s extended thinking.
   *
   * When enabled, responses include `thinking` content blocks showing Claude&amp;apos;s
   * thinking process before the final answer. Requires a minimum budget of 1,024
   * tokens and counts towards your `max_tokens` limit.
   *
   * See
   * [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
   * for details.
   */
⋮----
/**
   * How the model should use the provided tools. The model can use a specific tool,
   * any available tool, decide by itself, or not use tools at all.
   */
⋮----
/**
   * Definitions of tools that the model may use.
   *
   * If you include `tools` in your API request, the model may return `tool_use`
   * content blocks that represent the model&amp;apos;s use of those tools. You can then run
   * those tools using the tool input generated by the model and then optionally
   * return results back to the model using `tool_result` content blocks.
   *
   * Each tool definition includes:
   *
   * - `name`: Name of the tool.
   * - `description`: Optional, but strongly-recommended description of the tool.
   * - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
   *   tool `input` shape that the model will produce in `tool_use` output content
   *   blocks.
   *
   * For example, if you defined `tools` as:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;description&amp;quot;: &amp;quot;Get the current stock price for a given ticker symbol.&amp;quot;,
   *     &amp;quot;input_schema&amp;quot;: {
   *       &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
   *       &amp;quot;properties&amp;quot;: {
   *         &amp;quot;ticker&amp;quot;: {
   *           &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
   *           &amp;quot;description&amp;quot;: &amp;quot;The stock ticker symbol, e.g. AAPL for Apple Inc.&amp;quot;
   *         }
   *       },
   *       &amp;quot;required&amp;quot;: [&amp;quot;ticker&amp;quot;]
   *     }
   *   }
   * ]
   * ```
   *
   * And then asked the model &amp;quot;What&amp;apos;s the S&amp;amp;P 500 at today?&amp;quot;, the model might produce
   * `tool_use` content blocks in the response like this:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_use&amp;quot;,
   *     &amp;quot;id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;name&amp;quot;: &amp;quot;get_stock_price&amp;quot;,
   *     &amp;quot;input&amp;quot;: { &amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot; }
   *   }
   * ]
   * ```
   *
   * You might then run your `get_stock_price` tool with `{&amp;quot;ticker&amp;quot;: &amp;quot;^GSPC&amp;quot;}` as an
   * input, and return the following back to the model in a subsequent `user`
   * message:
   *
   * ```json
   * [
   *   {
   *     &amp;quot;type&amp;quot;: &amp;quot;tool_result&amp;quot;,
   *     &amp;quot;tool_use_id&amp;quot;: &amp;quot;toolu_01D7FLrfh4GYq7yT1ULFeyMV&amp;quot;,
   *     &amp;quot;content&amp;quot;: &amp;quot;259.75 USD&amp;quot;
   *   }
   * ]
   * ```
   *
   * Tools can be used for workflows that include running client-side tools and
   * functions, or more generally whenever you want the model to produce a particular
   * JSON structure of output.
   *
   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
   */&lt;/file&gt;&lt;file path=&quot;src/resources/beta.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/resources/completions.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from &amp;apos;../core/resource&amp;apos;;
⋮----
import { APIPromise } from &amp;apos;../core/api-promise&amp;apos;;
import { Stream } from &amp;apos;../core/streaming&amp;apos;;
import { buildHeaders } from &amp;apos;../internal/headers&amp;apos;;
import { RequestOptions } from &amp;apos;../internal/request-options&amp;apos;;
export class Completions extends APIResource
⋮----
/**
   * [Legacy] Create a Text Completion.
   *
   * The Text Completions API is a legacy API. We recommend using the
   * [Messages API](https://docs.anthropic.com/en/api/messages) going forward.
   *
   * Future models and features will not be compatible with Text Completions. See our
   * [migration guide](https://docs.anthropic.com/en/api/migrating-from-text-completions-to-messages)
   * for guidance in migrating from Text Completions to Messages.
   *
   * @example
   * ```ts
   * const completion = await client.completions.create({
   *   max_tokens_to_sample: 256,
   *   model: &amp;apos;claude-3-7-sonnet-latest&amp;apos;,
   *   prompt: &amp;apos;\n\nHuman: Hello, world!\n\nAssistant:&amp;apos;,
   * });
   * ```
   */
create(params: CompletionCreateParamsNonStreaming, options?: RequestOptions): APIPromise&amp;lt;Completion&amp;gt;;
create(params: CompletionCreateParamsStreaming, options?: RequestOptions): APIPromise&amp;lt;Stream&amp;lt;Completion&amp;gt;&amp;gt;;
create(
    params: CompletionCreateParamsBase,
    options?: RequestOptions,
  ): APIPromise&amp;lt;Stream&amp;lt;Completion&amp;gt; | Completion&amp;gt;;
create(
    params: CompletionCreateParams,
    options?: RequestOptions,
): APIPromise&amp;lt;Completion&amp;gt; | APIPromise&amp;lt;Stream&amp;lt;Completion&amp;gt;&amp;gt;
⋮----
export interface Completion {
  /**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
  id: string;
  /**
   * The resulting completion up to and excluding the stop sequences.
   */
  completion: string;
  /**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
  model: MessagesAPI.Model;
  /**
   * The reason that we stopped.
   *
   * This may be one the following values:
   *
   * - `&amp;quot;stop_sequence&amp;quot;`: we reached a stop sequence — either provided by you via the
   *   `stop_sequences` parameter, or a stop sequence built into the model
   * - `&amp;quot;max_tokens&amp;quot;`: we exceeded `max_tokens_to_sample` or the model&amp;apos;s maximum
   */
  stop_reason: string | null;
  /**
   * Object type.
   *
   * For Text Completions, this is always `&amp;quot;completion&amp;quot;`.
   */
  type: &amp;apos;completion&amp;apos;;
}
⋮----
/**
   * Unique object identifier.
   *
   * The format and length of IDs may change over time.
   */
⋮----
/**
   * The resulting completion up to and excluding the stop sequences.
   */
⋮----
/**
   * The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
⋮----
/**
   * The reason that we stopped.
   *
   * This may be one the following values:
   *
   * - `&amp;quot;stop_sequence&amp;quot;`: we reached a stop sequence — either provided by you via the
   *   `stop_sequences` parameter, or a stop sequence built into the model
   * - `&amp;quot;max_tokens&amp;quot;`: we exceeded `max_tokens_to_sample` or the model&amp;apos;s maximum
   */
⋮----
/**
   * Object type.
   *
   * For Text Completions, this is always `&amp;quot;completion&amp;quot;`.
   */
⋮----
export type CompletionCreateParams = CompletionCreateParamsNonStreaming | CompletionCreateParamsStreaming;
export interface CompletionCreateParamsBase {
  /**
   * Body param: The maximum number of tokens to generate before stopping.
   *
   * Note that our models may stop _before_ reaching this maximum. This parameter
   * only specifies the absolute maximum number of tokens to generate.
   */
  max_tokens_to_sample: number;
  /**
   * Body param: The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
  model: MessagesAPI.Model;
  /**
   * Body param: The prompt that you want Claude to complete.
   *
   * For proper response generation you will need to format your prompt using
   * alternating `\n\nHuman:` and `\n\nAssistant:` conversational turns. For example:
   *
   * ```
   * &amp;quot;\n\nHuman: {userQuestion}\n\nAssistant:&amp;quot;
   * ```
   *
   * See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and
   * our guide to
   * [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more
   * details.
   */
  prompt: string;
  /**
   * Body param: An object describing metadata about the request.
   */
  metadata?: MessagesAPI.Metadata;
  /**
   * Body param: Sequences that will cause the model to stop generating.
   *
   * Our models stop on `&amp;quot;\n\nHuman:&amp;quot;`, and may include additional built-in stop
   * sequences in the future. By providing the stop_sequences parameter, you may
   * include additional strings that will cause the model to stop generating.
   */
  stop_sequences?: Array&amp;lt;string&amp;gt;;
  /**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.
   */
  stream?: boolean;
  /**
   * Body param: Amount of randomness injected into the response.
   *
   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
   * for analytical / multiple choice, and closer to `1.0` for creative and
   * generative tasks.
   *
   * Note that even with `temperature` of `0.0`, the results will not be fully
   * deterministic.
   */
  temperature?: number;
  /**
   * Body param: Only sample from the top K options for each subsequent token.
   *
   * Used to remove &amp;quot;long tail&amp;quot; low probability responses.
   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
  top_k?: number;
  /**
   * Body param: Use nucleus sampling.
   *
   * In nucleus sampling, we compute the cumulative distribution over all the options
   * for each subsequent token in decreasing probability order and cut it off once it
   * reaches a particular probability specified by `top_p`. You should either alter
   * `temperature` or `top_p`, but not both.
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
  top_p?: number;
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Body param: The maximum number of tokens to generate before stopping.
   *
   * Note that our models may stop _before_ reaching this maximum. This parameter
   * only specifies the absolute maximum number of tokens to generate.
   */
⋮----
/**
   * Body param: The model that will complete your prompt.\n\nSee
   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional
   * details and options.
   */
⋮----
/**
   * Body param: The prompt that you want Claude to complete.
   *
   * For proper response generation you will need to format your prompt using
   * alternating `\n\nHuman:` and `\n\nAssistant:` conversational turns. For example:
   *
   * ```
   * &amp;quot;\n\nHuman: {userQuestion}\n\nAssistant:&amp;quot;
   * ```
   *
   * See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and
   * our guide to
   * [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more
   * details.
   */
⋮----
/**
   * Body param: An object describing metadata about the request.
   */
⋮----
/**
   * Body param: Sequences that will cause the model to stop generating.
   *
   * Our models stop on `&amp;quot;\n\nHuman:&amp;quot;`, and may include additional built-in stop
   * sequences in the future. By providing the stop_sequences parameter, you may
   * include additional strings that will cause the model to stop generating.
   */
⋮----
/**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.
   */
⋮----
/**
   * Body param: Amount of randomness injected into the response.
   *
   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
   * for analytical / multiple choice, and closer to `1.0` for creative and
   * generative tasks.
   *
   * Note that even with `temperature` of `0.0`, the results will not be fully
   * deterministic.
   */
⋮----
/**
   * Body param: Only sample from the top K options for each subsequent token.
   *
   * Used to remove &amp;quot;long tail&amp;quot; low probability responses.
   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
⋮----
/**
   * Body param: Use nucleus sampling.
   *
   * In nucleus sampling, we compute the cumulative distribution over all the options
   * for each subsequent token in decreasing probability order and cut it off once it
   * reaches a particular probability specified by `top_p`. You should either alter
   * `temperature` or `top_p`, but not both.
   *
   * Recommended for advanced use cases only. You usually only need to use
   * `temperature`.
   */
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
⋮----
/**
   * @deprecated use `Anthropic.Messages.Metadata` instead
   */
export type Metadata = MessagesAPI.Metadata;
export type CompletionCreateParamsNonStreaming = CompletionsAPI.CompletionCreateParamsNonStreaming;
export type CompletionCreateParamsStreaming = CompletionsAPI.CompletionCreateParamsStreaming;
⋮----
export interface CompletionCreateParamsNonStreaming extends CompletionCreateParamsBase {
  /**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.
   */
  stream?: false;
}
⋮----
/**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.
   */
⋮----
export interface CompletionCreateParamsStreaming extends CompletionCreateParamsBase {
  /**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.
   */
  stream: true;
}
⋮----
/**
   * Body param: Whether to incrementally stream the response using server-sent
   * events.
   *
   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.
   */&lt;/file&gt;&lt;file path=&quot;src/resources/index.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/resources/messages.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/resources/models.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from &amp;apos;../core/resource&amp;apos;;
⋮----
import { APIPromise } from &amp;apos;../core/api-promise&amp;apos;;
import { Page, type PageParams, PagePromise } from &amp;apos;../core/pagination&amp;apos;;
import { buildHeaders } from &amp;apos;../internal/headers&amp;apos;;
import { RequestOptions } from &amp;apos;../internal/request-options&amp;apos;;
import { path } from &amp;apos;../internal/utils/path&amp;apos;;
export class Models extends APIResource
⋮----
/**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
retrieve(
    modelID: string,
    params: ModelRetrieveParams | null | undefined = {},
    options?: RequestOptions,
): APIPromise&amp;lt;ModelInfo&amp;gt;
/**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   */
list(
    params: ModelListParams | null | undefined = {},
    options?: RequestOptions,
): PagePromise&amp;lt;ModelInfosPage, ModelInfo&amp;gt;
⋮----
export type ModelInfosPage = Page&amp;lt;ModelInfo&amp;gt;;
export interface ModelInfo {
  /**
   * Unique model identifier.
   */
  id: string;
  /**
   * RFC 3339 datetime string representing the time at which the model was released.
   * May be set to an epoch value if the release date is unknown.
   */
  created_at: string;
  /**
   * A human-readable name for the model.
   */
  display_name: string;
  /**
   * Object type.
   *
   * For Models, this is always `&amp;quot;model&amp;quot;`.
   */
  type: &amp;apos;model&amp;apos;;
}
⋮----
/**
   * Unique model identifier.
   */
⋮----
/**
   * RFC 3339 datetime string representing the time at which the model was released.
   * May be set to an epoch value if the release date is unknown.
   */
⋮----
/**
   * A human-readable name for the model.
   */
⋮----
/**
   * Object type.
   *
   * For Models, this is always `&amp;quot;model&amp;quot;`.
   */
⋮----
export interface ModelRetrieveParams {
  /**
   * Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Optional header to specify the beta version(s) you want to use.
   */
⋮----
export interface ModelListParams extends PageParams {
  /**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */
  betas?: Array&amp;lt;BetaAPI.AnthropicBeta&amp;gt;;
}
⋮----
/**
   * Header param: Optional header to specify the beta version(s) you want to use.
   */&lt;/file&gt;&lt;file path=&quot;src/resources/shared.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
export interface APIErrorObject {
  message: string;
  type: &amp;apos;api_error&amp;apos;;
}
export interface AuthenticationError {
  message: string;
  type: &amp;apos;authentication_error&amp;apos;;
}
export interface BillingError {
  message: string;
  type: &amp;apos;billing_error&amp;apos;;
}
export type ErrorObject =
  | InvalidRequestError
  | AuthenticationError
  | BillingError
  | PermissionError
  | NotFoundError
  | RateLimitError
  | GatewayTimeoutError
  | APIErrorObject
  | OverloadedError;
export interface ErrorResponse {
  error: ErrorObject;
  type: &amp;apos;error&amp;apos;;
}
export interface GatewayTimeoutError {
  message: string;
  type: &amp;apos;timeout_error&amp;apos;;
}
export interface InvalidRequestError {
  message: string;
  type: &amp;apos;invalid_request_error&amp;apos;;
}
export interface NotFoundError {
  message: string;
  type: &amp;apos;not_found_error&amp;apos;;
}
export interface OverloadedError {
  message: string;
  type: &amp;apos;overloaded_error&amp;apos;;
}
export interface PermissionError {
  message: string;
  type: &amp;apos;permission_error&amp;apos;;
}
export interface RateLimitError {
  message: string;
  type: &amp;apos;rate_limit_error&amp;apos;;
}&lt;/file&gt;&lt;file path=&quot;src/resources/top-level.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/api-promise.ts&quot;&gt;/** @deprecated Import from ./core/api-promise instead */&lt;/file&gt;&lt;file path=&quot;src/client.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import type { RequestInit, RequestInfo, BodyInit } from &amp;apos;./internal/builtin-types&amp;apos;;
import type { HTTPMethod, PromiseOrValue, MergedRequestInit, FinalizedRequestInit } from &amp;apos;./internal/types&amp;apos;;
import { uuid4 } from &amp;apos;./internal/utils/uuid&amp;apos;;
import { validatePositiveInteger, isAbsoluteURL, safeJSON } from &amp;apos;./internal/utils/values&amp;apos;;
import { sleep } from &amp;apos;./internal/utils/sleep&amp;apos;;
import { type Logger, type LogLevel, parseLogLevel } from &amp;apos;./internal/utils/log&amp;apos;;
⋮----
import { castToError, isAbortError } from &amp;apos;./internal/errors&amp;apos;;
import type { APIResponseProps } from &amp;apos;./internal/parse&amp;apos;;
import { getPlatformHeaders } from &amp;apos;./internal/detect-platform&amp;apos;;
⋮----
import { VERSION } from &amp;apos;./version&amp;apos;;
⋮----
import { type PageParams, PageResponse } from &amp;apos;./core/pagination&amp;apos;;
⋮----
import { APIPromise } from &amp;apos;./core/api-promise&amp;apos;;
import { type Fetch } from &amp;apos;./internal/builtin-types&amp;apos;;
import { isRunningInBrowser } from &amp;apos;./internal/detect-platform&amp;apos;;
import { HeadersLike, NullableHeaders, buildHeaders } from &amp;apos;./internal/headers&amp;apos;;
import { FinalRequestOptions, RequestOptions } from &amp;apos;./internal/request-options&amp;apos;;
import {
  Completion,
  CompletionCreateParams,
  CompletionCreateParamsNonStreaming,
  CompletionCreateParamsStreaming,
  Completions,
} from &amp;apos;./resources/completions&amp;apos;;
import { ModelInfo, ModelInfosPage, ModelListParams, ModelRetrieveParams, Models } from &amp;apos;./resources/models&amp;apos;;
import { readEnv } from &amp;apos;./internal/utils/env&amp;apos;;
import { formatRequestDetails, loggerFor } from &amp;apos;./internal/utils/log&amp;apos;;
import { isEmptyObj } from &amp;apos;./internal/utils/values&amp;apos;;
import {
  AnthropicBeta,
  Beta,
  BetaAPIError,
  BetaAuthenticationError,
  BetaBillingError,
  BetaError,
  BetaErrorResponse,
  BetaGatewayTimeoutError,
  BetaInvalidRequestError,
  BetaNotFoundError,
  BetaOverloadedError,
  BetaPermissionError,
  BetaRateLimitError,
} from &amp;apos;./resources/beta/beta&amp;apos;;
import {
  Base64ImageSource,
  Base64PDFSource,
  CacheControlEphemeral,
  CitationCharLocation,
  CitationCharLocationParam,
  CitationContentBlockLocation,
  CitationContentBlockLocationParam,
  CitationPageLocation,
  CitationPageLocationParam,
  CitationWebSearchResultLocationParam,
  CitationsConfigParam,
  CitationsDelta,
  CitationsWebSearchResultLocation,
  ContentBlock,
  ContentBlockDeltaEvent,
  ContentBlockParam,
  ContentBlockStartEvent,
  ContentBlockStopEvent,
  ContentBlockSource,
  ContentBlockSourceContent,
  DocumentBlockParam,
  ImageBlockParam,
  InputJSONDelta,
  Message,
  MessageStreamParams,
  MessageCountTokensParams,
  MessageCountTokensTool,
  MessageCreateParams,
  MessageCreateParamsNonStreaming,
  MessageCreateParamsStreaming,
  MessageDeltaEvent,
  MessageDeltaUsage,
  MessageParam,
  MessageStartEvent,
  MessageStopEvent,
  MessageStreamEvent,
  MessageTokensCount,
  Messages,
  Metadata,
  Model,
  PlainTextSource,
  RawContentBlockDelta,
  RawContentBlockDeltaEvent,
  RawContentBlockStartEvent,
  RawContentBlockStopEvent,
  RawMessageDeltaEvent,
  RawMessageStartEvent,
  RawMessageStopEvent,
  RawMessageStreamEvent,
  RedactedThinkingBlock,
  RedactedThinkingBlockParam,
  ServerToolUsage,
  ServerToolUseBlock,
  ServerToolUseBlockParam,
  SignatureDelta,
  StopReason,
  TextBlock,
  TextBlockParam,
  TextCitation,
  TextCitationParam,
  TextDelta,
  ThinkingBlock,
  ThinkingBlockParam,
  ThinkingConfigDisabled,
  ThinkingConfigEnabled,
  ThinkingConfigParam,
  ThinkingDelta,
  Tool,
  ToolBash20250124,
  ToolChoice,
  ToolChoiceAny,
  ToolChoiceAuto,
  ToolChoiceNone,
  ToolChoiceTool,
  ToolResultBlockParam,
  ToolTextEditor20250124,
  ToolUnion,
  ToolUseBlock,
  ToolUseBlockParam,
  URLImageSource,
  URLPDFSource,
  Usage,
  WebSearchResultBlock,
  WebSearchResultBlockParam,
  WebSearchTool20250305,
  WebSearchToolRequestError,
  WebSearchToolResultBlock,
  WebSearchToolResultBlockContent,
  WebSearchToolResultBlockParam,
  WebSearchToolResultBlockParamContent,
  WebSearchToolResultError,
} from &amp;apos;./resources/messages/messages&amp;apos;;
export interface ClientOptions {
  /**
   * Defaults to process.env[&amp;apos;ANTHROPIC_API_KEY&amp;apos;].
   */
  apiKey?: string | null | undefined;
  /**
   * Defaults to process.env[&amp;apos;ANTHROPIC_AUTH_TOKEN&amp;apos;].
   */
  authToken?: string | null | undefined;
  /**
   * Override the default base URL for the API, e.g., &amp;quot;https://api.example.com/v2/&amp;quot;
   *
   * Defaults to process.env[&amp;apos;ANTHROPIC_BASE_URL&amp;apos;].
   */
  baseURL?: string | null | undefined;
  /**
   * The maximum amount of time (in milliseconds) that the client should wait for a response
   * from the server before timing out a single request.
   *
   * Note that request timeouts are retried by default, so in a worst-case scenario you may wait
   * much longer than this timeout before the promise succeeds or fails.
   */
  timeout?: number | undefined;
  /**
   * Additional `RequestInit` options to be passed to `fetch` calls.
   * Properties will be overridden by per-request `fetchOptions`.
   */
  fetchOptions?: MergedRequestInit | undefined;
  /**
   * Specify a custom `fetch` function implementation.
   *
   * If not provided, we expect that `fetch` is defined globally.
   */
  fetch?: Fetch | undefined;
  /**
   * The maximum number of times that the client will retry a request in case of a
   * temporary failure, like a network error or a 5XX error from the server.
   *
   * @default 2
   */
  maxRetries?: number | undefined;
  /**
   * Default headers to include with every request to the API.
   *
   * These can be removed in individual requests by explicitly setting the
   * header to `null` in request options.
   */
  defaultHeaders?: HeadersLike | undefined;
  /**
   * Default query parameters to include with every request to the API.
   *
   * These can be removed in individual requests by explicitly setting the
   * param to `undefined` in request options.
   */
  defaultQuery?: Record&amp;lt;string, string | undefined&amp;gt; | undefined;
  /**
   * By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   * Only set this option to `true` if you understand the risks and have appropriate mitigations in place.
   */
  dangerouslyAllowBrowser?: boolean | undefined;
  /**
   * Set the log level.
   *
   * Defaults to process.env[&amp;apos;ANTHROPIC_LOG&amp;apos;] or &amp;apos;warn&amp;apos; if it isn&amp;apos;t set.
   */
  logLevel?: LogLevel | undefined;
  /**
   * Set the logger.
   *
   * Defaults to globalThis.console.
   */
  logger?: Logger | undefined;
}
⋮----
/**
   * Defaults to process.env[&amp;apos;ANTHROPIC_API_KEY&amp;apos;].
   */
⋮----
/**
   * Defaults to process.env[&amp;apos;ANTHROPIC_AUTH_TOKEN&amp;apos;].
   */
⋮----
/**
   * Override the default base URL for the API, e.g., &amp;quot;https://api.example.com/v2/&amp;quot;
   *
   * Defaults to process.env[&amp;apos;ANTHROPIC_BASE_URL&amp;apos;].
   */
⋮----
/**
   * The maximum amount of time (in milliseconds) that the client should wait for a response
   * from the server before timing out a single request.
   *
   * Note that request timeouts are retried by default, so in a worst-case scenario you may wait
   * much longer than this timeout before the promise succeeds or fails.
   */
⋮----
/**
   * Additional `RequestInit` options to be passed to `fetch` calls.
   * Properties will be overridden by per-request `fetchOptions`.
   */
⋮----
/**
   * Specify a custom `fetch` function implementation.
   *
   * If not provided, we expect that `fetch` is defined globally.
   */
⋮----
/**
   * The maximum number of times that the client will retry a request in case of a
   * temporary failure, like a network error or a 5XX error from the server.
   *
   * @default 2
   */
⋮----
/**
   * Default headers to include with every request to the API.
   *
   * These can be removed in individual requests by explicitly setting the
   * header to `null` in request options.
   */
⋮----
/**
   * Default query parameters to include with every request to the API.
   *
   * These can be removed in individual requests by explicitly setting the
   * param to `undefined` in request options.
   */
⋮----
/**
   * By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   * Only set this option to `true` if you understand the risks and have appropriate mitigations in place.
   */
⋮----
/**
   * Set the log level.
   *
   * Defaults to process.env[&amp;apos;ANTHROPIC_LOG&amp;apos;] or &amp;apos;warn&amp;apos; if it isn&amp;apos;t set.
   */
⋮----
/**
   * Set the logger.
   *
   * Defaults to globalThis.console.
   */
⋮----
export class BaseAnthropic
⋮----
/**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env[&amp;apos;ANTHROPIC_API_KEY&amp;apos;] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env[&amp;apos;ANTHROPIC_AUTH_TOKEN&amp;apos;] ?? null]
   * @param {string} [opts.baseURL=process.env[&amp;apos;ANTHROPIC_BASE_URL&amp;apos;] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record&amp;lt;string, string | undefined&amp;gt;} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
constructor({
    baseURL = readEnv(&amp;apos;ANTHROPIC_BASE_URL&amp;apos;),
    apiKey = readEnv(&amp;apos;ANTHROPIC_API_KEY&amp;apos;) ?? null,
    authToken = readEnv(&amp;apos;ANTHROPIC_AUTH_TOKEN&amp;apos;) ?? null,
    ...opts
}: ClientOptions =
⋮----
this.timeout = options.timeout ?? Anthropic.DEFAULT_TIMEOUT /* 10 minutes */;
⋮----
// Set default logLevel early so that we can log a warning in parseLogLevel.
⋮----
/**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
withOptions(options: Partial&amp;lt;ClientOptions&amp;gt;): this
protected defaultQuery(): Record&amp;lt;string, string | undefined&amp;gt; | undefined
protected validateHeaders(
protected authHeaders(opts: FinalRequestOptions): NullableHeaders | undefined
protected apiKeyAuth(opts: FinalRequestOptions): NullableHeaders | undefined
protected bearerAuth(opts: FinalRequestOptions): NullableHeaders | undefined
/**
   * Basic re-implementation of `qs.stringify` for primitive types.
   */
protected stringifyQuery(query: Record&amp;lt;string, unknown&amp;gt;): string
private getUserAgent(): string
protected defaultIdempotencyKey(): string
protected makeStatusError(
    status: number,
    error: Object,
    message: string | undefined,
    headers: Headers,
): Errors.APIError
buildURL(path: string, query: Record&amp;lt;string, unknown&amp;gt; | null | undefined): string
_calculateNonstreamingTimeout(maxTokens: number): number
/**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
protected async prepareOptions(options: FinalRequestOptions): Promise&amp;lt;void&amp;gt;
/**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
protected async prepareRequest(
get&amp;lt;Rsp&amp;gt;(path: string, opts?: PromiseOrValue&amp;lt;RequestOptions&amp;gt;): APIPromise&amp;lt;Rsp&amp;gt;
post&amp;lt;Rsp&amp;gt;(path: string, opts?: PromiseOrValue&amp;lt;RequestOptions&amp;gt;): APIPromise&amp;lt;Rsp&amp;gt;
patch&amp;lt;Rsp&amp;gt;(path: string, opts?: PromiseOrValue&amp;lt;RequestOptions&amp;gt;): APIPromise&amp;lt;Rsp&amp;gt;
put&amp;lt;Rsp&amp;gt;(path: string, opts?: PromiseOrValue&amp;lt;RequestOptions&amp;gt;): APIPromise&amp;lt;Rsp&amp;gt;
delete&amp;lt;Rsp&amp;gt;(path: string, opts?: PromiseOrValue&amp;lt;RequestOptions&amp;gt;): APIPromise&amp;lt;Rsp&amp;gt;
private methodRequest&amp;lt;Rsp&amp;gt;(
    method: HTTPMethod,
    path: string,
    opts?: PromiseOrValue&amp;lt;RequestOptions&amp;gt;,
): APIPromise&amp;lt;Rsp&amp;gt;
request&amp;lt;Rsp&amp;gt;(
    options: PromiseOrValue&amp;lt;FinalRequestOptions&amp;gt;,
    remainingRetries: number | null = null,
): APIPromise&amp;lt;Rsp&amp;gt;
private async makeRequest(
    optionsInput: PromiseOrValue&amp;lt;FinalRequestOptions&amp;gt;,
    retriesRemaining: number | null,
    retryOfRequestLogID: string | undefined,
): Promise&amp;lt;APIResponseProps&amp;gt;
⋮----
/** Not an API request ID, just for correlating local log entries. */
⋮----
// detect native connection timeout errors
// deno throws &amp;quot;TypeError: error sending request for url (https://example/): client error (Connect): tcp connect error: Operation timed out (os error 60): Operation timed out (os error 60)&amp;quot;
// undici throws &amp;quot;TypeError: fetch failed&amp;quot; with cause &amp;quot;ConnectTimeoutError: Connect Timeout Error (attempted address: example:443, timeout: 1ms)&amp;quot;
// others do not provide enough information to distinguish timeouts from other connection errors
⋮----
// We don&amp;apos;t need the body of this response.
⋮----
getAPIList&amp;lt;Item, PageClass extends Pagination.AbstractPage&amp;lt;Item&amp;gt; = Pagination.AbstractPage&amp;lt;Item&amp;gt;&amp;gt;(
    path: string,
    Page: new (...args: any[]) =&amp;gt; PageClass,
    opts?: RequestOptions,
): Pagination.PagePromise&amp;lt;PageClass, Item&amp;gt;
requestAPIList&amp;lt;
    Item = unknown,
    PageClass extends Pagination.AbstractPage&amp;lt;Item&amp;gt; = Pagination.AbstractPage&amp;lt;Item&amp;gt;,
  &amp;gt;(
    Page: new (...args: ConstructorParameters&amp;lt;typeof Pagination.AbstractPage&amp;gt;) =&amp;gt; PageClass,
    options: FinalRequestOptions,
): Pagination.PagePromise&amp;lt;PageClass, Item&amp;gt;
async fetchWithTimeout(
    url: RequestInfo,
    init: RequestInit | undefined,
    ms: number,
    controller: AbortController,
): Promise&amp;lt;Response&amp;gt;
⋮----
// Custom methods like &amp;apos;patch&amp;apos; need to be uppercased
// See https://github.com/nodejs/undici/issues/2294
⋮----
// use undefined this binding; fetch errors if bound to something else in browser/cloudflare
⋮----
private shouldRetry(response: Response): boolean
⋮----
// Note this is not a standard header.
⋮----
// If the server explicitly says whether or not to retry, obey.
⋮----
// Retry on request timeouts.
⋮----
// Retry on lock timeouts.
⋮----
// Retry on rate limits.
⋮----
// Retry internal errors.
⋮----
private async retryRequest(
    options: FinalRequestOptions,
    retriesRemaining: number,
    requestLogID: string,
    responseHeaders?: Headers | undefined,
): Promise&amp;lt;APIResponseProps&amp;gt;
⋮----
// Note the `retry-after-ms` header may not be standard, but is a good idea and we&amp;apos;d like proactive support for it.
⋮----
// About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
⋮----
// If the API asks us to wait a certain amount of time (and it&amp;apos;s a reasonable amount),
// just do what it says, but otherwise calculate a default
⋮----
private calculateDefaultRetryTimeoutMillis(retriesRemaining: number, maxRetries: number): number
⋮----
// Apply exponential backoff, but not more than the max.
⋮----
// Apply some jitter, take up to at most 25 percent of the retry time.
⋮----
public calculateNonstreamingTimeout(maxTokens: number, maxNonstreamingTokens?: number): number
⋮----
const maxTime = 60 * 60 * 1000; // 10 minutes
const defaultTime = 60 * 10 * 1000; // 10 minutes
⋮----
buildRequest(
    inputOptions: FinalRequestOptions,
    { retryCount = 0 }: { retryCount?: number } = {},
):
private buildHeaders({
    options,
    method,
    bodyHeaders,
    retryCount,
  }: {
    options: FinalRequestOptions;
    method: HTTPMethod;
    bodyHeaders: HeadersLike;
    retryCount: number;
}): Headers
private buildBody(
⋮----
// Pass raw type verbatim
⋮----
// Preserve legacy string encoding behavior for now
⋮----
// `Blob` is superset of `File`
⋮----
// `FormData` -&amp;gt; `multipart/form-data`
⋮----
// `URLSearchParams` -&amp;gt; `application/x-www-form-urlencoded`
⋮----
// Send chunked stream (each chunk has own `length`)
⋮----
static DEFAULT_TIMEOUT = 600000; // 10 minutes
⋮----
/**
 * API Client for interfacing with the Anthropic API.
 */
export class Anthropic extends BaseAnthropic
⋮----
export type RequestOptions = Opts.RequestOptions;
⋮----
export type APIErrorObject = API.APIErrorObject;
export type AuthenticationError = API.AuthenticationError;
export type BillingError = API.BillingError;
export type ErrorObject = API.ErrorObject;
export type ErrorResponse = API.ErrorResponse;
export type GatewayTimeoutError = API.GatewayTimeoutError;
export type InvalidRequestError = API.InvalidRequestError;
export type NotFoundError = API.NotFoundError;
export type OverloadedError = API.OverloadedError;
export type PermissionError = API.PermissionError;
export type RateLimitError = API.RateLimitError;&lt;/file&gt;&lt;file path=&quot;src/error.ts&quot;&gt;/** @deprecated Import from ./core/error instead */&lt;/file&gt;&lt;file path=&quot;src/index.ts&quot;&gt;// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.&lt;/file&gt;&lt;file path=&quot;src/pagination.ts&quot;&gt;/** @deprecated Import from ./core/pagination instead */&lt;/file&gt;&lt;file path=&quot;src/resource.ts&quot;&gt;/** @deprecated Import from ./core/resource instead */&lt;/file&gt;&lt;file path=&quot;src/resources.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;src/streaming.ts&quot;&gt;/** @deprecated Import from ./core/streaming instead */&lt;/file&gt;&lt;file path=&quot;src/uploads.ts&quot;&gt;/** @deprecated Import from ./core/uploads instead */&lt;/file&gt;&lt;file path=&quot;src/version.ts&quot;&gt;export const VERSION = &amp;apos;0.52.0&amp;apos;; // x-release-please-version&lt;/file&gt;&lt;file path=&quot;api.md&quot;&gt;# Anthropic
# Shared
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;APIErrorObject&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;AuthenticationError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;BillingError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;ErrorObject&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;ErrorResponse&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;GatewayTimeoutError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;InvalidRequestError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;NotFoundError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;OverloadedError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;PermissionError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/shared.ts&amp;quot;&amp;gt;RateLimitError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
# Messages
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;Base64ImageSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;Base64PDFSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CacheControlEphemeral&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationCharLocation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationCharLocationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationContentBlockLocation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationContentBlockLocationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationPageLocation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationPageLocationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationWebSearchResultLocationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationsConfigParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationsDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;CitationsWebSearchResultLocation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlockSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlockSourceContent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlockStartEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlockStopEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;DocumentBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ImageBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;InputJSONDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;Message&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageCountTokensTool&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageDeltaEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageDeltaUsage&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageTokensCount&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;Metadata&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;Model&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;PlainTextSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RawContentBlockDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RawContentBlockDeltaEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RawContentBlockStartEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RawContentBlockStopEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RawMessageDeltaEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RawMessageStartEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RawMessageStopEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RawMessageStreamEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RedactedThinkingBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;RedactedThinkingBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ServerToolUsage&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ServerToolUseBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ServerToolUseBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;SignatureDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;StopReason&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;TextBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;TextBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;TextCitation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;TextCitationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;TextDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ThinkingBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ThinkingBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ThinkingConfigDisabled&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ThinkingConfigEnabled&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ThinkingConfigParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ThinkingDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;Tool&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolBash20250124&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolChoice&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolChoiceAny&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolChoiceAuto&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolChoiceNone&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolChoiceTool&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolTextEditor20250124&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolUnion&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolUseBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ToolUseBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;URLImageSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;URLPDFSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;Usage&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchResultBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchTool20250305&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchToolRequestError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchToolResultBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchToolResultBlockContent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchToolResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchToolResultBlockParamContent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;WebSearchToolResultError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageStreamEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageStartEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageDeltaEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;MessageStopEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlockStartEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlockDeltaEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;ContentBlockStopEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
Methods:
- &amp;lt;code title=&amp;quot;post /v1/messages&amp;quot;&amp;gt;client.messages.&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;create&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; Message&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;post /v1/messages/count_tokens&amp;quot;&amp;gt;client.messages.&amp;lt;a href=&amp;quot;./src/resources/messages/messages.ts&amp;quot;&amp;gt;countTokens&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; MessageTokensCount&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;client.messages.&amp;lt;a href=&amp;quot;./src/resources/messages.ts&amp;quot;&amp;gt;stream&amp;lt;/a&amp;gt;(body, options?) -&amp;gt; MessageStream&amp;lt;/code&amp;gt;
## Batches
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;DeletedMessageBatch&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;MessageBatch&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;MessageBatchCanceledResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;MessageBatchErroredResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;MessageBatchExpiredResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;MessageBatchIndividualResponse&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;MessageBatchRequestCounts&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;MessageBatchResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;MessageBatchSucceededResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
Methods:
- &amp;lt;code title=&amp;quot;post /v1/messages/batches&amp;quot;&amp;gt;client.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;create&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; MessageBatch&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/messages/batches/{message_batch_id}&amp;quot;&amp;gt;client.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;retrieve&amp;lt;/a&amp;gt;(messageBatchID) -&amp;gt; MessageBatch&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/messages/batches&amp;quot;&amp;gt;client.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;list&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; MessageBatchesPage&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;delete /v1/messages/batches/{message_batch_id}&amp;quot;&amp;gt;client.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;delete&amp;lt;/a&amp;gt;(messageBatchID) -&amp;gt; DeletedMessageBatch&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;post /v1/messages/batches/{message_batch_id}/cancel&amp;quot;&amp;gt;client.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;cancel&amp;lt;/a&amp;gt;(messageBatchID) -&amp;gt; MessageBatch&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/messages/batches/{message_batch_id}/results&amp;quot;&amp;gt;client.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/messages/batches.ts&amp;quot;&amp;gt;results&amp;lt;/a&amp;gt;(messageBatchID) -&amp;gt; MessageBatchIndividualResponse&amp;lt;/code&amp;gt;
# Models
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/models.ts&amp;quot;&amp;gt;ModelInfo&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
Methods:
- &amp;lt;code title=&amp;quot;get /v1/models/{model_id}&amp;quot;&amp;gt;client.models.&amp;lt;a href=&amp;quot;./src/resources/models.ts&amp;quot;&amp;gt;retrieve&amp;lt;/a&amp;gt;(modelID, { ...params }) -&amp;gt; ModelInfo&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/models&amp;quot;&amp;gt;client.models.&amp;lt;a href=&amp;quot;./src/resources/models.ts&amp;quot;&amp;gt;list&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; ModelInfosPage&amp;lt;/code&amp;gt;
# Beta
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;AnthropicBeta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaAPIError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaAuthenticationError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaBillingError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaErrorResponse&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaGatewayTimeoutError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaInvalidRequestError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaNotFoundError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaOverloadedError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaPermissionError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/beta.ts&amp;quot;&amp;gt;BetaRateLimitError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
## Models
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/models.ts&amp;quot;&amp;gt;BetaModelInfo&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
Methods:
- &amp;lt;code title=&amp;quot;get /v1/models/{model_id}?beta=true&amp;quot;&amp;gt;client.beta.models.&amp;lt;a href=&amp;quot;./src/resources/beta/models.ts&amp;quot;&amp;gt;retrieve&amp;lt;/a&amp;gt;(modelID, { ...params }) -&amp;gt; BetaModelInfo&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/models?beta=true&amp;quot;&amp;gt;client.beta.models.&amp;lt;a href=&amp;quot;./src/resources/beta/models.ts&amp;quot;&amp;gt;list&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; BetaModelInfosPage&amp;lt;/code&amp;gt;
## Messages
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaBase64ImageSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaBase64PDFBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaBase64PDFSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCacheControlEphemeral&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCacheCreation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationCharLocation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationCharLocationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationContentBlockLocation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationContentBlockLocationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationPageLocation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationPageLocationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationWebSearchResultLocationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationsConfigParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationsDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCitationsWebSearchResultLocation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionOutputBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionOutputBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionResultBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionTool20250522&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionToolResultBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionToolResultBlockContent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionToolResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionToolResultBlockParamContent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionToolResultError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionToolResultErrorCode&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaCodeExecutionToolResultErrorParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaContainer&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaContainerUploadBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaContainerUploadBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaContentBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaContentBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaContentBlockSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaContentBlockSourceContent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaFileDocumentSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaFileImageSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaImageBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaInputJSONDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaMCPToolResultBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaMCPToolUseBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaMCPToolUseBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaMessage&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaMessageDeltaUsage&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaMessageParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaMessageTokensCount&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaMetadata&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaPlainTextSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRawContentBlockDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRawContentBlockDeltaEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRawContentBlockStartEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRawContentBlockStopEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRawMessageDeltaEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRawMessageStartEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRawMessageStopEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRawMessageStreamEvent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRedactedThinkingBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRedactedThinkingBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRequestMCPServerToolConfiguration&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRequestMCPServerURLDefinition&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaRequestMCPToolResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaServerToolUsage&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaServerToolUseBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaServerToolUseBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaSignatureDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaStopReason&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaTextBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaTextBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaTextCitation&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaTextCitationParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaTextDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaThinkingBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaThinkingBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaThinkingConfigDisabled&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaThinkingConfigEnabled&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaThinkingConfigParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaThinkingDelta&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaTool&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolBash20241022&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolBash20250124&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolChoice&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolChoiceAny&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolChoiceAuto&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolChoiceNone&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolChoiceTool&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolComputerUse20241022&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolComputerUse20250124&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolTextEditor20241022&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolTextEditor20250124&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolTextEditor20250429&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolUnion&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolUseBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaToolUseBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaURLImageSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaURLPDFSource&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaUsage&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchResultBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchTool20250305&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchToolRequestError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchToolResultBlock&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchToolResultBlockContent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchToolResultBlockParam&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchToolResultBlockParamContent&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchToolResultError&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;BetaWebSearchToolResultErrorCode&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
Methods:
- &amp;lt;code title=&amp;quot;post /v1/messages?beta=true&amp;quot;&amp;gt;client.beta.messages.&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;create&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; BetaMessage&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;post /v1/messages/count_tokens?beta=true&amp;quot;&amp;gt;client.beta.messages.&amp;lt;a href=&amp;quot;./src/resources/beta/messages/messages.ts&amp;quot;&amp;gt;countTokens&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; BetaMessageTokensCount&amp;lt;/code&amp;gt;
### Batches
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaDeletedMessageBatch&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaMessageBatch&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaMessageBatchCanceledResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaMessageBatchErroredResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaMessageBatchExpiredResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaMessageBatchIndividualResponse&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaMessageBatchRequestCounts&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaMessageBatchResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;BetaMessageBatchSucceededResult&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
Methods:
- &amp;lt;code title=&amp;quot;post /v1/messages/batches?beta=true&amp;quot;&amp;gt;client.beta.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;create&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; BetaMessageBatch&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/messages/batches/{message_batch_id}?beta=true&amp;quot;&amp;gt;client.beta.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;retrieve&amp;lt;/a&amp;gt;(messageBatchID, { ...params }) -&amp;gt; BetaMessageBatch&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/messages/batches?beta=true&amp;quot;&amp;gt;client.beta.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;list&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; BetaMessageBatchesPage&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;delete /v1/messages/batches/{message_batch_id}?beta=true&amp;quot;&amp;gt;client.beta.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;delete&amp;lt;/a&amp;gt;(messageBatchID, { ...params }) -&amp;gt; BetaDeletedMessageBatch&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;post /v1/messages/batches/{message_batch_id}/cancel?beta=true&amp;quot;&amp;gt;client.beta.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;cancel&amp;lt;/a&amp;gt;(messageBatchID, { ...params }) -&amp;gt; BetaMessageBatch&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/messages/batches/{message_batch_id}/results?beta=true&amp;quot;&amp;gt;client.beta.messages.batches.&amp;lt;a href=&amp;quot;./src/resources/beta/messages/batches.ts&amp;quot;&amp;gt;results&amp;lt;/a&amp;gt;(messageBatchID, { ...params }) -&amp;gt; BetaMessageBatchIndividualResponse&amp;lt;/code&amp;gt;
## Files
Types:
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/files.ts&amp;quot;&amp;gt;DeletedFile&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
- &amp;lt;code&amp;gt;&amp;lt;a href=&amp;quot;./src/resources/beta/files.ts&amp;quot;&amp;gt;FileMetadata&amp;lt;/a&amp;gt;&amp;lt;/code&amp;gt;
Methods:
- &amp;lt;code title=&amp;quot;get /v1/files?beta=true&amp;quot;&amp;gt;client.beta.files.&amp;lt;a href=&amp;quot;./src/resources/beta/files.ts&amp;quot;&amp;gt;list&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; FileMetadataPage&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;delete /v1/files/{file_id}?beta=true&amp;quot;&amp;gt;client.beta.files.&amp;lt;a href=&amp;quot;./src/resources/beta/files.ts&amp;quot;&amp;gt;delete&amp;lt;/a&amp;gt;(fileID, { ...params }) -&amp;gt; DeletedFile&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/files/{file_id}/content?beta=true&amp;quot;&amp;gt;client.beta.files.&amp;lt;a href=&amp;quot;./src/resources/beta/files.ts&amp;quot;&amp;gt;download&amp;lt;/a&amp;gt;(fileID, { ...params }) -&amp;gt; Response&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;get /v1/files/{file_id}?beta=true&amp;quot;&amp;gt;client.beta.files.&amp;lt;a href=&amp;quot;./src/resources/beta/files.ts&amp;quot;&amp;gt;retrieveMetadata&amp;lt;/a&amp;gt;(fileID, { ...params }) -&amp;gt; FileMetadata&amp;lt;/code&amp;gt;
- &amp;lt;code title=&amp;quot;post /v1/files?beta=true&amp;quot;&amp;gt;client.beta.files.&amp;lt;a href=&amp;quot;./src/resources/beta/files.ts&amp;quot;&amp;gt;upload&amp;lt;/a&amp;gt;({ ...params }) -&amp;gt; FileMetadata&amp;lt;/code&amp;gt;&lt;/file&gt;&lt;file path=&quot;README.md&quot;&gt;# Anthropic TypeScript API Library
[![NPM version](https://img.shields.io/npm/v/@anthropic-ai/sdk.svg)](https://npmjs.org/package/@anthropic-ai/sdk) ![npm bundle size](https://img.shields.io/bundlephobia/minzip/@anthropic-ai/sdk)
This library provides convenient access to the Anthropic REST API from server-side TypeScript or JavaScript.
The REST API documentation can be found on [docs.anthropic.com](https://docs.anthropic.com/claude/reference/). The full API of this library can be found in [api.md](api.md).
## Installation
```sh
npm install @anthropic-ai/sdk
```
## Usage
The full API of this library can be found in [api.md](api.md).
&amp;lt;!-- prettier-ignore --&amp;gt;
```js
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic({
  apiKey: process.env[&amp;apos;ANTHROPIC_API_KEY&amp;apos;], // This is the default and can be omitted
});
async function main() {
  const message = await client.messages.create({
    max_tokens: 1024,
    messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }],
    model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
  });
  console.log(message.content);
}
main();
```
## Streaming responses
We provide support for streaming responses using Server Sent Events (SSE).
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic();
const stream = await client.messages.create({
  max_tokens: 1024,
  messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }],
  model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
  stream: true,
});
for await (const messageStreamEvent of stream) {
  console.log(messageStreamEvent.type);
}
```
If you need to cancel a stream, you can `break` from the loop
or call `stream.controller.abort()`.
### Request &amp;amp; Response types
This library includes TypeScript definitions for all request params and response fields. You may import and use them like so:
&amp;lt;!-- prettier-ignore --&amp;gt;
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic({
  apiKey: process.env[&amp;apos;ANTHROPIC_API_KEY&amp;apos;], // This is the default and can be omitted
});
async function main() {
  const params: Anthropic.MessageCreateParams = {
    max_tokens: 1024,
    messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }],
    model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
  };
  const message: Anthropic.Message = await client.messages.create(params);
}
main();
```
Documentation for each method, request param, and response field are available in docstrings and will appear on hover in most modern editors.
## Counting Tokens
You can see the exact usage for a given request through the `usage` response property, e.g.
```ts
const message = await client.messages.create(...)
console.log(message.usage)
// { input_tokens: 25, output_tokens: 13 }
```
## Streaming Helpers
This library provides several conveniences for streaming messages, for example:
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const anthropic = new Anthropic();
async function main() {
  const stream = anthropic.messages
    .stream({
      model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
      max_tokens: 1024,
      messages: [
        {
          role: &amp;apos;user&amp;apos;,
          content: &amp;apos;Say hello there!&amp;apos;,
        },
      ],
    })
    .on(&amp;apos;text&amp;apos;, (text) =&amp;gt; {
      console.log(text);
    });
  const message = await stream.finalMessage();
  console.log(message);
}
main();
```
Streaming with `client.messages.stream(...)` exposes [various helpers for your convenience](helpers.md) including event handlers and accumulation.
Alternatively, you can use `client.messages.create({ ..., stream: true })` which only returns an async iterable of the events in the stream and thus uses less memory (it does not build up a final message object for you).
## Message Batches
This SDK provides beta support for the [Message Batches API](https://docs.anthropic.com/en/docs/build-with-claude/message-batches) under the `client.beta.messages.batches` namespace.
### Creating a batch
Message Batches takes an array of requests, where each object has a `custom_id` identifier, and the exact same request `params` as the standard Messages API:
```ts
await anthropic.beta.messages.batches.create({
  requests: [
    {
      custom_id: &amp;apos;my-first-request&amp;apos;,
      params: {
        model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
        max_tokens: 1024,
        messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, world&amp;apos; }],
      },
    },
    {
      custom_id: &amp;apos;my-second-request&amp;apos;,
      params: {
        model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
        max_tokens: 1024,
        messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hi again, friend&amp;apos; }],
      },
    },
  ],
});
```
### Getting results from a batch
Once a Message Batch has been processed, indicated by `.processing_status === &amp;apos;ended&amp;apos;`, you can access the results with `.batches.results()`
```ts
const results = await anthropic.beta.messages.batches.results(batch_id);
for await (const entry of results) {
  if (entry.result.type === &amp;apos;succeeded&amp;apos;) {
    console.log(entry.result.message.content);
  }
}
```
## Tool use
This SDK provides support for tool use, aka function calling. More details can be found in [the documentation](https://docs.anthropic.com/claude/docs/tool-use).
## AWS Bedrock
We provide support for the [Anthropic Bedrock API](https://aws.amazon.com/bedrock/claude/) through a [separate package](https://github.com/anthropics/anthropic-sdk-typescript/tree/main/packages/bedrock-sdk).
## File uploads
Request parameters that correspond to file uploads can be passed in many different forms:
- `File` (or an object with the same structure)
- a `fetch` `Response` (or an object with the same structure)
- an `fs.ReadStream`
- the return value of our `toFile` helper
Note that we recommend you set the content-type explicitly as the files API will not infer it for you:
```ts
import fs from &amp;apos;fs&amp;apos;;
import Anthropic, { toFile } from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic();
// If you have access to Node `fs` we recommend using `fs.createReadStream()`:
await client.beta.files.upload({
  file: await toFile(fs.createReadStream(&amp;apos;/path/to/file&amp;apos;), undefined, { type: &amp;apos;application/json&amp;apos; }),
  betas: [&amp;apos;files-api-2025-04-14&amp;apos;],
});
// Or if you have the web `File` API you can pass a `File` instance:
await client.beta.files.upload({
  file: new File([&amp;apos;my bytes&amp;apos;], &amp;apos;file.txt&amp;apos;, { type: &amp;apos;text/plain&amp;apos; }),
  betas: [&amp;apos;files-api-2025-04-14&amp;apos;],
});
// You can also pass a `fetch` `Response`:
await client.beta.files.upload({
  file: await fetch(&amp;apos;https://somesite/file&amp;apos;),
  betas: [&amp;apos;files-api-2025-04-14&amp;apos;],
});
// Or a `Buffer` / `Uint8Array`
await client.beta.files.upload({
  file: await toFile(Buffer.from(&amp;apos;my bytes&amp;apos;), &amp;apos;file&amp;apos;, { type: &amp;apos;text/plain&amp;apos; }),
  betas: [&amp;apos;files-api-2025-04-14&amp;apos;],
});
await client.beta.files.upload({
  file: await toFile(new Uint8Array([0, 1, 2]), &amp;apos;file&amp;apos;, { type: &amp;apos;text/plain&amp;apos; }),
  betas: [&amp;apos;files-api-2025-04-14&amp;apos;],
});
```
## Handling errors
When the library is unable to connect to the API,
or if the API returns a non-success status code (i.e., 4xx or 5xx response),
a subclass of `APIError` will be thrown:
&amp;lt;!-- prettier-ignore --&amp;gt;
```ts
async function main() {
  const message = await client.messages
    .create({
      max_tokens: 1024,
      messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }],
      model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
    })
    .catch(async (err) =&amp;gt; {
      if (err instanceof Anthropic.APIError) {
        console.log(err.status); // 400
        console.log(err.name); // BadRequestError
        console.log(err.headers); // {server: &amp;apos;nginx&amp;apos;, ...}
      } else {
        throw err;
      }
    });
}
main();
```
Error codes are as follows:
| Status Code | Error Type                 |
| ----------- | -------------------------- |
| 400         | `BadRequestError`          |
| 401         | `AuthenticationError`      |
| 403         | `PermissionDeniedError`    |
| 404         | `NotFoundError`            |
| 422         | `UnprocessableEntityError` |
| 429         | `RateLimitError`           |
| &amp;gt;=500       | `InternalServerError`      |
| N/A         | `APIConnectionError`       |
## Request IDs
&amp;gt; For more information on debugging requests, see [these docs](https://docs.anthropic.com/en/api/errors#request-id)
All object responses in the SDK provide a `_request_id` property which is added from the `request-id` response header so that you can quickly log failing requests and report them back to Anthropic.
```ts
const message = await client.messages.create({
  max_tokens: 1024,
  messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }],
  model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
});
console.log(message._request_id); // req_018EeWyXxfu5pfWkrYcMdjWG
```
### Retries
Certain errors will be automatically retried 2 times by default, with a short exponential backoff.
Connection errors (for example, due to a network connectivity problem), 408 Request Timeout, 409 Conflict,
429 Rate Limit, and &amp;gt;=500 Internal errors will all be retried by default.
You can use the `maxRetries` option to configure or disable this:
&amp;lt;!-- prettier-ignore --&amp;gt;
```js
// Configure the default for all requests:
const client = new Anthropic({
  maxRetries: 0, // default is 2
});
// Or, configure per-request:
await client.messages.create({ max_tokens: 1024, messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }], model: &amp;apos;claude-3-5-sonnet-latest&amp;apos; }, {
  maxRetries: 5,
});
```
### Timeouts
By default requests time out after 10 minutes. However if you have specified a large `max_tokens` value and are
_not_ streaming, the default timeout will be calculated dynamically using the formula:
```typescript
const minimum = 10 * 60;
const calculated = (60 * 60 * maxTokens) / 128_000;
return calculated &amp;lt; minimum ? minimum * 1000 : calculated * 1000;
```
which will result in a timeout up to 60 minutes, scaled by the `max_tokens` parameter, unless overriden at the request or client level.
You can configure this with a `timeout` option:
&amp;lt;!-- prettier-ignore --&amp;gt;
```ts
// Configure the default for all requests:
const client = new Anthropic({
  timeout: 20 * 1000, // 20 seconds (default is 10 minutes)
});
// Override per-request:
await client.messages.create({ max_tokens: 1024, messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }], model: &amp;apos;claude-3-5-sonnet-latest&amp;apos; }, {
  timeout: 5 * 1000,
});
```
On timeout, an `APIConnectionTimeoutError` is thrown.
Note that requests which time out will be [retried twice by default](#retries).
### Long Requests
&amp;gt; [!IMPORTANT]
&amp;gt; We highly encourage you use the streaming [Messages API](#streaming-responses) for longer running requests.
We do not recommend setting a large `max_tokens` values without using streaming.
Some networks may drop idle connections after a certain period of time, which
can cause the request to fail or [timeout](#timeouts) without receiving a response from Anthropic.
This SDK will also throw an error if a non-streaming request is expected to be above roughly 10 minutes long.
Passing `stream: true` or [overriding](#timeouts) the `timeout` option at the client or request level disables this error.
An expected request latency longer than the [timeout](#timeouts) for a non-streaming request
will result in the client terminating the connection and retrying without receiving a response.
When supported by the `fetch` implementation, we set a [TCP socket keep-alive](https://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html) option in order
to reduce the impact of idle connection timeouts on some networks.
This can be [overriden](#configuring-an-https-agent-eg-for-proxies) by configuring a custom proxy.
## Auto-pagination
List methods in the Anthropic API are paginated.
You can use the `for await … of` syntax to iterate through items across all pages:
```ts
async function fetchAllBetaMessagesBatches(params) {
  const allBetaMessagesBatches = [];
  // Automatically fetches more pages as needed.
  for await (const betaMessageBatch of client.beta.messages.batches.list({ limit: 20 })) {
    allBetaMessagesBatches.push(betaMessageBatch);
  }
  return allBetaMessagesBatches;
}
```
Alternatively, you can request a single page at a time:
```ts
let page = await client.beta.messages.batches.list({ limit: 20 });
for (const betaMessageBatch of page.data) {
  console.log(betaMessageBatch);
}
// Convenience methods are provided for manually paginating:
while (page.hasNextPage()) {
  page = await page.getNextPage();
  // ...
}
```
## Default Headers
We automatically send the `anthropic-version` header set to `2023-06-01`.
If you need to, you can override it by setting default headers on a per-request basis.
Be aware that doing so may result in incorrect types and other unexpected or undefined behavior in the SDK.
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic();
const message = await client.messages.create(
  {
    max_tokens: 1024,
    messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }],
    model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
  },
  { headers: { &amp;apos;anthropic-version&amp;apos;: &amp;apos;My-Custom-Value&amp;apos; } },
);
```
## Advanced Usage
### Accessing raw Response data (e.g., headers)
The &amp;quot;raw&amp;quot; `Response` returned by `fetch()` can be accessed through the `.asResponse()` method on the `APIPromise` type that all methods return.
This method returns as soon as the headers for a successful response are received and does not consume the response body, so you are free to write custom parsing or streaming logic.
You can also use the `.withResponse()` method to get the raw `Response` along with the parsed data.
Unlike `.asResponse()` this method consumes the body, returning once it is parsed.
&amp;lt;!-- prettier-ignore --&amp;gt;
```ts
const client = new Anthropic();
const response = await client.messages
  .create({
    max_tokens: 1024,
    messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }],
    model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
  })
  .asResponse();
console.log(response.headers.get(&amp;apos;X-My-Header&amp;apos;));
console.log(response.statusText); // access the underlying Response object
const { data: message, response: raw } = await client.messages
  .create({
    max_tokens: 1024,
    messages: [{ role: &amp;apos;user&amp;apos;, content: &amp;apos;Hello, Claude&amp;apos; }],
    model: &amp;apos;claude-3-5-sonnet-latest&amp;apos;,
  })
  .withResponse();
console.log(raw.headers.get(&amp;apos;X-My-Header&amp;apos;));
console.log(message.content);
```
### Logging
&amp;gt; [!IMPORTANT]
&amp;gt; All log messages are intended for debugging only. The format and content of log messages
&amp;gt; may change between releases.
#### Log levels
The log level can be configured in two ways:
1. Via the `ANTHROPIC_LOG` environment variable
2. Using the `logLevel` client option (overrides the environment variable if set)
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic({
  logLevel: &amp;apos;debug&amp;apos;, // Show all log messages
});
```
Available log levels, from most to least verbose:
- `&amp;apos;debug&amp;apos;` - Show debug messages, info, warnings, and errors
- `&amp;apos;info&amp;apos;` - Show info messages, warnings, and errors
- `&amp;apos;warn&amp;apos;` - Show warnings and errors (default)
- `&amp;apos;error&amp;apos;` - Show only errors
- `&amp;apos;off&amp;apos;` - Disable all logging
At the `&amp;apos;debug&amp;apos;` level, all HTTP requests and responses are logged, including headers and bodies.
Some authentication-related headers are redacted, but sensitive data in request and response bodies
may still be visible.
#### Custom logger
By default, this library logs to `globalThis.console`. You can also provide a custom logger.
Most logging libraries are supported, including [pino](https://www.npmjs.com/package/pino), [winston](https://www.npmjs.com/package/winston), [bunyan](https://www.npmjs.com/package/bunyan), [consola](https://www.npmjs.com/package/consola), [signale](https://www.npmjs.com/package/signale), and [@std/log](https://jsr.io/@std/log). If your logger doesn&amp;apos;t work, please open an issue.
When providing a custom logger, the `logLevel` option still controls which messages are emitted, messages
below the configured level will not be sent to your logger.
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
import pino from &amp;apos;pino&amp;apos;;
const logger = pino();
const client = new Anthropic({
  logger: logger.child({ name: &amp;apos;Anthropic&amp;apos; }),
  logLevel: &amp;apos;debug&amp;apos;, // Send all messages to pino, allowing it to filter
});
```
### Making custom/undocumented requests
This library is typed for convenient access to the documented API. If you need to access undocumented
endpoints, params, or response properties, the library can still be used.
#### Undocumented endpoints
To make requests to undocumented endpoints, you can use `client.get`, `client.post`, and other HTTP verbs.
Options on the client, such as retries, will be respected when making these requests.
```ts
await client.post(&amp;apos;/some/path&amp;apos;, {
  body: { some_prop: &amp;apos;foo&amp;apos; },
  query: { some_query_arg: &amp;apos;bar&amp;apos; },
});
```
#### Undocumented request params
To make requests using undocumented parameters, you may use `// @ts-expect-error` on the undocumented
parameter. This library doesn&amp;apos;t validate at runtime that the request matches the type, so any extra values you
send will be sent as-is.
```ts
client.foo.create({
  foo: &amp;apos;my_param&amp;apos;,
  bar: 12,
  // @ts-expect-error baz is not yet public
  baz: &amp;apos;undocumented option&amp;apos;,
});
```
For requests with the `GET` verb, any extra params will be in the query, all other requests will send the
extra param in the body.
If you want to explicitly send an extra argument, you can do so with the `query`, `body`, and `headers` request
options.
#### Undocumented response properties
To access undocumented response properties, you may access the response object with `// @ts-expect-error` on
the response object, or cast the response object to the requisite type. Like the request params, we do not
validate or strip extra properties from the response from the API.
### Customizing the fetch client
By default, this library expects a global `fetch` function is defined.
If you want to use a different `fetch` function, you can either polyfill the global:
```ts
import fetch from &amp;apos;my-fetch&amp;apos;;
globalThis.fetch = fetch;
```
Or pass it to the client:
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
import fetch from &amp;apos;my-fetch&amp;apos;;
const client = new Anthropic({ fetch });
```
### Fetch options
If you want to set custom `fetch` options without overriding the `fetch` function, you can provide a `fetchOptions` object when instantiating the client or making a request. (Request-specific options override client options.)
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic({
  fetchOptions: {
    // `RequestInit` options
  },
});
```
#### Configuring proxies
To modify proxy behavior, you can provide custom `fetchOptions` that add runtime-specific proxy
options to requests:
&amp;lt;img src=&amp;quot;https://raw.githubusercontent.com/stainless-api/sdk-assets/refs/heads/main/node.svg&amp;quot; align=&amp;quot;top&amp;quot; width=&amp;quot;18&amp;quot; height=&amp;quot;21&amp;quot;&amp;gt; **Node** &amp;lt;sup&amp;gt;[[docs](https://github.com/nodejs/undici/blob/main/docs/docs/api/ProxyAgent.md#example---proxyagent-with-fetch)]&amp;lt;/sup&amp;gt;
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
import * as undici from &amp;apos;undici&amp;apos;;
const proxyAgent = new undici.ProxyAgent(&amp;apos;http://localhost:8888&amp;apos;);
const client = new Anthropic({
  fetchOptions: {
    dispatcher: proxyAgent,
  },
});
```
&amp;lt;img src=&amp;quot;https://raw.githubusercontent.com/stainless-api/sdk-assets/refs/heads/main/bun.svg&amp;quot; align=&amp;quot;top&amp;quot; width=&amp;quot;18&amp;quot; height=&amp;quot;21&amp;quot;&amp;gt; **Bun** &amp;lt;sup&amp;gt;[[docs](https://bun.sh/guides/http/proxy)]&amp;lt;/sup&amp;gt;
```ts
import Anthropic from &amp;apos;@anthropic-ai/sdk&amp;apos;;
const client = new Anthropic({
  fetchOptions: {
    proxy: &amp;apos;http://localhost:8888&amp;apos;,
  },
});
```
&amp;lt;img src=&amp;quot;https://raw.githubusercontent.com/stainless-api/sdk-assets/refs/heads/main/deno.svg&amp;quot; align=&amp;quot;top&amp;quot; width=&amp;quot;18&amp;quot; height=&amp;quot;21&amp;quot;&amp;gt; **Deno** &amp;lt;sup&amp;gt;[[docs](https://docs.deno.com/api/deno/~/Deno.createHttpClient)]&amp;lt;/sup&amp;gt;
```ts
import Anthropic from &amp;apos;npm:@anthropic-ai/sdk&amp;apos;;
const httpClient = Deno.createHttpClient({ proxy: { url: &amp;apos;http://localhost:8888&amp;apos; } });
const client = new Anthropic({
  fetchOptions: {
    client: httpClient,
  },
});
```
## Frequently Asked Questions
## Semantic versioning
This package generally follows [SemVer](https://semver.org/spec/v2.0.0.html) conventions, though certain backwards-incompatible changes may be released as minor versions:
1. Changes that only affect static types, without breaking runtime behavior.
2. Changes to library internals which are technically public but not intended or documented for external use. _(Please open a GitHub issue to let us know if you are relying on such internals.)_
3. Changes that we do not expect to impact the vast majority of users in practice.
We take backwards-compatibility seriously and work hard to ensure you can rely on a smooth upgrade experience.
We are keen for your feedback; please open an [issue](https://www.github.com/anthropics/anthropic-sdk-typescript/issues) with questions, bugs, or suggestions.
## Requirements
TypeScript &amp;gt;= 4.9 is supported.
The following runtimes are supported:
- Node.js 20 LTS or later ([non-EOL](https://endoflife.date/nodejs)) versions.
- Deno v1.28.0 or higher.
- Bun 1.0 or later.
- Cloudflare Workers.
- Vercel Edge Runtime.
- Jest 28 or greater with the `&amp;quot;node&amp;quot;` environment (`&amp;quot;jsdom&amp;quot;` is not supported at this time).
- Nitro v2.6 or greater.
- Web browsers: disabled by default to avoid exposing your secret API credentials (see our help center for [best practices](https://support.anthropic.com/en/articles/9767949-api-key-best-practices-keeping-your-keys-safe-and-secure)). Enable browser support by explicitly setting `dangerouslyAllowBrowser` to `true`.
&amp;lt;details&amp;gt;
  &amp;lt;summary&amp;gt;&amp;lt;b&amp;gt;More explanation&amp;lt;/b&amp;gt;&amp;lt;/summary&amp;gt;
  &amp;lt;h3&amp;gt;Why is this dangerous?&amp;lt;/h3&amp;gt;
  Enabling the &amp;lt;code&amp;gt;dangerouslyAllowBrowser&amp;lt;/code&amp;gt; option can be dangerous because it exposes your secret API credentials in the client-side code. Web browsers are inherently less secure than server environments,
  any user with access to the browser can potentially inspect, extract, and misuse these credentials. This could lead to unauthorized access using your credentials and potentially compromise sensitive data or functionality.
  &amp;lt;h3&amp;gt;When might this not be dangerous?&amp;lt;/h3&amp;gt;
  In certain scenarios where enabling browser support might not pose significant risks:
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;Internal Tools: If the application is used solely within a controlled internal environment where the users are trusted, the risk of credential exposure can be mitigated.&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Development or debugging purpose: Enabling this feature temporarily might be acceptable, provided the credentials are short-lived, aren&amp;apos;t also used in production environments, or are frequently rotated.&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/details&amp;gt;
Note that React Native is not supported at this time.
If you are interested in other runtime environments, please open or upvote an issue on GitHub.
## Contributing
See [the contributing documentation](./CONTRIBUTING.md).&lt;/file&gt;&lt;/files&gt;&lt;/repomix&gt;</file><file path=".hypermix/openai/sdk-examples.xml">&lt;repomix&gt;This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).&lt;file_summary&gt;This section contains a summary of this file.&lt;purpose&gt;This file contains a packed representation of the entire repository&amp;apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.&lt;/purpose&gt;&lt;file_format&gt;The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file&lt;/file_format&gt;&lt;usage_guidelines&gt;- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.&lt;/usage_guidelines&gt;&lt;notes&gt;- Some files may have been excluded based on .gitignore rules and Repomix&amp;apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/examples/**/*.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)&lt;/notes&gt;&lt;additional_info&gt;&lt;/additional_info&gt;&lt;/file_summary&gt;&lt;directory_structure&gt;&lt;/directory_structure&gt;&lt;files&gt;This section contains the contents of the repository&amp;apos;s files.&lt;/files&gt;&lt;/repomix&gt;</file><file path=".hypermix/vercel/ai.xml">&lt;repomix&gt;This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).&lt;file_summary&gt;This section contains a summary of this file.&lt;purpose&gt;This file contains a packed representation of the entire repository&amp;apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.&lt;/purpose&gt;&lt;file_format&gt;The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file&lt;/file_format&gt;&lt;usage_guidelines&gt;- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.&lt;/usage_guidelines&gt;&lt;notes&gt;- Some files may have been excluded based on .gitignore rules and Repomix&amp;apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: packages/ai/core/**/*.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)&lt;/notes&gt;&lt;additional_info&gt;&lt;/additional_info&gt;&lt;/file_summary&gt;&lt;directory_structure&gt;packages/
  ai/
    core/
      data-stream/
        create-data-stream-response.test.ts
        create-data-stream-response.ts
        create-data-stream.test.ts
        create-data-stream.ts
        data-stream-writer.ts
        index.ts
        pipe-data-stream-to-response.test.ts
        pipe-data-stream-to-response.ts
      embed/
        embed-many-result.ts
        embed-many.test.ts
        embed-many.ts
        embed-result.ts
        embed.test.ts
        embed.ts
        index.ts
      generate-image/
        generate-image-result.ts
        generate-image.test.ts
        generate-image.ts
        index.ts
      generate-object/
        generate-object-result.ts
        generate-object.test.ts
        generate-object.ts
        index.ts
        inject-json-instruction.test.ts
        inject-json-instruction.ts
        output-strategy.ts
        stream-object-result.ts
        stream-object.test.ts
        stream-object.ts
        validate-object-generation-input.ts
      generate-speech/
        generate-speech-result.ts
        generate-speech.test.ts
        generate-speech.ts
        generated-audio-file.ts
        index.ts
      generate-text/
        generate-text-result.ts
        generate-text.test.ts
        generate-text.ts
        generated-file.ts
        index.ts
        output.test.ts
        output.ts
        parse-tool-call.test.ts
        parse-tool-call.ts
        reasoning-detail.ts
        run-tools-transformation.test.ts
        run-tools-transformation.ts
        smooth-stream.test.ts
        smooth-stream.ts
        step-result.ts
        stream-text-result.ts
        stream-text.test.ts
        stream-text.ts
        to-response-messages.test.ts
        to-response-messages.ts
        tool-call-repair.ts
        tool-call.ts
        tool-result.ts
        tool-set.ts
      middleware/
        default-settings-middleware.test.ts
        default-settings-middleware.ts
        extract-reasoning-middleware.test.ts
        extract-reasoning-middleware.ts
        index.ts
        language-model-v1-middleware.ts
        simulate-streaming-middleware.test.ts
        simulate-streaming-middleware.ts
        wrap-language-model.test.ts
        wrap-language-model.ts
      prompt/
        append-client-message.test.ts
        append-client-message.ts
        append-response-messages.test.ts
        append-response-messages.ts
        attachments-to-parts.ts
        call-settings.ts
        content-part.ts
        convert-to-core-messages.test.ts
        convert-to-core-messages.ts
        convert-to-language-model-prompt.test.ts
        convert-to-language-model-prompt.ts
        data-content.test.ts
        data-content.ts
        index.ts
        invalid-data-content-error.ts
        invalid-message-role-error.ts
        message-conversion-error.ts
        message.ts
        prepare-call-settings.test.ts
        prepare-call-settings.ts
        prepare-retries.test.ts
        prepare-retries.ts
        prepare-tools-and-tool-choice.test.ts
        prepare-tools-and-tool-choice.ts
        prompt.ts
        split-data-url.ts
        standardize-prompt.test.ts
        standardize-prompt.ts
        stringify-for-telemetry.test.ts
        stringify-for-telemetry.ts
        tool-result-content.ts
      registry/
        custom-provider.test.ts
        custom-provider.ts
        index.ts
        no-such-provider-error.ts
        provider-registry.test.ts
        provider-registry.ts
      telemetry/
        assemble-operation-name.ts
        get-base-telemetry-attributes.ts
        get-tracer.ts
        noop-tracer.ts
        record-span.ts
        select-telemetry-attributes.ts
        select-temetry-attributes.test.ts
        telemetry-settings.ts
      test/
        mock-embedding-model-v1.ts
        mock-image-model-v1.ts
        mock-language-model-v1.ts
        mock-server-response.ts
        mock-speech-model-v1.ts
        mock-tracer.ts
        mock-transcription-model-v1.ts
        mock-values.ts
        not-implemented.ts
      tool/
        mcp/
          json-rpc-message.ts
          mcp-client.test.ts
          mcp-client.ts
          mcp-sse-transport.test.ts
          mcp-sse-transport.ts
          mcp-transport.ts
          mock-mcp-transport.ts
          types.ts
        index.ts
        tool.ts
      transcribe/
        index.ts
        transcribe-result.ts
        transcribe.test.ts
        transcribe.ts
      types/
        embedding-model.ts
        image-model-response-metadata.ts
        image-model.ts
        index.ts
        json-value.ts
        language-model-request-metadata.ts
        language-model-response-metadata.ts
        language-model.ts
        provider-metadata.ts
        provider.ts
        speech-model-response-metadata.ts
        speech-model.ts
        transcription-model-response-metadata.ts
        transcription-model.ts
        usage.ts
      util/
        async-iterable-stream.test.ts
        async-iterable-stream.ts
        cosine-similarity.test.ts
        cosine-similarity.ts
        create-stitchable-stream.test.ts
        create-stitchable-stream.ts
        detect-mimetype.test.ts
        detect-mimetype.ts
        get-potential-start-index.test.ts
        get-potential-start-index.ts
        is-non-empty-object.ts
        merge-objects.test.ts
        merge-objects.ts
        merge-streams.test.ts
        merge-streams.ts
        now.ts
        prepare-outgoing-http-headers.test.ts
        prepare-outgoing-http-headers.ts
        prepare-response-headers.test.ts
        prepare-response-headers.ts
        remove-text-after-last-whitespace.test.ts
        remove-text-after-last-whitespace.ts
        simulate-readable-stream.test.ts
        simulate-readable-stream.ts
        split-array.test.ts
        split-array.ts
        split-on-last-whitespace.test.ts
        split-on-last-whitespace.ts
        value-of.ts
        write-to-server-response.ts
      index.ts&lt;/directory_structure&gt;&lt;files&gt;This section contains the contents of the repository&amp;apos;s files.&lt;file path=&quot;packages/ai/core/data-stream/create-data-stream-response.test.ts&quot;&gt;import { expect, it, describe } from &amp;apos;vitest&amp;apos;;
import { createDataStreamResponse } from &amp;apos;./create-data-stream-response&amp;apos;;
import { convertReadableStreamToArray } from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { formatDataStreamPart } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
⋮----
// Verify response properties
⋮----
// Verify headers
⋮----
// Verify encoded stream content&lt;/file&gt;&lt;file path=&quot;packages/ai/core/data-stream/create-data-stream-response.ts&quot;&gt;import { prepareResponseHeaders } from &amp;apos;../util/prepare-response-headers&amp;apos;;
import { createDataStream } from &amp;apos;./create-data-stream&amp;apos;;
import { DataStreamWriter } from &amp;apos;./data-stream-writer&amp;apos;;
export function createDataStreamResponse({
  status,
  statusText,
  headers,
  execute,
  onError,
}: ResponseInit &amp;amp; {
execute: (dataStream: DataStreamWriter)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/data-stream/create-data-stream.test.ts&quot;&gt;import { delay } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { convertReadableStreamToArray } from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { formatDataStreamPart } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { expect, it } from &amp;apos;vitest&amp;apos;;
import { DelayedPromise } from &amp;apos;../../util/delayed-promise&amp;apos;;
import { Source } from &amp;apos;../types/language-model&amp;apos;;
import { createDataStream } from &amp;apos;./create-data-stream&amp;apos;;
import { DataStreamWriter } from &amp;apos;./data-stream-writer&amp;apos;;
⋮----
start(controller)
⋮----
start(controllerArg)
⋮----
async function pull()
// function is finished
⋮----
// controller1 is still open, create 2nd stream
⋮----
// close controller1
⋮----
await delay(); // relinquish control
// it should still be able to write to controller2&lt;/file&gt;&lt;file path=&quot;packages/ai/core/data-stream/create-data-stream.ts&quot;&gt;import { DataStreamString, formatDataStreamPart } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { DataStreamWriter } from &amp;apos;./data-stream-writer&amp;apos;;
export function createDataStream({
  execute,
  onError = () =&amp;gt; &amp;apos;An error occurred.&amp;apos;, // mask error messages for safety by default
}: {
execute: (dataStream: DataStreamWriter)
⋮----
onError = () =&amp;gt; &amp;apos;An error occurred.&amp;apos;, // mask error messages for safety by default
⋮----
start(controllerArg)
⋮----
function safeEnqueue(data: DataStreamString)
⋮----
// suppress errors when the stream has been closed
⋮----
write(data: DataStreamString)
writeData(data)
writeMessageAnnotation(annotation)
writeSource(source)
merge(streamArg)
⋮----
// Wait until all ongoing streams are done. This approach enables merging
// streams even after execute has returned, as long as there is still an
// open merged stream. This is important to e.g. forward new streams and
// from callbacks.
⋮----
// suppress errors when the stream has been closed&lt;/file&gt;&lt;file path=&quot;packages/ai/core/data-stream/data-stream-writer.ts&quot;&gt;import { JSONValue } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { DataStreamString } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { Source } from &amp;apos;../types/language-model&amp;apos;;
export interface DataStreamWriter {
  /**
   * Appends a data part to the stream.
   */
  write(data: DataStreamString): void;
  /**
   * Appends a data part to the stream.
   */
  writeData(value: JSONValue): void;
  /**
   * Appends a message annotation to the stream.
   */
  writeMessageAnnotation(value: JSONValue): void;
  /**
   * Appends a source part to the stream.
   */
  writeSource(source: Source): void;
  /**
   * Merges the contents of another stream to this stream.
   */
  merge(stream: ReadableStream&amp;lt;DataStreamString&amp;gt;): void;
  /**
   * Error handler that is used by the data stream writer.
   * This is intended for forwarding when merging streams
   * to prevent duplicated error masking.
   */
  onError: ((error: unknown) =&amp;gt; string) | undefined;
}
⋮----
/**
   * Appends a data part to the stream.
   */
write(data: DataStreamString): void;
/**
   * Appends a data part to the stream.
   */
writeData(value: JSONValue): void;
/**
   * Appends a message annotation to the stream.
   */
writeMessageAnnotation(value: JSONValue): void;
/**
   * Appends a source part to the stream.
   */
writeSource(source: Source): void;
/**
   * Merges the contents of another stream to this stream.
   */
merge(stream: ReadableStream&amp;lt;DataStreamString&amp;gt;): void;
/**
   * Error handler that is used by the data stream writer.
   * This is intended for forwarding when merging streams
   * to prevent duplicated error masking.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/data-stream/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/data-stream/pipe-data-stream-to-response.test.ts&quot;&gt;import { expect, it, describe } from &amp;apos;vitest&amp;apos;;
import { pipeDataStreamToResponse } from &amp;apos;./pipe-data-stream-to-response&amp;apos;;
import { formatDataStreamPart } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { createMockServerResponse } from &amp;apos;../test/mock-server-response&amp;apos;;
⋮----
// Wait for the stream to finish writing
⋮----
// Verify response properties
⋮----
// Verify headers
⋮----
// Verify written data using decoded chunks
⋮----
// Wait for the stream to finish writing
⋮----
// Verify error handling using decoded chunks&lt;/file&gt;&lt;file path=&quot;packages/ai/core/data-stream/pipe-data-stream-to-response.ts&quot;&gt;import { ServerResponse } from &amp;apos;node:http&amp;apos;;
import { prepareOutgoingHttpHeaders } from &amp;apos;../util/prepare-outgoing-http-headers&amp;apos;;
import { writeToServerResponse } from &amp;apos;../util/write-to-server-response&amp;apos;;
import { createDataStream } from &amp;apos;./create-data-stream&amp;apos;;
import { DataStreamWriter } from &amp;apos;./data-stream-writer&amp;apos;;
export function pipeDataStreamToResponse(
  response: ServerResponse,
  {
    status,
    statusText,
    headers,
    execute,
    onError,
  }: ResponseInit &amp;amp; {
execute: (writer: DataStreamWriter)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/embed/embed-many-result.ts&quot;&gt;import { Embedding } from &amp;apos;../types&amp;apos;;
import { EmbeddingModelUsage } from &amp;apos;../types/usage&amp;apos;;
/**
The result of a `embedMany` call.
It contains the embeddings, the values, and additional information.
 */
export interface EmbedManyResult&amp;lt;VALUE&amp;gt; {
  /**
  The values that were embedded.
     */
  readonly values: Array&amp;lt;VALUE&amp;gt;;
  /**
  The embeddings. They are in the same order as the values.
    */
  readonly embeddings: Array&amp;lt;Embedding&amp;gt;;
  /**
  The embedding token usage.
    */
  readonly usage: EmbeddingModelUsage;
}
⋮----
/**
  The values that were embedded.
     */
⋮----
/**
  The embeddings. They are in the same order as the values.
    */
⋮----
/**
  The embedding token usage.
    */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/embed/embed-many.test.ts&quot;&gt;import assert from &amp;apos;node:assert&amp;apos;;
import {
  MockEmbeddingModelV1,
  mockEmbed,
} from &amp;apos;../test/mock-embedding-model-v1&amp;apos;;
import { MockTracer } from &amp;apos;../test/mock-tracer&amp;apos;;
import { embedMany } from &amp;apos;./embed-many&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/embed/embed-many.ts&quot;&gt;import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { assembleOperationName } from &amp;apos;../telemetry/assemble-operation-name&amp;apos;;
import { getBaseTelemetryAttributes } from &amp;apos;../telemetry/get-base-telemetry-attributes&amp;apos;;
import { getTracer } from &amp;apos;../telemetry/get-tracer&amp;apos;;
import { recordSpan } from &amp;apos;../telemetry/record-span&amp;apos;;
import { selectTelemetryAttributes } from &amp;apos;../telemetry/select-telemetry-attributes&amp;apos;;
import { TelemetrySettings } from &amp;apos;../telemetry/telemetry-settings&amp;apos;;
import { Embedding, EmbeddingModel } from &amp;apos;../types&amp;apos;;
import { splitArray } from &amp;apos;../util/split-array&amp;apos;;
import { EmbedManyResult } from &amp;apos;./embed-many-result&amp;apos;;
/**
Embed several values using an embedding model. The type of the value is defined
by the embedding model.
`embedMany` automatically splits large requests into smaller chunks if the model
has a limit on how many embeddings can be generated in a single call.
@param model - The embedding model to use.
@param values - The values that should be embedded.
@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.
@param abortSignal - An optional abort signal that can be used to cancel the call.
@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.
@returns A result object that contains the embeddings, the value, and additional information.
 */
export async function embedMany&amp;lt;VALUE&amp;gt;({
  model,
  values,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  experimental_telemetry: telemetry,
}: {
  /**
The embedding model to use.
     */
  model: EmbeddingModel&amp;lt;VALUE&amp;gt;;
  /**
The values that should be embedded.
   */
  values: Array&amp;lt;VALUE&amp;gt;;
  /**
Maximum number of retries per embedding model call. Set to 0 to disable retries.
@default 2
   */
  maxRetries?: number;
  /**
Abort signal.
 */
  abortSignal?: AbortSignal;
  /**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
  headers?: Record&amp;lt;string, string&amp;gt;;
  /**
   * Optional telemetry configuration (experimental).
   */
  experimental_telemetry?: TelemetrySettings;
}): Promise&amp;lt;EmbedManyResult&amp;lt;VALUE&amp;gt;&amp;gt;
⋮----
/**
The embedding model to use.
     */
⋮----
/**
The values that should be embedded.
   */
⋮----
/**
Maximum number of retries per embedding model call. Set to 0 to disable retries.
@default 2
   */
⋮----
/**
Abort signal.
 */
⋮----
/**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
⋮----
/**
   * Optional telemetry configuration (experimental).
   */
⋮----
// specific settings that only make sense on the outer level:
⋮----
// the model has not specified limits on
// how many embeddings can be generated in a single call
⋮----
// nested spans to align with the embedMany telemetry data:
⋮----
// specific settings that only make sense on the outer level:
⋮----
// split the values into chunks that are small enough for the model:
⋮----
// serially embed the chunks:
⋮----
// nested spans to align with the embedMany telemetry data:
⋮----
// specific settings that only make sense on the outer level:
⋮----
class DefaultEmbedManyResult&amp;lt;VALUE&amp;gt; implements EmbedManyResult&amp;lt;VALUE&amp;gt;
⋮----
constructor(options: {
    values: EmbedManyResult&amp;lt;VALUE&amp;gt;[&amp;apos;values&amp;apos;];
    embeddings: EmbedManyResult&amp;lt;VALUE&amp;gt;[&amp;apos;embeddings&amp;apos;];
    usage: EmbedManyResult&amp;lt;VALUE&amp;gt;[&amp;apos;usage&amp;apos;];
})&lt;/file&gt;&lt;file path=&quot;packages/ai/core/embed/embed-result.ts&quot;&gt;import { Embedding } from &amp;apos;../types&amp;apos;;
import { EmbeddingModelUsage } from &amp;apos;../types/usage&amp;apos;;
/**
The result of an `embed` call.
It contains the embedding, the value, and additional information.
 */
export interface EmbedResult&amp;lt;VALUE&amp;gt; {
  /**
  The value that was embedded.
     */
  readonly value: VALUE;
  /**
  The embedding of the value.
    */
  readonly embedding: Embedding;
  /**
  The embedding token usage.
    */
  readonly usage: EmbeddingModelUsage;
  /**
  Optional raw response data.
     */
  readonly rawResponse?: {
    /**
  Response headers.
       */
    headers?: Record&amp;lt;string, string&amp;gt;;
  };
}
⋮----
/**
  The value that was embedded.
     */
⋮----
/**
  The embedding of the value.
    */
⋮----
/**
  The embedding token usage.
    */
⋮----
/**
  Optional raw response data.
     */
⋮----
/**
  Response headers.
       */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/embed/embed.test.ts&quot;&gt;import assert from &amp;apos;node:assert&amp;apos;;
import {
  MockEmbeddingModelV1,
  mockEmbed,
} from &amp;apos;../test/mock-embedding-model-v1&amp;apos;;
import { MockTracer } from &amp;apos;../test/mock-tracer&amp;apos;;
import { embed } from &amp;apos;./embed&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/embed/embed.ts&quot;&gt;import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { assembleOperationName } from &amp;apos;../telemetry/assemble-operation-name&amp;apos;;
import { getBaseTelemetryAttributes } from &amp;apos;../telemetry/get-base-telemetry-attributes&amp;apos;;
import { getTracer } from &amp;apos;../telemetry/get-tracer&amp;apos;;
import { recordSpan } from &amp;apos;../telemetry/record-span&amp;apos;;
import { selectTelemetryAttributes } from &amp;apos;../telemetry/select-telemetry-attributes&amp;apos;;
import { TelemetrySettings } from &amp;apos;../telemetry/telemetry-settings&amp;apos;;
import { EmbeddingModel } from &amp;apos;../types&amp;apos;;
import { EmbedResult } from &amp;apos;./embed-result&amp;apos;;
/**
Embed a value using an embedding model. The type of the value is defined by the embedding model.
@param model - The embedding model to use.
@param value - The value that should be embedded.
@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.
@param abortSignal - An optional abort signal that can be used to cancel the call.
@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.
@returns A result object that contains the embedding, the value, and additional information.
 */
export async function embed&amp;lt;VALUE&amp;gt;({
  model,
  value,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  experimental_telemetry: telemetry,
}: {
  /**
The embedding model to use.
     */
  model: EmbeddingModel&amp;lt;VALUE&amp;gt;;
  /**
The value that should be embedded.
   */
  value: VALUE;
  /**
Maximum number of retries per embedding model call. Set to 0 to disable retries.
@default 2
   */
  maxRetries?: number;
  /**
Abort signal.
 */
  abortSignal?: AbortSignal;
  /**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
  headers?: Record&amp;lt;string, string&amp;gt;;
  /**
   * Optional telemetry configuration (experimental).
   */
  experimental_telemetry?: TelemetrySettings;
}): Promise&amp;lt;EmbedResult&amp;lt;VALUE&amp;gt;&amp;gt;
⋮----
/**
The embedding model to use.
     */
⋮----
/**
The value that should be embedded.
   */
⋮----
/**
Maximum number of retries per embedding model call. Set to 0 to disable retries.
@default 2
   */
⋮----
/**
Abort signal.
 */
⋮----
/**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
⋮----
/**
   * Optional telemetry configuration (experimental).
   */
⋮----
// nested spans to align with the embedMany telemetry data:
⋮----
// specific settings that only make sense on the outer level:
⋮----
class DefaultEmbedResult&amp;lt;VALUE&amp;gt; implements EmbedResult&amp;lt;VALUE&amp;gt;
⋮----
constructor(options: {
    value: EmbedResult&amp;lt;VALUE&amp;gt;[&amp;apos;value&amp;apos;];
    embedding: EmbedResult&amp;lt;VALUE&amp;gt;[&amp;apos;embedding&amp;apos;];
    usage: EmbedResult&amp;lt;VALUE&amp;gt;[&amp;apos;usage&amp;apos;];
    rawResponse?: EmbedResult&amp;lt;VALUE&amp;gt;[&amp;apos;rawResponse&amp;apos;];
})&lt;/file&gt;&lt;file path=&quot;packages/ai/core/embed/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-image/generate-image-result.ts&quot;&gt;import { GeneratedFile } from &amp;apos;../generate-text&amp;apos;;
import { ImageGenerationWarning } from &amp;apos;../types/image-model&amp;apos;;
import { ImageModelResponseMetadata } from &amp;apos;../types/image-model-response-metadata&amp;apos;;
/**
The result of a `generateImage` call.
It contains the images and additional information.
 */
export interface GenerateImageResult {
  /**
The first image that was generated.
   */
  readonly image: GeneratedFile;
  /**
The images that were generated.
     */
  readonly images: Array&amp;lt;GeneratedFile&amp;gt;;
  /**
Warnings for the call, e.g. unsupported settings.
     */
  readonly warnings: Array&amp;lt;ImageGenerationWarning&amp;gt;;
  /**
Response metadata from the provider. There may be multiple responses if we made multiple calls to the model.
   */
  readonly responses: Array&amp;lt;ImageModelResponseMetadata&amp;gt;;
}
⋮----
/**
The first image that was generated.
   */
⋮----
/**
The images that were generated.
     */
⋮----
/**
Warnings for the call, e.g. unsupported settings.
     */
⋮----
/**
Response metadata from the provider. There may be multiple responses if we made multiple calls to the model.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-image/generate-image.test.ts&quot;&gt;import { ImageModelV1, ImageModelV1CallWarning } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { MockImageModelV1 } from &amp;apos;../test/mock-image-model-v1&amp;apos;;
import { generateImage } from &amp;apos;./generate-image&amp;apos;;
import {
  convertBase64ToUint8Array,
  convertUint8ArrayToBase64,
} from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
⋮----
&amp;apos;iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==&amp;apos;; // 1x1 transparent PNG
⋮----
&amp;apos;/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAb/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k=&amp;apos;; // 1x1 black JPEG
const gifBase64 = &amp;apos;R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=&amp;apos;; // 1x1 transparent GIF
const createMockResponse = (options: {
  images: string[] | Uint8Array[];
  warnings?: ImageModelV1CallWarning[];
  timestamp?: Date;
  modelId?: string;
  headers?: Record&amp;lt;string, string&amp;gt;;
}) =&amp;gt; (&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-image/generate-image.ts&quot;&gt;import { AISDKError, ImageModelV1, JSONValue } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { NoImageGeneratedError } from &amp;apos;../../errors/no-image-generated-error&amp;apos;;
import {
  DefaultGeneratedFile,
  GeneratedFile,
} from &amp;apos;../generate-text/generated-file&amp;apos;;
import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { ImageGenerationWarning } from &amp;apos;../types/image-model&amp;apos;;
import { ImageModelResponseMetadata } from &amp;apos;../types/image-model-response-metadata&amp;apos;;
import { GenerateImageResult } from &amp;apos;./generate-image-result&amp;apos;;
import {
  detectMimeType,
  imageMimeTypeSignatures,
} from &amp;apos;../util/detect-mimetype&amp;apos;;
/**
Generates images using an image model.
@param model - The image model to use.
@param prompt - The prompt that should be used to generate the image.
@param n - Number of images to generate. Default: 1.
@param size - Size of the images to generate. Must have the format `{width}x{height}`.
@param aspectRatio - Aspect ratio of the images to generate. Must have the format `{width}:{height}`.
@param seed - Seed for the image generation.
@param providerOptions - Additional provider-specific options that are passed through to the provider
as body parameters.
@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.
@param abortSignal - An optional abort signal that can be used to cancel the call.
@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.
@returns A result object that contains the generated images.
 */
export async function generateImage({
  model,
  prompt,
  n = 1,
  size,
  aspectRatio,
  seed,
  providerOptions,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
}: {
  /**
The image model to use.
     */
  model: ImageModelV1;
  /**
The prompt that should be used to generate the image.
   */
  prompt: string;
  /**
Number of images to generate.
   */
  n?: number;
  /**
Size of the images to generate. Must have the format `{width}x{height}`. If not provided, the default size will be used.
   */
  size?: `${number}x${number}`;
  /**
Aspect ratio of the images to generate. Must have the format `{width}:{height}`. If not provided, the default aspect ratio will be used.
   */
  aspectRatio?: `${number}:${number}`;
  /**
Seed for the image generation. If not provided, the default seed will be used.
   */
  seed?: number;
  /**
Additional provider-specific options that are passed through to the provider
as body parameters.
The outer record is keyed by the provider name, and the inner
record is keyed by the provider-specific metadata key.
```ts
{
  &amp;quot;openai&amp;quot;: {
    &amp;quot;style&amp;quot;: &amp;quot;vivid&amp;quot;
  }
}
```
     */
  providerOptions?: Record&amp;lt;string, Record&amp;lt;string, JSONValue&amp;gt;&amp;gt;;
  /**
Maximum number of retries per embedding model call. Set to 0 to disable retries.
@default 2
   */
  maxRetries?: number;
  /**
Abort signal.
 */
  abortSignal?: AbortSignal;
  /**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
  headers?: Record&amp;lt;string, string&amp;gt;;
}): Promise&amp;lt;GenerateImageResult&amp;gt;
⋮----
/**
The image model to use.
     */
⋮----
/**
The prompt that should be used to generate the image.
   */
⋮----
/**
Number of images to generate.
   */
⋮----
/**
Size of the images to generate. Must have the format `{width}x{height}`. If not provided, the default size will be used.
   */
⋮----
/**
Aspect ratio of the images to generate. Must have the format `{width}:{height}`. If not provided, the default aspect ratio will be used.
   */
⋮----
/**
Seed for the image generation. If not provided, the default seed will be used.
   */
⋮----
/**
Additional provider-specific options that are passed through to the provider
as body parameters.
The outer record is keyed by the provider name, and the inner
record is keyed by the provider-specific metadata key.
```ts
{
  &amp;quot;openai&amp;quot;: {
    &amp;quot;style&amp;quot;: &amp;quot;vivid&amp;quot;
  }
}
```
     */
⋮----
/**
Maximum number of retries per embedding model call. Set to 0 to disable retries.
@default 2
   */
⋮----
/**
Abort signal.
 */
⋮----
/**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
⋮----
// default to 1 if the model has not specified limits on
// how many images can be generated in a single call
⋮----
// parallelize calls to the model:
⋮----
// collect result images, warnings, and response metadata
⋮----
class DefaultGenerateImageResult implements GenerateImageResult
⋮----
constructor(options: {
    images: Array&amp;lt;GeneratedFile&amp;gt;;
    warnings: Array&amp;lt;ImageGenerationWarning&amp;gt;;
    responses: Array&amp;lt;ImageModelResponseMetadata&amp;gt;;
})
get image()&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-image/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/generate-object-result.ts&quot;&gt;import {
  CallWarning,
  FinishReason,
  LanguageModelRequestMetadata,
  LanguageModelResponseMetadata,
  LogProbs,
  ProviderMetadata,
} from &amp;apos;../types&amp;apos;;
import { LanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
/**
The result of a `generateObject` call.
 */
export interface GenerateObjectResult&amp;lt;OBJECT&amp;gt; {
  /**
  The generated object (typed according to the schema).
     */
  readonly object: OBJECT;
  /**
  The reason why the generation finished.
     */
  readonly finishReason: FinishReason;
  /**
  The token usage of the generated text.
     */
  readonly usage: LanguageModelUsage;
  /**
  Warnings from the model provider (e.g. unsupported settings).
     */
  readonly warnings: CallWarning[] | undefined;
  /**
Additional request information.
   */
  readonly request: LanguageModelRequestMetadata;
  /**
Additional response information.
   */
  readonly response: LanguageModelResponseMetadata &amp;amp; {
    /**
Response body (available only for providers that use HTTP requests).
    */
    body?: unknown;
  };
  /**
 Logprobs for the completion.
`undefined` if the mode does not support logprobs or if was not enabled.
@deprecated Will become a provider extension in the future.
     */
  readonly logprobs: LogProbs | undefined;
  /**
Additional provider-specific metadata. They are passed through
from the provider to the AI SDK and enable provider-specific
results that can be fully encapsulated in the provider.
   */
  readonly providerMetadata: ProviderMetadata | undefined;
  /**
@deprecated Use `providerMetadata` instead.
   */
  readonly experimental_providerMetadata: ProviderMetadata | undefined;
  /**
  Converts the object to a JSON response.
  The response will have a status code of 200 and a content type of `application/json; charset=utf-8`.
     */
  toJsonResponse(init?: ResponseInit): Response;
}
⋮----
/**
  The generated object (typed according to the schema).
     */
⋮----
/**
  The reason why the generation finished.
     */
⋮----
/**
  The token usage of the generated text.
     */
⋮----
/**
  Warnings from the model provider (e.g. unsupported settings).
     */
⋮----
/**
Additional request information.
   */
⋮----
/**
Additional response information.
   */
⋮----
/**
Response body (available only for providers that use HTTP requests).
    */
⋮----
/**
 Logprobs for the completion.
`undefined` if the mode does not support logprobs or if was not enabled.
@deprecated Will become a provider extension in the future.
     */
⋮----
/**
Additional provider-specific metadata. They are passed through
from the provider to the AI SDK and enable provider-specific
results that can be fully encapsulated in the provider.
   */
⋮----
/**
@deprecated Use `providerMetadata` instead.
   */
⋮----
/**
  Converts the object to a JSON response.
  The response will have a status code of 200 and a content type of `application/json; charset=utf-8`.
     */
toJsonResponse(init?: ResponseInit): Response;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/generate-object.test.ts&quot;&gt;import { convertReadableStreamToArray } from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { jsonSchema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import assert, { fail } from &amp;apos;node:assert&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { verifyNoObjectGeneratedError as originalVerifyNoObjectGeneratedError } from &amp;apos;../../errors/no-object-generated-error&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
import { MockTracer } from &amp;apos;../test/mock-tracer&amp;apos;;
import { generateObject } from &amp;apos;./generate-object&amp;apos;;
import { JSONParseError, TypeValidationError } from &amp;apos;@ai-sdk/provider&amp;apos;;
⋮----
function verifyNoObjectGeneratedError(
      error: unknown,
      { message }: { message: string },
)
⋮----
class MockLanguageModelWithImageSupport extends MockLanguageModelV1
⋮----
constructor()
⋮----
supportsUrl(url: URL)
⋮----
// Reference &amp;apos;this&amp;apos; to verify context&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/generate-object.ts&quot;&gt;import {
  JSONParseError,
  JSONValue,
  TypeValidationError,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { createIdGenerator, safeParseJSON } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { Schema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { NoObjectGeneratedError } from &amp;apos;../../errors/no-object-generated-error&amp;apos;;
import { CallSettings } from &amp;apos;../prompt/call-settings&amp;apos;;
import { convertToLanguageModelPrompt } from &amp;apos;../prompt/convert-to-language-model-prompt&amp;apos;;
import { prepareCallSettings } from &amp;apos;../prompt/prepare-call-settings&amp;apos;;
import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { Prompt } from &amp;apos;../prompt/prompt&amp;apos;;
import { standardizePrompt } from &amp;apos;../prompt/standardize-prompt&amp;apos;;
import { assembleOperationName } from &amp;apos;../telemetry/assemble-operation-name&amp;apos;;
import { getBaseTelemetryAttributes } from &amp;apos;../telemetry/get-base-telemetry-attributes&amp;apos;;
import { getTracer } from &amp;apos;../telemetry/get-tracer&amp;apos;;
import { recordSpan } from &amp;apos;../telemetry/record-span&amp;apos;;
import { selectTelemetryAttributes } from &amp;apos;../telemetry/select-telemetry-attributes&amp;apos;;
import { TelemetrySettings } from &amp;apos;../telemetry/telemetry-settings&amp;apos;;
import {
  CallWarning,
  FinishReason,
  LanguageModel,
  LogProbs,
  ProviderMetadata,
} from &amp;apos;../types&amp;apos;;
import { LanguageModelRequestMetadata } from &amp;apos;../types/language-model-request-metadata&amp;apos;;
import { LanguageModelResponseMetadata } from &amp;apos;../types/language-model-response-metadata&amp;apos;;
import { ProviderOptions } from &amp;apos;../types/provider-metadata&amp;apos;;
import { calculateLanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
import { prepareResponseHeaders } from &amp;apos;../util/prepare-response-headers&amp;apos;;
import { GenerateObjectResult } from &amp;apos;./generate-object-result&amp;apos;;
import { injectJsonInstruction } from &amp;apos;./inject-json-instruction&amp;apos;;
import { getOutputStrategy } from &amp;apos;./output-strategy&amp;apos;;
import { validateObjectGenerationInput } from &amp;apos;./validate-object-generation-input&amp;apos;;
import { stringifyForTelemetry } from &amp;apos;../prompt/stringify-for-telemetry&amp;apos;;
⋮----
/**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
Should return the repaired text or null if the text cannot be repaired.
     */
export type RepairTextFunction = (options: {
  text: string;
  error: JSONParseError | TypeValidationError;
}) =&amp;gt; Promise&amp;lt;string | null&amp;gt;;
/**
Generate a structured, typed object for a given prompt and schema using a language model.
This function does not stream the output. If you want to stream the output, use `streamObject` instead.
@returns
A result object that contains the generated object, the finish reason, the token usage, and additional information.
 */
export async function generateObject&amp;lt;OBJECT&amp;gt;(
  options: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
    Prompt &amp;amp; {
      output?: &amp;apos;object&amp;apos; | undefined;
      /**
The language model to use.
     */
      model: LanguageModel;
      /**
The schema of the object that the model should generate.
     */
      schema: z.Schema&amp;lt;OBJECT, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;OBJECT&amp;gt;;
      /**
Optional name of the output that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema name.
     */
      schemaName?: string;
      /**
Optional description of the output that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema description.
     */
      schemaDescription?: string;
      /**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
      mode?: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos;;
      /**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
     */
      experimental_repairText?: RepairTextFunction;
      /**
Optional telemetry configuration (experimental).
       */
      experimental_telemetry?: TelemetrySettings;
      /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
      providerOptions?: ProviderOptions;
      /**
@deprecated Use `providerOptions` instead.
*/
      experimental_providerMetadata?: ProviderMetadata;
      /**
       * Internal. For test use only. May change without notice.
       */
      _internal?: {
generateId?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The schema of the object that the model should generate.
     */
⋮----
/**
Optional name of the output that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema name.
     */
⋮----
/**
Optional description of the output that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema description.
     */
⋮----
/**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
⋮----
/**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
     */
⋮----
/**
Optional telemetry configuration (experimental).
       */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
       * Internal. For test use only. May change without notice.
       */
⋮----
/**
Generate an array with structured, typed elements for a given prompt and element schema using a language model.
This function does not stream the output. If you want to stream the output, use `streamObject` instead.
@return
A result object that contains the generated object, the finish reason, the token usage, and additional information.
 */
export async function generateObject&amp;lt;ELEMENT&amp;gt;(
  options: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
    Prompt &amp;amp; {
      output: &amp;apos;array&amp;apos;;
      /**
The language model to use.
     */
      model: LanguageModel;
      /**
The element schema of the array that the model should generate.
 */
      schema: z.Schema&amp;lt;ELEMENT, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;ELEMENT&amp;gt;;
      /**
Optional name of the array that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema name.
     */
      schemaName?: string;
      /**
Optional description of the array that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema description.
 */
      schemaDescription?: string;
      /**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
      mode?: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos;;
      /**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
     */
      experimental_repairText?: RepairTextFunction;
      /**
Optional telemetry configuration (experimental).
     */
      experimental_telemetry?: TelemetrySettings;
      /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
      providerOptions?: ProviderOptions;
      /**
@deprecated Use `providerOptions` instead.
*/
      experimental_providerMetadata?: ProviderMetadata;
      /**
       * Internal. For test use only. May change without notice.
       */
      _internal?: {
generateId?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The element schema of the array that the model should generate.
 */
⋮----
/**
Optional name of the array that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema name.
     */
⋮----
/**
Optional description of the array that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema description.
 */
⋮----
/**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
⋮----
/**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
     */
⋮----
/**
Optional telemetry configuration (experimental).
     */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
       * Internal. For test use only. May change without notice.
       */
⋮----
/**
Generate a value from an enum (limited list of string values) using a language model.
This function does not stream the output.
@return
A result object that contains the generated value, the finish reason, the token usage, and additional information.
 */
export async function generateObject&amp;lt;ENUM extends string&amp;gt;(
  options: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
    Prompt &amp;amp; {
      output: &amp;apos;enum&amp;apos;;
      /**
The language model to use.
     */
      model: LanguageModel;
      /**
The enum values that the model should use.
     */
      enum: Array&amp;lt;ENUM&amp;gt;;
      /**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
      mode?: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos;;
      /**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
     */
      experimental_repairText?: RepairTextFunction;
      /**
Optional telemetry configuration (experimental).
     */
      experimental_telemetry?: TelemetrySettings;
      /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
      providerOptions?: ProviderOptions;
      /**
@deprecated Use `providerOptions` instead.
*/
      experimental_providerMetadata?: ProviderMetadata;
      /**
       * Internal. For test use only. May change without notice.
       */
      _internal?: {
generateId?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The enum values that the model should use.
     */
⋮----
/**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
⋮----
/**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
     */
⋮----
/**
Optional telemetry configuration (experimental).
     */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
       * Internal. For test use only. May change without notice.
       */
⋮----
/**
Generate JSON with any schema for a given prompt using a language model.
This function does not stream the output. If you want to stream the output, use `streamObject` instead.
@returns
A result object that contains the generated object, the finish reason, the token usage, and additional information.
 */
export async function generateObject(
  options: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
    Prompt &amp;amp; {
      output: &amp;apos;no-schema&amp;apos;;
      /**
The language model to use.
     */
      model: LanguageModel;
      /**
The mode to use for object generation. Must be &amp;quot;json&amp;quot; for no-schema output.
     */
      mode?: &amp;apos;json&amp;apos;;
      /**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
     */
      experimental_repairText?: RepairTextFunction;
      /**
Optional telemetry configuration (experimental).
       */
      experimental_telemetry?: TelemetrySettings;
      /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
      providerOptions?: ProviderOptions;
      /**
@deprecated Use `providerOptions` instead.
*/
      experimental_providerMetadata?: ProviderMetadata;
      /**
       * Internal. For test use only. May change without notice.
       */
      _internal?: {
generateId?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The mode to use for object generation. Must be &amp;quot;json&amp;quot; for no-schema output.
     */
⋮----
/**
A function that attempts to repair the raw output of the mode
to enable JSON parsing.
     */
⋮----
/**
Optional telemetry configuration (experimental).
       */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
       * Internal. For test use only. May change without notice.
       */
⋮----
export async function generateObject&amp;lt;SCHEMA, RESULT&amp;gt;({
  model,
  enum: enumValues, // rename bc enum is reserved by typescript
  schema: inputSchema,
  schemaName,
  schemaDescription,
  mode,
  output = &amp;apos;object&amp;apos;,
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  experimental_repairText: repairText,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  _internal: {
    generateId = originalGenerateId,
    currentDate = () =&amp;gt; new Date(),
  } = {},
  ...settings
}: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
  Prompt &amp;amp; {
    /**
     * The expected structure of the output.
     *
     * - &amp;apos;object&amp;apos;: Generate a single object that conforms to the schema.
     * - &amp;apos;array&amp;apos;: Generate an array of objects that conform to the schema.
     * - &amp;apos;no-schema&amp;apos;: Generate any JSON object. No schema is specified.
     *
     * Default is &amp;apos;object&amp;apos; if not specified.
     */
    output?: &amp;apos;object&amp;apos; | &amp;apos;array&amp;apos; | &amp;apos;enum&amp;apos; | &amp;apos;no-schema&amp;apos;;
    model: LanguageModel;
    enum?: Array&amp;lt;SCHEMA&amp;gt;;
    schema?: z.Schema&amp;lt;SCHEMA, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;SCHEMA&amp;gt;;
    schemaName?: string;
    schemaDescription?: string;
    mode?: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos;;
    experimental_repairText?: RepairTextFunction;
    experimental_telemetry?: TelemetrySettings;
    experimental_providerMetadata?: ProviderMetadata;
    providerOptions?: ProviderOptions;
    /**
     * Internal. For test use only. May change without notice.
     */
    _internal?: {
generateId?: ()
⋮----
enum: enumValues, // rename bc enum is reserved by typescript
⋮----
/**
     * The expected structure of the output.
     *
     * - &amp;apos;object&amp;apos;: Generate a single object that conforms to the schema.
     * - &amp;apos;array&amp;apos;: Generate an array of objects that conform to the schema.
     * - &amp;apos;no-schema&amp;apos;: Generate any JSON object. No schema is specified.
     *
     * Default is &amp;apos;object&amp;apos; if not specified.
     */
⋮----
/**
     * Internal. For test use only. May change without notice.
     */
⋮----
// automatically set mode to &amp;apos;json&amp;apos; for no-schema output
⋮----
// specific settings that only make sense on the outer level:
⋮----
// use the default provider mode when the mode is set to &amp;apos;auto&amp;apos; or unspecified
⋮----
modelSupportsUrl: model.supportsUrl?.bind(model), // support &amp;apos;this&amp;apos; context
⋮----
// standardized gen-ai llm span attributes:
⋮----
// Add response information to the span:
⋮----
// standardized gen-ai llm span attributes:
⋮----
modelSupportsUrl: model.supportsUrl?.bind(model), // support &amp;apos;this&amp;apos; context,
⋮----
// standardized gen-ai llm span attributes:
⋮----
// Add response information to the span:
⋮----
// standardized gen-ai llm span attributes:
⋮----
function processResult(result: string): RESULT
⋮----
// Add response information to the span:
⋮----
class DefaultGenerateObjectResult&amp;lt;T&amp;gt; implements GenerateObjectResult&amp;lt;T&amp;gt;
⋮----
constructor(options: {
    object: GenerateObjectResult&amp;lt;T&amp;gt;[&amp;apos;object&amp;apos;];
    finishReason: GenerateObjectResult&amp;lt;T&amp;gt;[&amp;apos;finishReason&amp;apos;];
    usage: GenerateObjectResult&amp;lt;T&amp;gt;[&amp;apos;usage&amp;apos;];
    warnings: GenerateObjectResult&amp;lt;T&amp;gt;[&amp;apos;warnings&amp;apos;];
    logprobs: GenerateObjectResult&amp;lt;T&amp;gt;[&amp;apos;logprobs&amp;apos;];
    providerMetadata: GenerateObjectResult&amp;lt;T&amp;gt;[&amp;apos;providerMetadata&amp;apos;];
    response: GenerateObjectResult&amp;lt;T&amp;gt;[&amp;apos;response&amp;apos;];
    request: GenerateObjectResult&amp;lt;T&amp;gt;[&amp;apos;request&amp;apos;];
})
toJsonResponse(init?: ResponseInit): Response&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/inject-json-instruction.test.ts&quot;&gt;import { JSONSchema7 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { injectJsonInstruction } from &amp;apos;./inject-json-instruction&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/inject-json-instruction.ts&quot;&gt;import { JSONSchema7 } from &amp;apos;@ai-sdk/provider&amp;apos;;
⋮----
export function injectJsonInstruction({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,
  schemaSuffix = schema != null
    ? DEFAULT_SCHEMA_SUFFIX
    : DEFAULT_GENERIC_SUFFIX,
}: {
  prompt?: string;
  schema?: JSONSchema7;
  schemaPrefix?: string;
  schemaSuffix?: string;
}): string
⋮----
prompt != null &amp;amp;&amp;amp; prompt.length &amp;gt; 0 ? &amp;apos;&amp;apos; : undefined, // add a newline if prompt is not null&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/output-strategy.ts&quot;&gt;import {
  isJSONArray,
  isJSONObject,
  JSONObject,
  JSONSchema7,
  JSONValue,
  TypeValidationError,
  UnsupportedFunctionalityError,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { safeValidateTypes, ValidationResult } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { asSchema, DeepPartial, Schema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { NoObjectGeneratedError } from &amp;apos;../../errors/no-object-generated-error&amp;apos;;
import {
  AsyncIterableStream,
  createAsyncIterableStream,
} from &amp;apos;../util/async-iterable-stream&amp;apos;;
import { ObjectStreamPart } from &amp;apos;./stream-object-result&amp;apos;;
import {
  FinishReason,
  LanguageModelResponseMetadata,
  LanguageModelUsage,
} from &amp;apos;../types&amp;apos;;
export interface OutputStrategy&amp;lt;PARTIAL, RESULT, ELEMENT_STREAM&amp;gt; {
  readonly type: &amp;apos;object&amp;apos; | &amp;apos;array&amp;apos; | &amp;apos;enum&amp;apos; | &amp;apos;no-schema&amp;apos;;
  readonly jsonSchema: JSONSchema7 | undefined;
  validatePartialResult({
    value,
    textDelta,
    isFinalDelta,
  }: {
    value: JSONValue;
    textDelta: string;
    isFirstDelta: boolean;
    isFinalDelta: boolean;
    latestObject: PARTIAL | undefined;
  }): ValidationResult&amp;lt;{
    partial: PARTIAL;
    textDelta: string;
  }&amp;gt;;
  validateFinalResult(
    value: JSONValue | undefined,
    context: {
      text: string;
      response: LanguageModelResponseMetadata;
      usage: LanguageModelUsage;
    },
  ): ValidationResult&amp;lt;RESULT&amp;gt;;
  createElementStream(
    originalStream: ReadableStream&amp;lt;ObjectStreamPart&amp;lt;PARTIAL&amp;gt;&amp;gt;,
  ): ELEMENT_STREAM;
}
⋮----
validatePartialResult({
    value,
    textDelta,
    isFinalDelta,
  }: {
    value: JSONValue;
    textDelta: string;
    isFirstDelta: boolean;
    isFinalDelta: boolean;
    latestObject: PARTIAL | undefined;
}): ValidationResult&amp;lt;
validateFinalResult(
    value: JSONValue | undefined,
    context: {
      text: string;
      response: LanguageModelResponseMetadata;
      usage: LanguageModelUsage;
    },
  ): ValidationResult&amp;lt;RESULT&amp;gt;;
createElementStream(
    originalStream: ReadableStream&amp;lt;ObjectStreamPart&amp;lt;PARTIAL&amp;gt;&amp;gt;,
  ): ELEMENT_STREAM;
⋮----
validateFinalResult(
    value: JSONValue | undefined,
    context: {
      text: string;
      response: LanguageModelResponseMetadata;
      usage: LanguageModelUsage;
      finishReason: FinishReason;
    },
): ValidationResult&amp;lt;JSONValue&amp;gt;
createElementStream()
⋮----
const objectOutputStrategy = &amp;lt;OBJECT&amp;gt;(
  schema: Schema&amp;lt;OBJECT&amp;gt;,
): OutputStrategy&amp;lt;DeepPartial&amp;lt;OBJECT&amp;gt;, OBJECT, never&amp;gt; =&amp;gt; (
⋮----
// Note: currently no validation of partial results:
⋮----
validateFinalResult(value: JSONValue | undefined): ValidationResult&amp;lt;OBJECT&amp;gt;
⋮----
const arrayOutputStrategy = &amp;lt;ELEMENT&amp;gt;(
  schema: Schema&amp;lt;ELEMENT&amp;gt;,
): OutputStrategy&amp;lt;ELEMENT[], ELEMENT[], AsyncIterableStream&amp;lt;ELEMENT&amp;gt;&amp;gt; =&amp;gt;
⋮----
// remove $schema from schema.jsonSchema:
⋮----
// wrap in object that contains array of elements, since most LLMs will not
// be able to generate an array directly:
// possible future optimization: use arrays directly when model supports grammar-guided generation
⋮----
// check that the value is an object that contains an array of elements:
⋮----
// special treatment for last processed element:
// ignore parse or validation failures, since they indicate that the
// last element is incomplete and should not be included in the result,
// unless it is the final delta
⋮----
// calculate delta:
⋮----
.slice(publishedElementCount) // only new elements
⋮----
validateFinalResult(
      value: JSONValue | undefined,
): ValidationResult&amp;lt;Array&amp;lt;ELEMENT&amp;gt;&amp;gt;
⋮----
// check that the value is an object that contains an array of elements:
⋮----
// check that each element in the array is of the correct type:
⋮----
createElementStream(
      originalStream: ReadableStream&amp;lt;ObjectStreamPart&amp;lt;ELEMENT[]&amp;gt;&amp;gt;,
)
⋮----
transform(chunk, controller)
⋮----
// publish new elements one by one:
⋮----
case &amp;apos;error&amp;apos;: // suppress error (use onError instead)
⋮----
const enumOutputStrategy = &amp;lt;ENUM extends string&amp;gt;(
  enumValues: Array&amp;lt;ENUM&amp;gt;,
): OutputStrategy&amp;lt;ENUM, ENUM, never&amp;gt; =&amp;gt;
⋮----
// wrap in object that contains result, since most LLMs will not
// be able to generate an enum value directly:
// possible future optimization: use enums directly when model supports top-level enums
⋮----
validateFinalResult(value: JSONValue | undefined): ValidationResult&amp;lt;ENUM&amp;gt;
⋮----
// check that the value is an object that contains an array of elements:
⋮----
validatePartialResult()
⋮----
// no streaming in enum mode
⋮----
// no streaming in enum mode
⋮----
export function getOutputStrategy&amp;lt;SCHEMA&amp;gt;({
  output,
  schema,
  enumValues,
}: {
  output: &amp;apos;object&amp;apos; | &amp;apos;array&amp;apos; | &amp;apos;enum&amp;apos; | &amp;apos;no-schema&amp;apos;;
  schema?: z.Schema&amp;lt;SCHEMA, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;SCHEMA&amp;gt;;
  enumValues?: Array&amp;lt;SCHEMA&amp;gt;;
}): OutputStrategy&amp;lt;any, any, any&amp;gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/stream-object-result.ts&quot;&gt;import { ServerResponse } from &amp;apos;http&amp;apos;;
import {
  CallWarning,
  FinishReason,
  LanguageModelRequestMetadata,
  LanguageModelResponseMetadata,
  LogProbs,
  ProviderMetadata,
} from &amp;apos;../types&amp;apos;;
import { LanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
import { AsyncIterableStream } from &amp;apos;../util/async-iterable-stream&amp;apos;;
/**
The result of a `streamObject` call that contains the partial object stream and additional information.
 */
export interface StreamObjectResult&amp;lt;PARTIAL, RESULT, ELEMENT_STREAM&amp;gt; {
  /**
  Warnings from the model provider (e.g. unsupported settings)
     */
  readonly warnings: Promise&amp;lt;CallWarning[] | undefined&amp;gt;;
  /**
  The token usage of the generated response. Resolved when the response is finished.
     */
  readonly usage: Promise&amp;lt;LanguageModelUsage&amp;gt;;
  /**
Additional provider-specific metadata. They are passed through
from the provider to the AI SDK and enable provider-specific
results that can be fully encapsulated in the provider.
   */
  readonly providerMetadata: Promise&amp;lt;ProviderMetadata | undefined&amp;gt;;
  /**
@deprecated Use `providerMetadata` instead.
   */
  readonly experimental_providerMetadata: Promise&amp;lt;ProviderMetadata | undefined&amp;gt;;
  /**
Additional request information from the last step.
 */
  readonly request: Promise&amp;lt;LanguageModelRequestMetadata&amp;gt;;
  /**
Additional response information.
 */
  readonly response: Promise&amp;lt;LanguageModelResponseMetadata&amp;gt;;
  /**
  The generated object (typed according to the schema). Resolved when the response is finished.
     */
  readonly object: Promise&amp;lt;RESULT&amp;gt;;
  /**
  Stream of partial objects. It gets more complete as the stream progresses.
  Note that the partial object is not validated.
  If you want to be certain that the actual content matches your schema, you need to implement your own validation for partial results.
     */
  readonly partialObjectStream: AsyncIterableStream&amp;lt;PARTIAL&amp;gt;;
  /**
   * Stream over complete array elements. Only available if the output strategy is set to `array`.
   */
  readonly elementStream: ELEMENT_STREAM;
  /**
  Text stream of the JSON representation of the generated object. It contains text chunks.
  When the stream is finished, the object is valid JSON that can be parsed.
     */
  readonly textStream: AsyncIterableStream&amp;lt;string&amp;gt;;
  /**
  Stream of different types of events, including partial objects, errors, and finish events.
  Only errors that stop the stream, such as network errors, are thrown.
     */
  readonly fullStream: AsyncIterableStream&amp;lt;ObjectStreamPart&amp;lt;PARTIAL&amp;gt;&amp;gt;;
  /**
  Writes text delta output to a Node.js response-like object.
  It sets a `Content-Type` header to `text/plain; charset=utf-8` and
  writes each text delta as a separate chunk.
  @param response A Node.js response-like object (ServerResponse).
  @param init Optional headers, status code, and status text.
     */
  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit): void;
  /**
  Creates a simple text stream response.
  The response has a `Content-Type` header set to `text/plain; charset=utf-8`.
  Each text delta is encoded as UTF-8 and sent as a separate chunk.
  Non-text-delta events are ignored.
  @param init Optional headers, status code, and status text.
     */
  toTextStreamResponse(init?: ResponseInit): Response;
}
⋮----
/**
  Warnings from the model provider (e.g. unsupported settings)
     */
⋮----
/**
  The token usage of the generated response. Resolved when the response is finished.
     */
⋮----
/**
Additional provider-specific metadata. They are passed through
from the provider to the AI SDK and enable provider-specific
results that can be fully encapsulated in the provider.
   */
⋮----
/**
@deprecated Use `providerMetadata` instead.
   */
⋮----
/**
Additional request information from the last step.
 */
⋮----
/**
Additional response information.
 */
⋮----
/**
  The generated object (typed according to the schema). Resolved when the response is finished.
     */
⋮----
/**
  Stream of partial objects. It gets more complete as the stream progresses.
  Note that the partial object is not validated.
  If you want to be certain that the actual content matches your schema, you need to implement your own validation for partial results.
     */
⋮----
/**
   * Stream over complete array elements. Only available if the output strategy is set to `array`.
   */
⋮----
/**
  Text stream of the JSON representation of the generated object. It contains text chunks.
  When the stream is finished, the object is valid JSON that can be parsed.
     */
⋮----
/**
  Stream of different types of events, including partial objects, errors, and finish events.
  Only errors that stop the stream, such as network errors, are thrown.
     */
⋮----
/**
  Writes text delta output to a Node.js response-like object.
  It sets a `Content-Type` header to `text/plain; charset=utf-8` and
  writes each text delta as a separate chunk.
  @param response A Node.js response-like object (ServerResponse).
  @param init Optional headers, status code, and status text.
     */
pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit): void;
/**
  Creates a simple text stream response.
  The response has a `Content-Type` header set to `text/plain; charset=utf-8`.
  Each text delta is encoded as UTF-8 and sent as a separate chunk.
  Non-text-delta events are ignored.
  @param init Optional headers, status code, and status text.
     */
toTextStreamResponse(init?: ResponseInit): Response;
⋮----
export type ObjectStreamPart&amp;lt;PARTIAL&amp;gt; =
  | {
      type: &amp;apos;object&amp;apos;;
      object: PARTIAL;
    }
  | {
      type: &amp;apos;text-delta&amp;apos;;
      textDelta: string;
    }
  | {
      type: &amp;apos;error&amp;apos;;
      error: unknown;
    }
  | {
      type: &amp;apos;finish&amp;apos;;
      finishReason: FinishReason;
      logprobs?: LogProbs;
      usage: LanguageModelUsage;
      response: LanguageModelResponseMetadata;
      providerMetadata?: ProviderMetadata;
    };&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/stream-object.test.ts&quot;&gt;import {
  convertArrayToReadableStream,
  convertAsyncIterableToArray,
  convertReadableStreamToArray,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { jsonSchema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import assert, { fail } from &amp;apos;node:assert&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import {
  NoObjectGeneratedError,
  verifyNoObjectGeneratedError,
} from &amp;apos;../../errors/no-object-generated-error&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
import { createMockServerResponse } from &amp;apos;../test/mock-server-response&amp;apos;;
import { MockTracer } from &amp;apos;../test/mock-tracer&amp;apos;;
import { AsyncIterableStream } from &amp;apos;../util/async-iterable-stream&amp;apos;;
import { streamObject } from &amp;apos;./stream-object&amp;apos;;
import { StreamObjectResult } from &amp;apos;./stream-object-result&amp;apos;;
⋮----
onError(event)
⋮----
// consume stream
⋮----
// consume stream (runs in parallel)
⋮----
// consume stream (runs in parallel)
⋮----
// consume stream (runs in parallel)
⋮----
// consume stream (runs in parallel)
⋮----
// consume stream (runs in parallel)
⋮----
// consume stream (runs in parallel)
⋮----
// consume stream (runs in parallel)
⋮----
// consume stream (runs in parallel)
⋮----
// consume stream (runs in parallel)
⋮----
// unhandled promise rejection should not be thrown (Vitest does this automatically)
⋮----
// consume stream
⋮----
// consume stream
⋮----
// consume expected error rejection
⋮----
// first element:
⋮----
// second element:
⋮----
// third element:
⋮----
// end of array
⋮----
// finish
⋮----
// consume stream
⋮----
// finish
⋮----
// consume stream
⋮----
// consume stream
⋮----
// consume stream
⋮----
// consume stream
⋮----
// consume stream
⋮----
// consume stream
⋮----
class MockLanguageModelWithImageSupport extends MockLanguageModelV1
⋮----
constructor()
⋮----
supportsUrl(url: URL)
⋮----
// Reference &amp;apos;this&amp;apos; to verify context&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/stream-object.ts&quot;&gt;import {
  JSONValue,
  LanguageModelV1CallOptions,
  LanguageModelV1FinishReason,
  LanguageModelV1StreamPart,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { createIdGenerator } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import {
  DeepPartial,
  Schema,
  isDeepEqualData,
  parsePartialJson,
} from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { ServerResponse } from &amp;apos;http&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { NoObjectGeneratedError } from &amp;apos;../../errors/no-object-generated-error&amp;apos;;
import { DelayedPromise } from &amp;apos;../../util/delayed-promise&amp;apos;;
import { CallSettings } from &amp;apos;../prompt/call-settings&amp;apos;;
import { convertToLanguageModelPrompt } from &amp;apos;../prompt/convert-to-language-model-prompt&amp;apos;;
import { prepareCallSettings } from &amp;apos;../prompt/prepare-call-settings&amp;apos;;
import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { Prompt } from &amp;apos;../prompt/prompt&amp;apos;;
import { standardizePrompt } from &amp;apos;../prompt/standardize-prompt&amp;apos;;
import { assembleOperationName } from &amp;apos;../telemetry/assemble-operation-name&amp;apos;;
import { getBaseTelemetryAttributes } from &amp;apos;../telemetry/get-base-telemetry-attributes&amp;apos;;
import { getTracer } from &amp;apos;../telemetry/get-tracer&amp;apos;;
import { recordSpan } from &amp;apos;../telemetry/record-span&amp;apos;;
import { selectTelemetryAttributes } from &amp;apos;../telemetry/select-telemetry-attributes&amp;apos;;
import { TelemetrySettings } from &amp;apos;../telemetry/telemetry-settings&amp;apos;;
import {
  CallWarning,
  FinishReason,
  LanguageModel,
  LogProbs,
} from &amp;apos;../types/language-model&amp;apos;;
import { LanguageModelRequestMetadata } from &amp;apos;../types/language-model-request-metadata&amp;apos;;
import { LanguageModelResponseMetadata } from &amp;apos;../types/language-model-response-metadata&amp;apos;;
import { ProviderMetadata, ProviderOptions } from &amp;apos;../types/provider-metadata&amp;apos;;
import {
  LanguageModelUsage,
  calculateLanguageModelUsage,
} from &amp;apos;../types/usage&amp;apos;;
import {
  AsyncIterableStream,
  createAsyncIterableStream,
} from &amp;apos;../util/async-iterable-stream&amp;apos;;
import { createStitchableStream } from &amp;apos;../util/create-stitchable-stream&amp;apos;;
import { now as originalNow } from &amp;apos;../util/now&amp;apos;;
import { prepareOutgoingHttpHeaders } from &amp;apos;../util/prepare-outgoing-http-headers&amp;apos;;
import { prepareResponseHeaders } from &amp;apos;../util/prepare-response-headers&amp;apos;;
import { writeToServerResponse } from &amp;apos;../util/write-to-server-response&amp;apos;;
import { injectJsonInstruction } from &amp;apos;./inject-json-instruction&amp;apos;;
import { OutputStrategy, getOutputStrategy } from &amp;apos;./output-strategy&amp;apos;;
import { ObjectStreamPart, StreamObjectResult } from &amp;apos;./stream-object-result&amp;apos;;
import { validateObjectGenerationInput } from &amp;apos;./validate-object-generation-input&amp;apos;;
import { stringifyForTelemetry } from &amp;apos;../prompt/stringify-for-telemetry&amp;apos;;
⋮----
/**
Callback that is set using the `onError` option.
@param event - The event that is passed to the callback.
 */
export type StreamObjectOnErrorCallback = (event: {
  error: unknown;
}) =&amp;gt; Promise&amp;lt;void&amp;gt; | void;
/**
Callback that is set using the `onFinish` option.
@param event - The event that is passed to the callback.
 */
export type StreamObjectOnFinishCallback&amp;lt;RESULT&amp;gt; = (event: {
  /**
The token usage of the generated response.
*/
  usage: LanguageModelUsage;
  /**
The generated object. Can be undefined if the final object does not match the schema.
*/
  object: RESULT | undefined;
  /**
Optional error object. This is e.g. a TypeValidationError when the final object does not match the schema.
*/
  error: unknown | undefined;
  /**
Response metadata.
 */
  response: LanguageModelResponseMetadata;
  /**
Warnings from the model provider (e.g. unsupported settings).
*/
  warnings?: CallWarning[];
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
*/
  providerMetadata: ProviderMetadata | undefined;
  /**
@deprecated Use `providerMetadata` instead.
*/
  experimental_providerMetadata?: ProviderMetadata;
}) =&amp;gt; Promise&amp;lt;void&amp;gt; | void;
⋮----
/**
The token usage of the generated response.
*/
⋮----
/**
The generated object. Can be undefined if the final object does not match the schema.
*/
⋮----
/**
Optional error object. This is e.g. a TypeValidationError when the final object does not match the schema.
*/
⋮----
/**
Response metadata.
 */
⋮----
/**
Warnings from the model provider (e.g. unsupported settings).
*/
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
*/
⋮----
/**
@deprecated Use `providerMetadata` instead.
*/
⋮----
/**
Generate a structured, typed object for a given prompt and schema using a language model.
This function streams the output. If you do not want to stream the output, use `generateObject` instead.
@return
A result object for accessing the partial object stream and additional information.
 */
export function streamObject&amp;lt;OBJECT&amp;gt;(
  options: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
    Prompt &amp;amp; {
      output?: &amp;apos;object&amp;apos; | undefined;
      /**
The language model to use.
     */
      model: LanguageModel;
      /**
The schema of the object that the model should generate.
 */
      schema: z.Schema&amp;lt;OBJECT, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;OBJECT&amp;gt;;
      /**
Optional name of the output that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema name.
     */
      schemaName?: string;
      /**
Optional description of the output that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema description.
 */
      schemaDescription?: string;
      /**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
      mode?: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos;;
      /**
Optional telemetry configuration (experimental).
     */
      experimental_telemetry?: TelemetrySettings;
      /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
      providerOptions?: ProviderOptions;
      /**
@deprecated Use `providerOptions` instead.
*/
      experimental_providerMetadata?: ProviderMetadata;
      /**
Callback that is invoked when an error occurs during streaming.
You can use it to log errors.
The stream processing will pause until the callback promise is resolved.
     */
      onError?: StreamObjectOnErrorCallback;
      /**
Callback that is called when the LLM response and the final object validation are finished.
     */
      onFinish?: StreamObjectOnFinishCallback&amp;lt;OBJECT&amp;gt;;
      /**
       * Internal. For test use only. May change without notice.
       */
      _internal?: {
generateId?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The schema of the object that the model should generate.
 */
⋮----
/**
Optional name of the output that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema name.
     */
⋮----
/**
Optional description of the output that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema description.
 */
⋮----
/**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
⋮----
/**
Optional telemetry configuration (experimental).
     */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
Callback that is invoked when an error occurs during streaming.
You can use it to log errors.
The stream processing will pause until the callback promise is resolved.
     */
⋮----
/**
Callback that is called when the LLM response and the final object validation are finished.
     */
⋮----
/**
       * Internal. For test use only. May change without notice.
       */
⋮----
/**
Generate an array with structured, typed elements for a given prompt and element schema using a language model.
This function streams the output. If you do not want to stream the output, use `generateObject` instead.
@return
A result object for accessing the partial object stream and additional information.
 */
export function streamObject&amp;lt;ELEMENT&amp;gt;(
  options: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
    Prompt &amp;amp; {
      output: &amp;apos;array&amp;apos;;
      /**
The language model to use.
     */
      model: LanguageModel;
      /**
The element schema of the array that the model should generate.
 */
      schema: z.Schema&amp;lt;ELEMENT, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;ELEMENT&amp;gt;;
      /**
Optional name of the array that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema name.
     */
      schemaName?: string;
      /**
Optional description of the array that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema description.
 */
      schemaDescription?: string;
      /**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
      mode?: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos;;
      /**
Optional telemetry configuration (experimental).
     */
      experimental_telemetry?: TelemetrySettings;
      /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
      providerOptions?: ProviderOptions;
      /**
@deprecated Use `providerOptions` instead.
*/
      experimental_providerMetadata?: ProviderMetadata;
      /**
Callback that is invoked when an error occurs during streaming.
You can use it to log errors.
The stream processing will pause until the callback promise is resolved.
     */
      onError?: StreamObjectOnErrorCallback;
      /**
Callback that is called when the LLM response and the final object validation are finished.
     */
      onFinish?: StreamObjectOnFinishCallback&amp;lt;Array&amp;lt;ELEMENT&amp;gt;&amp;gt;;
      /**
       * Internal. For test use only. May change without notice.
       */
      _internal?: {
generateId?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The element schema of the array that the model should generate.
 */
⋮----
/**
Optional name of the array that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema name.
     */
⋮----
/**
Optional description of the array that should be generated.
Used by some providers for additional LLM guidance, e.g.
via tool or schema description.
 */
⋮----
/**
The mode to use for object generation.
The schema is converted into a JSON schema and used in one of the following ways
- &amp;apos;auto&amp;apos;: The provider will choose the best mode for the model.
- &amp;apos;tool&amp;apos;: A tool with the JSON schema as parameters is provided and the provider is instructed to use it.
- &amp;apos;json&amp;apos;: The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.
Please note that most providers do not support all modes.
Default and recommended: &amp;apos;auto&amp;apos; (best mode for the model).
     */
⋮----
/**
Optional telemetry configuration (experimental).
     */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
Callback that is invoked when an error occurs during streaming.
You can use it to log errors.
The stream processing will pause until the callback promise is resolved.
     */
⋮----
/**
Callback that is called when the LLM response and the final object validation are finished.
     */
⋮----
/**
       * Internal. For test use only. May change without notice.
       */
⋮----
/**
Generate JSON with any schema for a given prompt using a language model.
This function streams the output. If you do not want to stream the output, use `generateObject` instead.
@return
A result object for accessing the partial object stream and additional information.
 */
export function streamObject(
  options: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
    Prompt &amp;amp; {
      output: &amp;apos;no-schema&amp;apos;;
      /**
The language model to use.
     */
      model: LanguageModel;
      /**
The mode to use for object generation. Must be &amp;quot;json&amp;quot; for no-schema output.
     */
      mode?: &amp;apos;json&amp;apos;;
      /**
Optional telemetry configuration (experimental).
     */
      experimental_telemetry?: TelemetrySettings;
      /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
      providerOptions?: ProviderOptions;
      /**
@deprecated Use `providerOptions` instead.
*/
      experimental_providerMetadata?: ProviderMetadata;
      /**
Callback that is invoked when an error occurs during streaming.
You can use it to log errors.
The stream processing will pause until the callback promise is resolved.
     */
      onError?: StreamObjectOnErrorCallback;
      /**
Callback that is called when the LLM response and the final object validation are finished.
     */
      onFinish?: StreamObjectOnFinishCallback&amp;lt;JSONValue&amp;gt;;
      /**
       * Internal. For test use only. May change without notice.
       */
      _internal?: {
generateId?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The mode to use for object generation. Must be &amp;quot;json&amp;quot; for no-schema output.
     */
⋮----
/**
Optional telemetry configuration (experimental).
     */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
Callback that is invoked when an error occurs during streaming.
You can use it to log errors.
The stream processing will pause until the callback promise is resolved.
     */
⋮----
/**
Callback that is called when the LLM response and the final object validation are finished.
     */
⋮----
/**
       * Internal. For test use only. May change without notice.
       */
⋮----
export function streamObject&amp;lt;SCHEMA, PARTIAL, RESULT, ELEMENT_STREAM&amp;gt;({
  model,
  schema: inputSchema,
  schemaName,
  schemaDescription,
  mode,
  output = &amp;apos;object&amp;apos;,
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  headers,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  onError,
  onFinish,
  _internal: {
    generateId = originalGenerateId,
    currentDate = () =&amp;gt; new Date(),
    now = originalNow,
  } = {},
  ...settings
}: Omit&amp;lt;CallSettings, &amp;apos;stopSequences&amp;apos;&amp;gt; &amp;amp;
  Prompt &amp;amp; {
    /**
     * The expected structure of the output.
     *
     * - &amp;apos;object&amp;apos;: Generate a single object that conforms to the schema.
     * - &amp;apos;array&amp;apos;: Generate an array of objects that conform to the schema.
     * - &amp;apos;no-schema&amp;apos;: Generate any JSON object. No schema is specified.
     *
     * Default is &amp;apos;object&amp;apos; if not specified.
     */
    output?: &amp;apos;object&amp;apos; | &amp;apos;array&amp;apos; | &amp;apos;no-schema&amp;apos;;
    model: LanguageModel;
    schema?: z.Schema&amp;lt;SCHEMA, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;SCHEMA&amp;gt;;
    schemaName?: string;
    schemaDescription?: string;
    mode?: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos;;
    experimental_telemetry?: TelemetrySettings;
    providerOptions?: ProviderOptions;
    experimental_providerMetadata?: ProviderMetadata;
    onError?: StreamObjectOnErrorCallback;
    onFinish?: StreamObjectOnFinishCallback&amp;lt;RESULT&amp;gt;;
    _internal?: {
generateId?: ()
⋮----
/**
     * The expected structure of the output.
     *
     * - &amp;apos;object&amp;apos;: Generate a single object that conforms to the schema.
     * - &amp;apos;array&amp;apos;: Generate an array of objects that conform to the schema.
     * - &amp;apos;no-schema&amp;apos;: Generate any JSON object. No schema is specified.
     *
     * Default is &amp;apos;object&amp;apos; if not specified.
     */
⋮----
// automatically set mode to &amp;apos;json&amp;apos; for no-schema output
⋮----
class DefaultStreamObjectResult&amp;lt;PARTIAL, RESULT, ELEMENT_STREAM&amp;gt;
implements StreamObjectResult&amp;lt;PARTIAL, RESULT, ELEMENT_STREAM&amp;gt;
⋮----
constructor({
    model,
    headers,
    telemetry,
    settings,
    maxRetries: maxRetriesArg,
    abortSignal,
    outputStrategy,
    system,
    prompt,
    messages,
    schemaName,
    schemaDescription,
    providerOptions,
    mode,
    onError,
    onFinish,
    generateId,
    currentDate,
    now,
  }: {
    model: LanguageModel;
    telemetry: TelemetrySettings | undefined;
    headers: Record&amp;lt;string, string | undefined&amp;gt; | undefined;
    settings: Omit&amp;lt;CallSettings, &amp;apos;abortSignal&amp;apos; | &amp;apos;headers&amp;apos;&amp;gt;;
    maxRetries: number | undefined;
    abortSignal: AbortSignal | undefined;
    outputStrategy: OutputStrategy&amp;lt;PARTIAL, RESULT, ELEMENT_STREAM&amp;gt;;
    system: Prompt[&amp;apos;system&amp;apos;];
    prompt: Prompt[&amp;apos;prompt&amp;apos;];
    messages: Prompt[&amp;apos;messages&amp;apos;];
    schemaName: string | undefined;
    schemaDescription: string | undefined;
    providerOptions: ProviderOptions | undefined;
    mode: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos; | undefined;
    onError: StreamObjectOnErrorCallback | undefined;
    onFinish: StreamObjectOnFinishCallback&amp;lt;RESULT&amp;gt; | undefined;
generateId: ()
⋮----
transform(chunk, controller)
⋮----
// specific settings that only make sense on the outer level:
⋮----
// use the default provider mode when the mode is set to &amp;apos;auto&amp;apos; or unspecified
⋮----
modelSupportsUrl: model.supportsUrl?.bind(model), // support &amp;apos;this&amp;apos; context
⋮----
modelSupportsUrl: model.supportsUrl?.bind(model), // support &amp;apos;this&amp;apos; context,
⋮----
// standardized gen-ai llm span attributes:
⋮----
// store information for onFinish callback:
⋮----
// pipe chunks through a transformation stream that extracts metadata:
⋮----
// Keep track of raw parse result before type validation, since e.g. Zod might
// change the object by mapping properties.
⋮----
async transform(chunk, controller): Promise&amp;lt;void&amp;gt;
⋮----
// Telemetry event for first chunk:
⋮----
// process partial text chunks
⋮----
// inside inner check to correctly parse the final element in array mode:
⋮----
// send final text delta:
⋮----
// store finish reason for telemetry:
⋮----
// store usage and metadata for promises and onFinish callback:
⋮----
// resolve promises that can be resolved now:
⋮----
// resolve the object promise with the latest object:
⋮----
// invoke onFinish callback and resolve toolResults promise when the stream is about to close:
async flush(controller)
⋮----
// standardized gen-ai llm span attributes:
⋮----
// finish doStreamSpan before other operations for correct timing:
⋮----
// Add response information to the root span:
⋮----
// call onFinish callback:
⋮----
// add an empty stream with an error to break the stream:
⋮----
start(controller)
⋮----
get object()
get usage()
get experimental_providerMetadata()
get providerMetadata()
get warnings()
get request()
get response()
get partialObjectStream(): AsyncIterableStream&amp;lt;PARTIAL&amp;gt;
⋮----
case &amp;apos;error&amp;apos;: // suppress error (use onError instead)
⋮----
get elementStream(): ELEMENT_STREAM
get textStream(): AsyncIterableStream&amp;lt;string&amp;gt;
⋮----
case &amp;apos;error&amp;apos;: // suppress error (use onError instead)
⋮----
get fullStream(): AsyncIterableStream&amp;lt;ObjectStreamPart&amp;lt;PARTIAL&amp;gt;&amp;gt;
pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit)
toTextStreamResponse(init?: ResponseInit): Response
⋮----
export type ObjectStreamInputPart =
  | {
      type: &amp;apos;error&amp;apos;;
      error: unknown;
    }
  | {
      type: &amp;apos;response-metadata&amp;apos;;
      id?: string;
      timestamp?: Date;
      modelId?: string;
    }
  | {
      type: &amp;apos;finish&amp;apos;;
      finishReason: FinishReason;
      logprobs?: LogProbs;
      usage: LanguageModelUsage;
      providerMetadata?: ProviderMetadata;
    };&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-object/validate-object-generation-input.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import { InvalidArgumentError } from &amp;apos;../../errors/invalid-argument-error&amp;apos;;
import { Schema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
export function validateObjectGenerationInput({
  output,
  mode,
  schema,
  schemaName,
  schemaDescription,
  enumValues,
}: {
  output?: &amp;apos;object&amp;apos; | &amp;apos;array&amp;apos; | &amp;apos;enum&amp;apos; | &amp;apos;no-schema&amp;apos;;
  schema?: z.Schema&amp;lt;any, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;any&amp;gt;;
  schemaName?: string;
  schemaDescription?: string;
  enumValues?: Array&amp;lt;unknown&amp;gt;;
  mode?: &amp;apos;auto&amp;apos; | &amp;apos;json&amp;apos; | &amp;apos;tool&amp;apos;;
})&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-speech/generate-speech-result.ts&quot;&gt;import { JSONValue } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { SpeechModelResponseMetadata } from &amp;apos;../types/speech-model-response-metadata&amp;apos;;
import { SpeechWarning } from &amp;apos;../types&amp;apos;;
import { GeneratedAudioFile } from &amp;apos;./generated-audio-file&amp;apos;;
/**
The result of a `generateSpeech` call.
It contains the audio data and additional information.
 */
export interface SpeechResult {
  /**
   * The audio data as a base64 encoded string or binary data.
   */
  readonly audio: GeneratedAudioFile;
  /**
  Warnings for the call, e.g. unsupported settings.
     */
  readonly warnings: Array&amp;lt;SpeechWarning&amp;gt;;
  /**
  Response metadata from the provider. There may be multiple responses if we made multiple calls to the model.
   */
  readonly responses: Array&amp;lt;SpeechModelResponseMetadata&amp;gt;;
  /**
  Provider metadata from the provider.
   */
  readonly providerMetadata: Record&amp;lt;string, Record&amp;lt;string, JSONValue&amp;gt;&amp;gt;;
}
⋮----
/**
   * The audio data as a base64 encoded string or binary data.
   */
⋮----
/**
  Warnings for the call, e.g. unsupported settings.
     */
⋮----
/**
  Response metadata from the provider. There may be multiple responses if we made multiple calls to the model.
   */
⋮----
/**
  Provider metadata from the provider.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-speech/generate-speech.test.ts&quot;&gt;import {
  JSONValue,
  SpeechModelV1,
  SpeechModelV1CallWarning,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { MockSpeechModelV1 } from &amp;apos;../test/mock-speech-model-v1&amp;apos;;
import { generateSpeech } from &amp;apos;./generate-speech&amp;apos;;
import {
  GeneratedAudioFile,
  DefaultGeneratedAudioFile,
} from &amp;apos;./generated-audio-file&amp;apos;;
const audio = new Uint8Array([1, 2, 3, 4]); // Sample audio data
⋮----
const createMockResponse = (options: {
  audio: GeneratedAudioFile;
  warnings?: SpeechModelV1CallWarning[];
  timestamp?: Date;
  modelId?: string;
  headers?: Record&amp;lt;string, string&amp;gt;;
  providerMetadata?: Record&amp;lt;string, Record&amp;lt;string, JSONValue&amp;gt;&amp;gt;;
}) =&amp;gt; (&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-speech/generate-speech.ts&quot;&gt;import { JSONValue, SpeechModelV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { NoSpeechGeneratedError } from &amp;apos;../../errors/no-speech-generated-error&amp;apos;;
import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { ProviderOptions } from &amp;apos;../types/provider-metadata&amp;apos;;
import { SpeechWarning } from &amp;apos;../types/speech-model&amp;apos;;
import { SpeechModelResponseMetadata } from &amp;apos;../types/speech-model-response-metadata&amp;apos;;
import { SpeechResult } from &amp;apos;./generate-speech-result&amp;apos;;
import {
  audioMimeTypeSignatures,
  detectMimeType,
} from &amp;apos;../util/detect-mimetype&amp;apos;;
import {
  DefaultGeneratedAudioFile,
  GeneratedAudioFile,
} from &amp;apos;./generated-audio-file&amp;apos;;
/**
Generates speech audio using a speech model.
@param model - The speech model to use.
@param text - The text to convert to speech.
@param voice - The voice to use for speech generation.
@param outputFormat - The output format to use for speech generation e.g. &amp;quot;mp3&amp;quot;, &amp;quot;wav&amp;quot;, etc.
@param instructions - Instructions for the speech generation e.g. &amp;quot;Speak in a slow and steady tone&amp;quot;.
@param speed - The speed of the speech generation.
@param providerOptions - Additional provider-specific options that are passed through to the provider
as body parameters.
@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.
@param abortSignal - An optional abort signal that can be used to cancel the call.
@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.
@returns A result object that contains the generated audio data.
 */
export async function generateSpeech({
  model,
  text,
  voice,
  outputFormat,
  instructions,
  speed,
  providerOptions = {},
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
}: {
  /**
The speech model to use.
     */
  model: SpeechModelV1;
  /**
The text to convert to speech.
   */
  text: string;
  /**
The voice to use for speech generation.
   */
  voice?: string;
  /**
   * The desired output format for the audio e.g. &amp;quot;mp3&amp;quot;, &amp;quot;wav&amp;quot;, etc.
   */
outputFormat?: &amp;apos;mp3&amp;apos; | &amp;apos;wav&amp;apos; | (string &amp;amp;
⋮----
/**
The speech model to use.
     */
⋮----
/**
The text to convert to speech.
   */
⋮----
/**
The voice to use for speech generation.
   */
⋮----
/**
   * The desired output format for the audio e.g. &amp;quot;mp3&amp;quot;, &amp;quot;wav&amp;quot;, etc.
   */
⋮----
/**
    Instructions for the speech generation e.g. &amp;quot;Speak in a slow and steady tone&amp;quot;.
  */
⋮----
/**
  The speed of the speech generation.
   */
⋮----
/**
Additional provider-specific options that are passed through to the provider
as body parameters.
The outer record is keyed by the provider name, and the inner
record is keyed by the provider-specific metadata key.
```ts
{
  &amp;quot;openai&amp;quot;: {}
}
```
     */
⋮----
/**
Maximum number of retries per speech model call. Set to 0 to disable retries.
@default 2
   */
⋮----
/**
Abort signal.
 */
⋮----
/**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
⋮----
class DefaultSpeechResult implements SpeechResult
⋮----
constructor(options: {
    audio: GeneratedAudioFile;
    warnings: Array&amp;lt;SpeechWarning&amp;gt;;
    responses: Array&amp;lt;SpeechModelResponseMetadata&amp;gt;;
    providerMetadata: Record&amp;lt;string, Record&amp;lt;string, JSONValue&amp;gt;&amp;gt; | undefined;
})&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-speech/generated-audio-file.ts&quot;&gt;import {
  GeneratedFile,
  DefaultGeneratedFile,
} from &amp;apos;../generate-text/generated-file&amp;apos;;
/**
 * A generated audio file.
 */
export interface GeneratedAudioFile extends GeneratedFile {
  /**
   * Audio format of the file (e.g., &amp;apos;mp3&amp;apos;, &amp;apos;wav&amp;apos;, etc.)
   */
  readonly format: string;
}
⋮----
/**
   * Audio format of the file (e.g., &amp;apos;mp3&amp;apos;, &amp;apos;wav&amp;apos;, etc.)
   */
⋮----
export class DefaultGeneratedAudioFile
extends DefaultGeneratedFile
⋮----
constructor({
    data,
    mimeType,
  }: {
    data: string | Uint8Array;
    mimeType: string;
})
⋮----
// If format is not provided, try to determine it from the mimeType
⋮----
// Handle special cases for audio formats
⋮----
export class DefaultGeneratedAudioFileWithType extends DefaultGeneratedAudioFile
⋮----
constructor(options: {
    data: string | Uint8Array;
    mimeType: string;
    format: string;
})&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-speech/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/generate-text-result.ts&quot;&gt;import {
  CallWarning,
  FinishReason,
  LogProbs,
  ProviderMetadata,
} from &amp;apos;../types&amp;apos;;
import { Source } from &amp;apos;../types/language-model&amp;apos;;
import { LanguageModelRequestMetadata } from &amp;apos;../types/language-model-request-metadata&amp;apos;;
import { LanguageModelResponseMetadata } from &amp;apos;../types/language-model-response-metadata&amp;apos;;
import { LanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
import { GeneratedFile } from &amp;apos;./generated-file&amp;apos;;
import { ReasoningDetail } from &amp;apos;./reasoning-detail&amp;apos;;
import { ResponseMessage, StepResult } from &amp;apos;./step-result&amp;apos;;
import { ToolCallArray } from &amp;apos;./tool-call&amp;apos;;
import { ToolResultArray } from &amp;apos;./tool-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
/**
The result of a `generateText` call.
It contains the generated text, the tool calls that were made during the generation, and the results of the tool calls.
 */
export interface GenerateTextResult&amp;lt;TOOLS extends ToolSet, OUTPUT&amp;gt; {
  /**
The generated text.
     */
  readonly text: string;
  /**
The reasoning text that the model has generated. Can be undefined if the model
has only generated text.
   */
  // TODO v5: rename to `reasoningText`
  readonly reasoning: string | undefined;
  /**
The files that were generated. Empty array if no files were generated.
     */
  readonly files: Array&amp;lt;GeneratedFile&amp;gt;;
  /**
The full reasoning that the model has generated.
   */
  // TODO v5: rename to `reasoning`
  readonly reasoningDetails: Array&amp;lt;ReasoningDetail&amp;gt;;
  /**
Sources that have been used as input to generate the response.
For multi-step generation, the sources are accumulated from all steps.
   */
  readonly sources: Source[];
  /**
The generated structured output. It uses the `experimental_output` specification.
   */
  readonly experimental_output: OUTPUT;
  /**
  The tool calls that were made during the generation.
   */
  readonly toolCalls: ToolCallArray&amp;lt;TOOLS&amp;gt;;
  /**
  The results of the tool calls.
   */
  readonly toolResults: ToolResultArray&amp;lt;TOOLS&amp;gt;;
  /**
  The reason why the generation finished.
   */
  readonly finishReason: FinishReason;
  /**
  The token usage of the generated text.
   */
  readonly usage: LanguageModelUsage;
  /**
  Warnings from the model provider (e.g. unsupported settings)
   */
  readonly warnings: CallWarning[] | undefined;
  /**
Details for all steps.
You can use this to get information about intermediate steps,
such as the tool calls or the response headers.
   */
  readonly steps: Array&amp;lt;StepResult&amp;lt;TOOLS&amp;gt;&amp;gt;;
  /**
Additional request information.
   */
  readonly request: LanguageModelRequestMetadata;
  /**
Additional response information.
   */
  readonly response: LanguageModelResponseMetadata &amp;amp; {
    /**
The response messages that were generated during the call. It consists of an assistant message,
potentially containing tool calls.
When there are tool results, there is an additional tool message with the tool results that are available.
If there are tools that do not have execute functions, they are not included in the tool results and
need to be added separately.
       */
    messages: Array&amp;lt;ResponseMessage&amp;gt;;
    /**
Response body (available only for providers that use HTTP requests).
     */
    body?: unknown;
  };
  /**
Logprobs for the completion.
`undefined` if the mode does not support logprobs or if it was not enabled.
@deprecated Will become a provider extension in the future.
     */
  readonly logprobs: LogProbs | undefined;
  /**
Additional provider-specific metadata. They are passed through
from the provider to the AI SDK and enable provider-specific
results that can be fully encapsulated in the provider.
   */
  readonly providerMetadata: ProviderMetadata | undefined;
  /**
@deprecated Use `providerMetadata` instead.
   */
  readonly experimental_providerMetadata: ProviderMetadata | undefined;
}
⋮----
/**
The generated text.
     */
⋮----
/**
The reasoning text that the model has generated. Can be undefined if the model
has only generated text.
   */
// TODO v5: rename to `reasoningText`
⋮----
/**
The files that were generated. Empty array if no files were generated.
     */
⋮----
/**
The full reasoning that the model has generated.
   */
// TODO v5: rename to `reasoning`
⋮----
/**
Sources that have been used as input to generate the response.
For multi-step generation, the sources are accumulated from all steps.
   */
⋮----
/**
The generated structured output. It uses the `experimental_output` specification.
   */
⋮----
/**
  The tool calls that were made during the generation.
   */
⋮----
/**
  The results of the tool calls.
   */
⋮----
/**
  The reason why the generation finished.
   */
⋮----
/**
  The token usage of the generated text.
   */
⋮----
/**
  Warnings from the model provider (e.g. unsupported settings)
   */
⋮----
/**
Details for all steps.
You can use this to get information about intermediate steps,
such as the tool calls or the response headers.
   */
⋮----
/**
Additional request information.
   */
⋮----
/**
Additional response information.
   */
⋮----
/**
The response messages that were generated during the call. It consists of an assistant message,
potentially containing tool calls.
When there are tool results, there is an additional tool message with the tool results that are available.
If there are tools that do not have execute functions, they are not included in the tool results and
need to be added separately.
       */
⋮----
/**
Response body (available only for providers that use HTTP requests).
     */
⋮----
/**
Logprobs for the completion.
`undefined` if the mode does not support logprobs or if it was not enabled.
@deprecated Will become a provider extension in the future.
     */
⋮----
/**
Additional provider-specific metadata. They are passed through
from the provider to the AI SDK and enable provider-specific
results that can be fully encapsulated in the provider.
   */
⋮----
/**
@deprecated Use `providerMetadata` instead.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/generate-text.test.ts&quot;&gt;import { LanguageModelV1CallOptions } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { mockId } from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { jsonSchema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import assert from &amp;apos;node:assert&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { Output } from &amp;apos;.&amp;apos;;
import { ToolExecutionError } from &amp;apos;../../errors&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
import { MockTracer } from &amp;apos;../test/mock-tracer&amp;apos;;
import { tool } from &amp;apos;../tool/tool&amp;apos;;
import { generateText } from &amp;apos;./generate-text&amp;apos;;
import { GenerateTextResult } from &amp;apos;./generate-text-result&amp;apos;;
import { StepResult } from &amp;apos;./step-result&amp;apos;;
⋮----
// 2nd tool to show typing:
⋮----
// test type inference
⋮----
// test type inference
⋮----
// trailing text is to be discarded, trailing whitespace is to be kept:
⋮----
finishReason: &amp;apos;length&amp;apos;, // trigger continue
⋮----
// case where there is no leading nor trailing whitespace:
⋮----
// test handling of custom response headers:
⋮----
// set up trailing whitespace for next step:
⋮----
// leading whitespace is to be discarded when there is whitespace from previous step
// (for models such as Anthropic that trim trailing whitespace in their inputs):
⋮----
// Abort the operation
⋮----
// 2nd tool to show typing:
⋮----
// test type inference
⋮----
class MockLanguageModelWithImageSupport extends MockLanguageModelV1
⋮----
constructor()
⋮----
supportsUrl(url: URL)
⋮----
// Reference &amp;apos;this&amp;apos; to verify context&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/generate-text.ts&quot;&gt;import { createIdGenerator, IDGenerator } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { Tracer } from &amp;apos;@opentelemetry/api&amp;apos;;
import { InvalidArgumentError } from &amp;apos;../../errors/invalid-argument-error&amp;apos;;
import { NoOutputSpecifiedError } from &amp;apos;../../errors/no-output-specified-error&amp;apos;;
import { ToolExecutionError } from &amp;apos;../../errors/tool-execution-error&amp;apos;;
import { CoreAssistantMessage, CoreMessage } from &amp;apos;../prompt&amp;apos;;
import { CallSettings } from &amp;apos;../prompt/call-settings&amp;apos;;
import { convertToLanguageModelPrompt } from &amp;apos;../prompt/convert-to-language-model-prompt&amp;apos;;
import { prepareCallSettings } from &amp;apos;../prompt/prepare-call-settings&amp;apos;;
import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { prepareToolsAndToolChoice } from &amp;apos;../prompt/prepare-tools-and-tool-choice&amp;apos;;
import { Prompt } from &amp;apos;../prompt/prompt&amp;apos;;
import { standardizePrompt } from &amp;apos;../prompt/standardize-prompt&amp;apos;;
import { assembleOperationName } from &amp;apos;../telemetry/assemble-operation-name&amp;apos;;
import { getBaseTelemetryAttributes } from &amp;apos;../telemetry/get-base-telemetry-attributes&amp;apos;;
import { getTracer } from &amp;apos;../telemetry/get-tracer&amp;apos;;
import { recordSpan } from &amp;apos;../telemetry/record-span&amp;apos;;
import { selectTelemetryAttributes } from &amp;apos;../telemetry/select-telemetry-attributes&amp;apos;;
import { TelemetrySettings } from &amp;apos;../telemetry/telemetry-settings&amp;apos;;
import { LanguageModel, ToolChoice } from &amp;apos;../types&amp;apos;;
import { ProviderMetadata, ProviderOptions } from &amp;apos;../types/provider-metadata&amp;apos;;
import {
  addLanguageModelUsage,
  calculateLanguageModelUsage,
  LanguageModelUsage,
} from &amp;apos;../types/usage&amp;apos;;
import { removeTextAfterLastWhitespace } from &amp;apos;../util/remove-text-after-last-whitespace&amp;apos;;
import { GenerateTextResult } from &amp;apos;./generate-text-result&amp;apos;;
import { DefaultGeneratedFile, GeneratedFile } from &amp;apos;./generated-file&amp;apos;;
import { Output } from &amp;apos;./output&amp;apos;;
import { parseToolCall } from &amp;apos;./parse-tool-call&amp;apos;;
import { asReasoningText, ReasoningDetail } from &amp;apos;./reasoning-detail&amp;apos;;
import { ResponseMessage, StepResult } from &amp;apos;./step-result&amp;apos;;
import { toResponseMessages } from &amp;apos;./to-response-messages&amp;apos;;
import { ToolCallArray } from &amp;apos;./tool-call&amp;apos;;
import { ToolCallRepairFunction } from &amp;apos;./tool-call-repair&amp;apos;;
import { ToolResultArray } from &amp;apos;./tool-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
import { stringifyForTelemetry } from &amp;apos;../prompt/stringify-for-telemetry&amp;apos;;
⋮----
/**
Callback that is set using the `onStepFinish` option.
@param stepResult - The result of the step.
 */
export type GenerateTextOnStepFinishCallback&amp;lt;TOOLS extends ToolSet&amp;gt; = (
  stepResult: StepResult&amp;lt;TOOLS&amp;gt;,
) =&amp;gt; Promise&amp;lt;void&amp;gt; | void;
/**
Generate a text and call tools for a given prompt using a language model.
This function does not stream the output. If you want to stream the output, use `streamText` instead.
@param model - The language model to use.
@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.
@param toolChoice - The tool choice strategy. Default: &amp;apos;auto&amp;apos;.
@param system - A system message that will be part of the prompt.
@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.
@param messages - A list of messages. You can either use `prompt` or `messages` but not both.
@param maxTokens - Maximum number of tokens to generate.
@param temperature - Temperature setting.
The value is passed through to the provider. The range depends on the provider and model.
It is recommended to set either `temperature` or `topP`, but not both.
@param topP - Nucleus sampling.
The value is passed through to the provider. The range depends on the provider and model.
It is recommended to set either `temperature` or `topP`, but not both.
@param topK - Only sample from the top K options for each subsequent token.
Used to remove &amp;quot;long tail&amp;quot; low probability responses.
Recommended for advanced use cases only. You usually only need to use temperature.
@param presencePenalty - Presence penalty setting.
It affects the likelihood of the model to repeat information that is already in the prompt.
The value is passed through to the provider. The range depends on the provider and model.
@param frequencyPenalty - Frequency penalty setting.
It affects the likelihood of the model to repeatedly use the same words or phrases.
The value is passed through to the provider. The range depends on the provider and model.
@param stopSequences - Stop sequences.
If set, the model will stop generating text when one of the stop sequences is generated.
@param seed - The seed (integer) to use for random sampling.
If set and supported by the model, calls will generate deterministic results.
@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.
@param abortSignal - An optional abort signal that can be used to cancel the call.
@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.
@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.
@param experimental_generateMessageId - Generate a unique ID for each message.
@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.
@returns
A result object that contains the generated text, the results of the tool calls, and additional information.
 */
export async function generateText&amp;lt;
  TOOLS extends ToolSet,
  OUTPUT = never,
  OUTPUT_PARTIAL = never,
&amp;gt;({
  model,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  maxSteps = 1,
  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,
  experimental_output: output,
  experimental_continueSteps: continueSteps = false,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  experimental_activeTools: activeTools,
  experimental_prepareStep: prepareStep,
  experimental_repairToolCall: repairToolCall,
  _internal: {
    generateId = originalGenerateId,
    currentDate = () =&amp;gt; new Date(),
  } = {},
  onStepFinish,
  ...settings
}: CallSettings &amp;amp;
  Prompt &amp;amp; {
    /**
The language model to use.
     */
    model: LanguageModel;
    /**
The tools that the model can call. The model needs to support calling tools.
*/
    tools?: TOOLS;
    /**
The tool choice strategy. Default: &amp;apos;auto&amp;apos;.
     */
    toolChoice?: ToolChoice&amp;lt;TOOLS&amp;gt;;
    /**
Maximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.
A maximum number is required to prevent infinite loops in the case of misconfigured tools.
By default, it&amp;apos;s set to 1, which means that only a single LLM call is made.
     */
    maxSteps?: number;
    /**
Generate a unique ID for each message.
     */
    experimental_generateMessageId?: IDGenerator;
    /**
When enabled, the model will perform additional steps if the finish reason is &amp;quot;length&amp;quot; (experimental).
By default, it&amp;apos;s set to false.
     */
    experimental_continueSteps?: boolean;
    /**
Optional telemetry configuration (experimental).
     */
    experimental_telemetry?: TelemetrySettings;
    /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
    providerOptions?: ProviderOptions;
    /**
@deprecated Use `providerOptions` instead.
     */
    experimental_providerMetadata?: ProviderMetadata;
    /**
Limits the tools that are available for the model to call without
changing the tool call and result types in the result.
     */
    experimental_activeTools?: Array&amp;lt;keyof TOOLS&amp;gt;;
    /**
Optional specification for parsing structured outputs from the LLM response.
     */
    experimental_output?: Output&amp;lt;OUTPUT, OUTPUT_PARTIAL&amp;gt;;
    /**
Optional function that you can use to provide different settings for a step.
@param options - The options for the step.
@param options.steps - The steps that have been executed so far.
@param options.stepNumber - The number of the step that is being executed.
@param options.maxSteps - The maximum number of steps.
@param options.model - The model that is being used.
@returns An object that contains the settings for the step.
If you return undefined (or for undefined settings), the settings from the outer level will be used.
    */
    experimental_prepareStep?: (options: {
      steps: Array&amp;lt;StepResult&amp;lt;TOOLS&amp;gt;&amp;gt;;
      stepNumber: number;
      maxSteps: number;
      model: LanguageModel;
    }) =&amp;gt; PromiseLike&amp;lt;
      | {
          model?: LanguageModel;
          toolChoice?: ToolChoice&amp;lt;TOOLS&amp;gt;;
          experimental_activeTools?: Array&amp;lt;keyof TOOLS&amp;gt;;
        }
      | undefined
    &amp;gt;;
    /**
A function that attempts to repair a tool call that failed to parse.
     */
    experimental_repairToolCall?: ToolCallRepairFunction&amp;lt;TOOLS&amp;gt;;
    /**
    Callback that is called when each step (LLM call) is finished, including intermediate steps.
    */
    onStepFinish?: GenerateTextOnStepFinishCallback&amp;lt;TOOLS&amp;gt;;
    /**
     * Internal. For test use only. May change without notice.
     */
    _internal?: {
      generateId?: IDGenerator;
currentDate?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The tools that the model can call. The model needs to support calling tools.
*/
⋮----
/**
The tool choice strategy. Default: &amp;apos;auto&amp;apos;.
     */
⋮----
/**
Maximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.
A maximum number is required to prevent infinite loops in the case of misconfigured tools.
By default, it&amp;apos;s set to 1, which means that only a single LLM call is made.
     */
⋮----
/**
Generate a unique ID for each message.
     */
⋮----
/**
When enabled, the model will perform additional steps if the finish reason is &amp;quot;length&amp;quot; (experimental).
By default, it&amp;apos;s set to false.
     */
⋮----
/**
Optional telemetry configuration (experimental).
     */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
     */
⋮----
/**
Limits the tools that are available for the model to call without
changing the tool call and result types in the result.
     */
⋮----
/**
Optional specification for parsing structured outputs from the LLM response.
     */
⋮----
/**
Optional function that you can use to provide different settings for a step.
@param options - The options for the step.
@param options.steps - The steps that have been executed so far.
@param options.stepNumber - The number of the step that is being executed.
@param options.maxSteps - The maximum number of steps.
@param options.model - The model that is being used.
@returns An object that contains the settings for the step.
If you return undefined (or for undefined settings), the settings from the outer level will be used.
    */
⋮----
/**
A function that attempts to repair a tool call that failed to parse.
     */
⋮----
/**
    Callback that is called when each step (LLM call) is finished, including intermediate steps.
    */
⋮----
/**
     * Internal. For test use only. May change without notice.
     */
⋮----
// model:
⋮----
// specific settings that only make sense on the outer level:
⋮----
// after the 1st step, we need to switch to messages format:
⋮----
modelSupportsUrl: stepModel.supportsUrl?.bind(stepModel), // support &amp;apos;this&amp;apos; context
⋮----
// model:
⋮----
// prompt:
⋮----
// convert the language model level tools:
⋮----
// standardized gen-ai llm span attributes:
⋮----
// Fill in default values:
⋮----
// Add response information to the span:
⋮----
// standardized gen-ai llm span attributes:
⋮----
// parse tool calls:
⋮----
// execute tools:
⋮----
// token usage:
⋮----
// check if another step is needed:
⋮----
// only use continue when there are no tool calls:
⋮----
// there are tool calls:
⋮----
// all current tool calls have results:
⋮----
// text:
⋮----
stepType === &amp;apos;continue&amp;apos; &amp;amp;&amp;amp; // only for continue steps
text.trimEnd() !== text // only trim when there is preceding whitespace
⋮----
// sources:
⋮----
// append to messages for potential next step:
⋮----
// continue step: update the last assistant message
// continue is only possible when there are no tool calls,
// so we can assume that there is a single last assistant message:
⋮----
// Add step information (after response messages are updated):
⋮----
// TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)
⋮----
// deep clone msgs to avoid mutating past messages in multi-step:
⋮----
// Add response information to the span:
⋮----
async function executeTools&amp;lt;TOOLS extends ToolSet&amp;gt;({
  toolCalls,
  tools,
  tracer,
  telemetry,
  messages,
  abortSignal,
}: {
  toolCalls: ToolCallArray&amp;lt;TOOLS&amp;gt;;
  tools: TOOLS;
  tracer: Tracer;
  telemetry: TelemetrySettings | undefined;
  messages: CoreMessage[];
  abortSignal: AbortSignal | undefined;
}): Promise&amp;lt;ToolResultArray&amp;lt;TOOLS&amp;gt;&amp;gt;
⋮----
// JSON stringify might fail if the result is not serializable,
// in which case we just ignore it. In the future we might want to
// add an optional serialize method to the tool interface and warn
// if the result is not serializable.
⋮----
class DefaultGenerateTextResult&amp;lt;TOOLS extends ToolSet, OUTPUT&amp;gt;
implements GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;
⋮----
constructor(options: {
    text: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;text&amp;apos;];
    files: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;files&amp;apos;];
    reasoning: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;reasoning&amp;apos;];
    reasoningDetails: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;reasoningDetails&amp;apos;];
    toolCalls: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;toolCalls&amp;apos;];
    toolResults: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;toolResults&amp;apos;];
    finishReason: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;finishReason&amp;apos;];
    usage: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;usage&amp;apos;];
    warnings: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;warnings&amp;apos;];
    logprobs: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;logprobs&amp;apos;];
    steps: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;steps&amp;apos;];
    providerMetadata: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;providerMetadata&amp;apos;];
    response: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;response&amp;apos;];
    request: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;request&amp;apos;];
    outputResolver: () =&amp;gt; GenerateTextResult&amp;lt;
      TOOLS,
      OUTPUT
    &amp;gt;[&amp;apos;experimental_output&amp;apos;];
    sources: GenerateTextResult&amp;lt;TOOLS, OUTPUT&amp;gt;[&amp;apos;sources&amp;apos;];
})
get experimental_output()
⋮----
function asReasoningDetails(
  reasoning:
    | string
    | Array&amp;lt;
        | { type: &amp;apos;text&amp;apos;; text: string; signature?: string }
        | { type: &amp;apos;redacted&amp;apos;; data: string }
      &amp;gt;
    | undefined,
): Array&amp;lt;
  | { type: &amp;apos;text&amp;apos;; text: string; signature?: string }
  | { type: &amp;apos;redacted&amp;apos;; data: string }
&amp;gt; {
if (reasoning == null)
function asFiles(
  files:
    | Array&amp;lt;{
        data: string | Uint8Array;
        mimeType: string;
      }&amp;gt;
    | undefined,
): Array&amp;lt;GeneratedFile&amp;gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/generated-file.ts&quot;&gt;import {
  convertBase64ToUint8Array,
  convertUint8ArrayToBase64,
} from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
/**
 * A generated file.
 */
export interface GeneratedFile {
  /**
File as a base64 encoded string.
     */
  readonly base64: string;
  /**
File as a Uint8Array.
     */
  readonly uint8Array: Uint8Array;
  /**
MIME type of the file
   */
  readonly mimeType: string;
}
⋮----
/**
File as a base64 encoded string.
     */
⋮----
/**
File as a Uint8Array.
     */
⋮----
/**
MIME type of the file
   */
⋮----
export class DefaultGeneratedFile implements GeneratedFile
⋮----
constructor({
    data,
    mimeType,
  }: {
    data: string | Uint8Array;
    mimeType: string;
})
// lazy conversion with caching to avoid unnecessary conversion overhead:
get base64()
// lazy conversion with caching to avoid unnecessary conversion overhead:
get uint8Array()
⋮----
export class DefaultGeneratedFileWithType extends DefaultGeneratedFile
⋮----
constructor(options:&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/index.ts&quot;&gt;GeneratedFile as Experimental_GeneratedImage, // Image for backwards compatibility, TODO remove in v5&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/output.test.ts&quot;&gt;import { fail } from &amp;apos;assert&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { verifyNoObjectGeneratedError } from &amp;apos;../../errors/no-object-generated-error&amp;apos;;
import { object } from &amp;apos;./output&amp;apos;;
import { FinishReason } from &amp;apos;../types&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/output.ts&quot;&gt;import { safeParseJSON, safeValidateTypes } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import {
  asSchema,
  DeepPartial,
  parsePartialJson,
  Schema,
} from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { NoObjectGeneratedError } from &amp;apos;../../errors&amp;apos;;
import { injectJsonInstruction } from &amp;apos;../generate-object/inject-json-instruction&amp;apos;;
import {
  FinishReason,
  LanguageModel,
  LanguageModelV1CallOptions,
} from &amp;apos;../types/language-model&amp;apos;;
import { LanguageModelResponseMetadata } from &amp;apos;../types/language-model-response-metadata&amp;apos;;
import { LanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
export interface Output&amp;lt;OUTPUT, PARTIAL&amp;gt; {
  readonly type: &amp;apos;object&amp;apos; | &amp;apos;text&amp;apos;;
  injectIntoSystemPrompt(options: {
    system: string | undefined;
    model: LanguageModel;
  }): string | undefined;
  responseFormat: (options: {
    model: LanguageModel;
  }) =&amp;gt; LanguageModelV1CallOptions[&amp;apos;responseFormat&amp;apos;];
  parsePartial(options: { text: string }): { partial: PARTIAL } | undefined;
  parseOutput(
    options: { text: string },
    context: {
      response: LanguageModelResponseMetadata;
      usage: LanguageModelUsage;
      finishReason: FinishReason;
    },
  ): OUTPUT;
}
⋮----
injectIntoSystemPrompt(options: {
    system: string | undefined;
    model: LanguageModel;
  }): string | undefined;
⋮----
parsePartial(options:
parseOutput(
    options: { text: string },
    context: {
      response: LanguageModelResponseMetadata;
      usage: LanguageModelUsage;
      finishReason: FinishReason;
    },
  ): OUTPUT;
⋮----
export const text = (): Output&amp;lt;string, string&amp;gt; =&amp;gt; (
⋮----
injectIntoSystemPrompt(
parsePartial(
⋮----
export const object = &amp;lt;OUTPUT&amp;gt;({
  schema: inputSchema,
}: {
  schema: z.Schema&amp;lt;OUTPUT, z.ZodTypeDef, any&amp;gt; | Schema&amp;lt;OUTPUT&amp;gt;;
}): Output&amp;lt;OUTPUT, DeepPartial&amp;lt;OUTPUT&amp;gt;&amp;gt; =&amp;gt;
⋮----
// when the model supports structured outputs,
// we can use the system prompt as is:
⋮----
// Note: currently no validation of partial results:
⋮----
parseOutput(
      { text }: { text: string },
      context: {
        response: LanguageModelResponseMetadata;
        usage: LanguageModelUsage;
        finishReason: FinishReason;
      },
)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/parse-tool-call.test.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import { InvalidToolArgumentsError } from &amp;apos;../../errors/invalid-tool-arguments-error&amp;apos;;
import { NoSuchToolError } from &amp;apos;../../errors/no-such-tool-error&amp;apos;;
import { tool } from &amp;apos;../tool&amp;apos;;
import { parseToolCall } from &amp;apos;./parse-tool-call&amp;apos;;
import { ToolCallRepairError } from &amp;apos;../../errors/tool-call-repair-error&amp;apos;;
⋮----
args: &amp;apos;{&amp;quot;param1&amp;quot;: &amp;quot;test&amp;quot;}&amp;apos;, // Missing required param2
⋮----
args: &amp;apos;invalid json&amp;apos;, // This will trigger repair
⋮----
// Verify repair function was called
⋮----
// Verify the repaired result was used&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/parse-tool-call.ts&quot;&gt;import { LanguageModelV1FunctionToolCall } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { safeParseJSON, safeValidateTypes } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { Schema, asSchema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { InvalidToolArgumentsError } from &amp;apos;../../errors/invalid-tool-arguments-error&amp;apos;;
import { NoSuchToolError } from &amp;apos;../../errors/no-such-tool-error&amp;apos;;
import { ToolCallRepairError } from &amp;apos;../../errors/tool-call-repair-error&amp;apos;;
import { CoreMessage } from &amp;apos;../prompt&amp;apos;;
import { inferParameters } from &amp;apos;../tool/tool&amp;apos;;
import { ToolCallUnion } from &amp;apos;./tool-call&amp;apos;;
import { ToolCallRepairFunction } from &amp;apos;./tool-call-repair&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
export async function parseToolCall&amp;lt;TOOLS extends ToolSet&amp;gt;({
  toolCall,
  tools,
  repairToolCall,
  system,
  messages,
}: {
  toolCall: LanguageModelV1FunctionToolCall;
  tools: TOOLS | undefined;
  repairToolCall: ToolCallRepairFunction&amp;lt;TOOLS&amp;gt; | undefined;
  system: string | undefined;
  messages: CoreMessage[];
}): Promise&amp;lt;ToolCallUnion&amp;lt;TOOLS&amp;gt;&amp;gt;
⋮----
// no repaired tool call returned
⋮----
async function doParseToolCall&amp;lt;TOOLS extends ToolSet&amp;gt;({
  toolCall,
  tools,
}: {
  toolCall: LanguageModelV1FunctionToolCall;
  tools: TOOLS;
}): Promise&amp;lt;ToolCallUnion&amp;lt;TOOLS&amp;gt;&amp;gt;
⋮----
// when the tool call has no arguments, we try passing an empty object to the schema
// (many LLMs generate empty strings for tool calls with no arguments)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/reasoning-detail.ts&quot;&gt;export type ReasoningDetail =
  | { type: &amp;apos;text&amp;apos;; text: string; signature?: string }
  | { type: &amp;apos;redacted&amp;apos;; data: string };
export function asReasoningText(
  reasoning: Array&amp;lt;ReasoningDetail&amp;gt;,
): string | undefined&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/run-tools-transformation.test.ts&quot;&gt;import { LanguageModelV1StreamPart } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { delay } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import {
  convertArrayToReadableStream,
  convertReadableStreamToArray,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { NoSuchToolError } from &amp;apos;../../errors&amp;apos;;
import { MockTracer } from &amp;apos;../test/mock-tracer&amp;apos;;
import { runToolsTransformation } from &amp;apos;./run-tools-transformation&amp;apos;;
⋮----
await delay(0); // Simulate delayed execution&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/run-tools-transformation.ts&quot;&gt;import { LanguageModelV1StreamPart } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { generateId } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { Tracer } from &amp;apos;@opentelemetry/api&amp;apos;;
import { ToolExecutionError } from &amp;apos;../../errors&amp;apos;;
import { CoreMessage } from &amp;apos;../prompt/message&amp;apos;;
import { assembleOperationName } from &amp;apos;../telemetry/assemble-operation-name&amp;apos;;
import { recordSpan } from &amp;apos;../telemetry/record-span&amp;apos;;
import { selectTelemetryAttributes } from &amp;apos;../telemetry/select-telemetry-attributes&amp;apos;;
import { TelemetrySettings } from &amp;apos;../telemetry/telemetry-settings&amp;apos;;
import {
  FinishReason,
  LanguageModelUsage,
  LogProbs,
  ProviderMetadata,
} from &amp;apos;../types&amp;apos;;
import { Source } from &amp;apos;../types/language-model&amp;apos;;
import { calculateLanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
import { DefaultGeneratedFileWithType, GeneratedFile } from &amp;apos;./generated-file&amp;apos;;
import { parseToolCall } from &amp;apos;./parse-tool-call&amp;apos;;
import { ToolCallUnion } from &amp;apos;./tool-call&amp;apos;;
import { ToolCallRepairFunction } from &amp;apos;./tool-call-repair&amp;apos;;
import { ToolResultUnion } from &amp;apos;./tool-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
export type SingleRequestTextStreamPart&amp;lt;TOOLS extends ToolSet&amp;gt; =
  | {
      type: &amp;apos;text-delta&amp;apos;;
      textDelta: string;
    }
  | {
      type: &amp;apos;reasoning&amp;apos;;
      textDelta: string;
    }
  | {
      type: &amp;apos;reasoning-signature&amp;apos;;
      signature: string;
    }
  | {
      type: &amp;apos;redacted-reasoning&amp;apos;;
      data: string;
    }
  | ({
      type: &amp;apos;file&amp;apos;;
    } &amp;amp; GeneratedFile)
  | {
      type: &amp;apos;source&amp;apos;;
      source: Source;
    }
  | ({
      type: &amp;apos;tool-call&amp;apos;;
    } &amp;amp; ToolCallUnion&amp;lt;TOOLS&amp;gt;)
  | {
      type: &amp;apos;tool-call-streaming-start&amp;apos;;
      toolCallId: string;
      toolName: string;
    }
  | {
      type: &amp;apos;tool-call-delta&amp;apos;;
      toolCallId: string;
      toolName: string;
      argsTextDelta: string;
    }
  | ({
      type: &amp;apos;tool-result&amp;apos;;
    } &amp;amp; ToolResultUnion&amp;lt;TOOLS&amp;gt;)
  | {
      type: &amp;apos;response-metadata&amp;apos;;
      id?: string;
      timestamp?: Date;
      modelId?: string;
    }
  | {
      type: &amp;apos;finish&amp;apos;;
      finishReason: FinishReason;
      logprobs?: LogProbs;
      usage: LanguageModelUsage;
      experimental_providerMetadata?: ProviderMetadata;
    }
  | {
      type: &amp;apos;error&amp;apos;;
      error: unknown;
    };
export function runToolsTransformation&amp;lt;TOOLS extends ToolSet&amp;gt;({
  tools,
  generatorStream,
  toolCallStreaming,
  tracer,
  telemetry,
  system,
  messages,
  abortSignal,
  repairToolCall,
}: {
  tools: TOOLS | undefined;
  generatorStream: ReadableStream&amp;lt;LanguageModelV1StreamPart&amp;gt;;
  toolCallStreaming: boolean;
  tracer: Tracer;
  telemetry: TelemetrySettings | undefined;
  system: string | undefined;
  messages: CoreMessage[];
  abortSignal: AbortSignal | undefined;
  repairToolCall: ToolCallRepairFunction&amp;lt;TOOLS&amp;gt; | undefined;
}): ReadableStream&amp;lt;SingleRequestTextStreamPart&amp;lt;TOOLS&amp;gt;&amp;gt;
⋮----
// tool results stream
⋮----
start(controller)
⋮----
// keep track of active tool calls for tool call streaming:
⋮----
// keep track of outstanding tool results for stream closing:
⋮----
function attemptClose()
⋮----
// close the tool results controller if no more outstanding tool calls
⋮----
// we delay sending the finish chunk until all tool results (incl. delayed ones)
// are received to ensure that the frontend receives tool results before a message
// finish event arrives.
⋮----
// forward stream
⋮----
async transform(
      chunk: LanguageModelV1StreamPart,
      controller: TransformStreamDefaultController&amp;lt;
        SingleRequestTextStreamPart&amp;lt;TOOLS&amp;gt;
      &amp;gt;,
)
⋮----
// forward:
⋮----
// forward with less information:
⋮----
// process tool call:
⋮----
const toolExecutionId = generateId(); // use our own id to guarantee uniqueness
⋮----
// Note: we don&amp;apos;t await the tool execution here (by leaving out &amp;apos;await&amp;apos; on recordSpan),
// because we want to process the next chunk as soon as possible.
// This is important for the case where the tool execution takes a long time.
⋮----
// record telemetry
⋮----
// JSON stringify might fail if the result is not serializable,
// in which case we just ignore it. In the future we might want to
// add an optional serialize method to the tool interface and warn
// if the result is not serializable.
⋮----
flush()
⋮----
// combine the generator stream and the tool results stream
⋮----
async start(controller)
⋮----
// need to wait for both pipes so there are no dangling promises that
// can cause uncaught promise rejections when the stream is aborted
⋮----
write(chunk)
close()
⋮----
// the generator stream controller is automatically closed when it&amp;apos;s consumed&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/smooth-stream.test.ts&quot;&gt;import { describe, expect, it } from &amp;apos;vitest&amp;apos;;
import { convertArrayToReadableStream } from &amp;apos;../../test&amp;apos;;
import { smoothStream } from &amp;apos;./smooth-stream&amp;apos;;
⋮----
async function consumeStream(stream: ReadableStream&amp;lt;any&amp;gt;)
function delay(delayInMs: number | null)
⋮----
// note: leading whitespace is included here
// because it is part of the new chunk:&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/smooth-stream.ts&quot;&gt;import { delay as originalDelay } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { TextStreamPart } from &amp;apos;./stream-text-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
import { InvalidArgumentError } from &amp;apos;@ai-sdk/provider&amp;apos;;
⋮----
/**
 * Detects the first chunk in a buffer.
 *
 * @param buffer - The buffer to detect the first chunk in.
 *
 * @returns The first detected chunk, or `undefined` if no chunk was detected.
 */
export type ChunkDetector = (buffer: string) =&amp;gt; string | undefined | null;
/**
 * Smooths text streaming output.
 *
 * @param delayInMs - The delay in milliseconds between each chunk. Defaults to 10ms. Can be set to `null` to skip the delay.
 * @param chunking - Controls how the text is chunked for streaming. Use &amp;quot;word&amp;quot; to stream word by word (default), &amp;quot;line&amp;quot; to stream line by line, or provide a custom RegExp pattern for custom chunking.
 *
 * @returns A transform stream that smooths text streaming output.
 */
export function smoothStream&amp;lt;TOOLS extends ToolSet&amp;gt;({
  delayInMs = 10,
  chunking = &amp;apos;word&amp;apos;,
  _internal: { delay = originalDelay } = {},
}: {
  delayInMs?: number | null;
  chunking?: &amp;apos;word&amp;apos; | &amp;apos;line&amp;apos; | RegExp | ChunkDetector;
  /**
   * Internal. For test use only. May change without notice.
   */
  _internal?: {
delay?: (delayInMs: number | null)
⋮----
/**
   * Internal. For test use only. May change without notice.
   */
⋮----
detectChunk = buffer =&amp;gt; {
      const match = chunking(buffer);
⋮----
detectChunk = buffer =&amp;gt; {
      const match = chunkingRegex.exec(buffer);
⋮----
async transform(chunk, controller)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/step-result.ts&quot;&gt;import { CoreAssistantMessage, CoreToolMessage } from &amp;apos;../prompt/message&amp;apos;;
import {
  CallWarning,
  FinishReason,
  LanguageModelRequestMetadata,
  LanguageModelResponseMetadata,
  LogProbs,
  ProviderMetadata,
} from &amp;apos;../types&amp;apos;;
import { Source } from &amp;apos;../types/language-model&amp;apos;;
import { LanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
import { GeneratedFile } from &amp;apos;./generated-file&amp;apos;;
import { ReasoningDetail } from &amp;apos;./reasoning-detail&amp;apos;;
import { ToolCallArray } from &amp;apos;./tool-call&amp;apos;;
import { ToolResultArray } from &amp;apos;./tool-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
/**
A message that was generated during the generation process.
It can be either an assistant message or a tool message.
 */
export type ResponseMessage = (CoreAssistantMessage | CoreToolMessage) &amp;amp; {
  /**
Message ID generated by the AI SDK.
   */
  id: string;
};
⋮----
/**
Message ID generated by the AI SDK.
   */
⋮----
/**
 * The result of a single step in the generation process.
 */
export type StepResult&amp;lt;TOOLS extends ToolSet&amp;gt; = {
  /**
The generated text.
*/
  readonly text: string;
  /**
The reasoning that was generated during the generation.
*/
  // TODO v5: rename to `reasoningText`
  readonly reasoning: string | undefined;
  // TODO v5: rename to `reasoning`
  readonly reasoningDetails: Array&amp;lt;ReasoningDetail&amp;gt;;
  /**
The files that were generated during the generation.
*/
  readonly files: GeneratedFile[];
  /**
The sources that were used to generate the text.
*/
  readonly sources: Source[];
  /**
The tool calls that were made during the generation.
*/
  readonly toolCalls: ToolCallArray&amp;lt;TOOLS&amp;gt;;
  /**
The results of the tool calls.
*/
  readonly toolResults: ToolResultArray&amp;lt;TOOLS&amp;gt;;
  /**
The reason why the generation finished.
*/
  readonly finishReason: FinishReason;
  /**
The token usage of the generated text.
*/
  readonly usage: LanguageModelUsage;
  /**
Warnings from the model provider (e.g. unsupported settings).
*/
  readonly warnings: CallWarning[] | undefined;
  /**
Logprobs for the completion.
`undefined` if the mode does not support logprobs or if was not enabled.
*/
  readonly logprobs: LogProbs | undefined;
  /**
Additional request information.
   */
  readonly request: LanguageModelRequestMetadata;
  /**
Additional response information.
*/
  readonly response: LanguageModelResponseMetadata &amp;amp; {
    /**
The response messages that were generated during the call.
Response messages can be either assistant messages or tool messages.
They contain a generated id.
*/
    readonly messages: Array&amp;lt;ResponseMessage&amp;gt;;
    /**
Response body (available only for providers that use HTTP requests).
     */
    body?: unknown;
  };
  /**
Additional provider-specific metadata. They are passed through
from the provider to the AI SDK and enable provider-specific
results that can be fully encapsulated in the provider.
   */
  readonly providerMetadata: ProviderMetadata | undefined;
  /**
@deprecated Use `providerMetadata` instead.
   */
  readonly experimental_providerMetadata: ProviderMetadata | undefined;
  /**
The type of step that this result is for. The first step is always
an &amp;quot;initial&amp;quot; step, and subsequent steps are either &amp;quot;continue&amp;quot; steps
or &amp;quot;tool-result&amp;quot; steps.
   */
  readonly stepType: &amp;apos;initial&amp;apos; | &amp;apos;continue&amp;apos; | &amp;apos;tool-result&amp;apos;;
  /**
True when there will be a continuation step with a continuation text.
   */
  readonly isContinued: boolean;
};
⋮----
/**
The generated text.
*/
⋮----
/**
The reasoning that was generated during the generation.
*/
// TODO v5: rename to `reasoningText`
⋮----
// TODO v5: rename to `reasoning`
⋮----
/**
The files that were generated during the generation.
*/
⋮----
/**
The sources that were used to generate the text.
*/
⋮----
/**
The tool calls that were made during the generation.
*/
⋮----
/**
The results of the tool calls.
*/
⋮----
/**
The reason why the generation finished.
*/
⋮----
/**
The token usage of the generated text.
*/
⋮----
/**
Warnings from the model provider (e.g. unsupported settings).
*/
⋮----
/**
Logprobs for the completion.
`undefined` if the mode does not support logprobs or if was not enabled.
*/
⋮----
/**
Additional request information.
   */
⋮----
/**
Additional response information.
*/
⋮----
/**
The response messages that were generated during the call.
Response messages can be either assistant messages or tool messages.
They contain a generated id.
*/
⋮----
/**
Response body (available only for providers that use HTTP requests).
     */
⋮----
/**
Additional provider-specific metadata. They are passed through
from the provider to the AI SDK and enable provider-specific
results that can be fully encapsulated in the provider.
   */
⋮----
/**
@deprecated Use `providerMetadata` instead.
   */
⋮----
/**
The type of step that this result is for. The first step is always
an &amp;quot;initial&amp;quot; step, and subsequent steps are either &amp;quot;continue&amp;quot; steps
or &amp;quot;tool-result&amp;quot; steps.
   */
⋮----
/**
True when there will be a continuation step with a continuation text.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/stream-text-result.ts&quot;&gt;import { ServerResponse } from &amp;apos;node:http&amp;apos;;
import { StreamData } from &amp;apos;../../streams/stream-data&amp;apos;;
import { DataStreamWriter } from &amp;apos;../data-stream/data-stream-writer&amp;apos;;
import {
  CallWarning,
  FinishReason,
  LanguageModelRequestMetadata,
  LogProbs,
  ProviderMetadata,
} from &amp;apos;../types&amp;apos;;
import { Source } from &amp;apos;../types/language-model&amp;apos;;
import { LanguageModelResponseMetadata } from &amp;apos;../types/language-model-response-metadata&amp;apos;;
import { LanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
import { AsyncIterableStream } from &amp;apos;../util/async-iterable-stream&amp;apos;;
import { GeneratedFile } from &amp;apos;./generated-file&amp;apos;;
import { ReasoningDetail } from &amp;apos;./reasoning-detail&amp;apos;;
import { ResponseMessage, StepResult } from &amp;apos;./step-result&amp;apos;;
import { ToolCallUnion } from &amp;apos;./tool-call&amp;apos;;
import { ToolResultUnion } from &amp;apos;./tool-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
export type DataStreamOptions = {
  /**
   * Send usage parts to the client.
   * Default to true.
   */
  // TODO change default to false in v5: secure by default
  sendUsage?: boolean;
  /**
   * Send reasoning parts to the client.
   * Default to false.
   */
  sendReasoning?: boolean;
  /**
   * Send source parts to the client.
   * Default to false.
   */
  sendSources?: boolean;
  /**
   * Send the finish event to the client.
   * Set to false if you are using additional streamText calls
   * that send additional data.
   * Default to true.
   */
  experimental_sendFinish?: boolean;
  /**
   * Send the message start event to the client.
   * Set to false if you are using additional streamText calls
   * and the message start event has already been sent.
   * Default to true.
   *
   * Note: this setting is currently not used, but you should
   * already set it to false if you are using additional
   * streamText calls that send additional data to prevent
   * the message start event from being sent multiple times.
   */
  experimental_sendStart?: boolean;
};
⋮----
/**
   * Send usage parts to the client.
   * Default to true.
   */
// TODO change default to false in v5: secure by default
⋮----
/**
   * Send reasoning parts to the client.
   * Default to false.
   */
⋮----
/**
   * Send source parts to the client.
   * Default to false.
   */
⋮----
/**
   * Send the finish event to the client.
   * Set to false if you are using additional streamText calls
   * that send additional data.
   * Default to true.
   */
⋮----
/**
   * Send the message start event to the client.
   * Set to false if you are using additional streamText calls
   * and the message start event has already been sent.
   * Default to true.
   *
   * Note: this setting is currently not used, but you should
   * already set it to false if you are using additional
   * streamText calls that send additional data to prevent
   * the message start event from being sent multiple times.
   */
⋮----
export type ConsumeStreamOptions = {
  onError?: (error: unknown) =&amp;gt; void;
};
/**
A result object for accessing different stream types and additional information.
 */
export interface StreamTextResult&amp;lt;TOOLS extends ToolSet, PARTIAL_OUTPUT&amp;gt; {
  /**
Warnings from the model provider (e.g. unsupported settings) for the first step.
     */
  readonly warnings: Promise&amp;lt;CallWarning[] | undefined&amp;gt;;
  /**
The total token usage of the generated response.
When there are multiple steps, the usage is the sum of all step usages.
Resolved when the response is finished.
     */
  readonly usage: Promise&amp;lt;LanguageModelUsage&amp;gt;;
  /**
Sources that have been used as input to generate the response.
For multi-step generation, the sources are accumulated from all steps.
Resolved when the response is finished.
   */
  readonly sources: Promise&amp;lt;Source[]&amp;gt;;
  /**
Files that have been generated by the model in the last step.
Resolved when the response is finished.
   */
  readonly files: Promise&amp;lt;GeneratedFile[]&amp;gt;;
  /**
The reason why the generation finished. Taken from the last step.
Resolved when the response is finished.
     */
  readonly finishReason: Promise&amp;lt;FinishReason&amp;gt;;
  /**
Additional provider-specific metadata from the last step.
Metadata is passed through from the provider to the AI SDK and
enables provider-specific results that can be fully encapsulated in the provider.
   */
  readonly providerMetadata: Promise&amp;lt;ProviderMetadata | undefined&amp;gt;;
  /**
@deprecated Use `providerMetadata` instead.
   */
  readonly experimental_providerMetadata: Promise&amp;lt;ProviderMetadata | undefined&amp;gt;;
  /**
The full text that has been generated by the last step.
Resolved when the response is finished.
     */
  readonly text: Promise&amp;lt;string&amp;gt;;
  /**
The reasoning that has been generated by the last step.
Resolved when the response is finished.
     */
  // TODO v5: rename to `reasoningText`
  readonly reasoning: Promise&amp;lt;string | undefined&amp;gt;;
  /**
The full reasoning that the model has generated.
Resolved when the response is finished.
   */
  // TODO v5: rename to `reasoning`
  readonly reasoningDetails: Promise&amp;lt;Array&amp;lt;ReasoningDetail&amp;gt;&amp;gt;;
  /**
The tool calls that have been executed in the last step.
Resolved when the response is finished.
     */
  readonly toolCalls: Promise&amp;lt;ToolCallUnion&amp;lt;TOOLS&amp;gt;[]&amp;gt;;
  /**
The tool results that have been generated in the last step.
Resolved when the all tool executions are finished.
     */
  readonly toolResults: Promise&amp;lt;ToolResultUnion&amp;lt;TOOLS&amp;gt;[]&amp;gt;;
  /**
Details for all steps.
You can use this to get information about intermediate steps,
such as the tool calls or the response headers.
   */
  readonly steps: Promise&amp;lt;Array&amp;lt;StepResult&amp;lt;TOOLS&amp;gt;&amp;gt;&amp;gt;;
  /**
Additional request information from the last step.
 */
  readonly request: Promise&amp;lt;LanguageModelRequestMetadata&amp;gt;;
  /**
Additional response information from the last step.
 */
  readonly response: Promise&amp;lt;
    LanguageModelResponseMetadata &amp;amp; {
      /**
The response messages that were generated during the call. It consists of an assistant message,
potentially containing tool calls.
When there are tool results, there is an additional tool message with the tool results that are available.
If there are tools that do not have execute functions, they are not included in the tool results and
need to be added separately.
       */
      messages: Array&amp;lt;ResponseMessage&amp;gt;;
    }
  &amp;gt;;
  /**
  A text stream that returns only the generated text deltas. You can use it
  as either an AsyncIterable or a ReadableStream. When an error occurs, the
  stream will throw the error.
     */
  readonly textStream: AsyncIterableStream&amp;lt;string&amp;gt;;
  /**
  A stream with all events, including text deltas, tool calls, tool results, and
  errors.
  You can use it as either an AsyncIterable or a ReadableStream.
  Only errors that stop the stream, such as network errors, are thrown.
     */
  readonly fullStream: AsyncIterableStream&amp;lt;TextStreamPart&amp;lt;TOOLS&amp;gt;&amp;gt;;
  /**
A stream of partial outputs. It uses the `experimental_output` specification.
   */
  readonly experimental_partialOutputStream: AsyncIterableStream&amp;lt;PARTIAL_OUTPUT&amp;gt;;
  /**
Consumes the stream without processing the parts.
This is useful to force the stream to finish.
It effectively removes the backpressure and allows the stream to finish,
triggering the `onFinish` callback and the promise resolution.
If an error occurs, it is passed to the optional `onError` callback.
  */
  consumeStream(options?: ConsumeStreamOptions): Promise&amp;lt;void&amp;gt;;
  /**
  Converts the result to a data stream.
  @param data an optional StreamData object that will be merged into the stream.
  @param getErrorMessage an optional function that converts an error to an error message.
  @param sendUsage whether to send the usage information to the client. Defaults to true.
  @param sendReasoning whether to send the reasoning information to the client. Defaults to false.
  @return A data stream.
     */
  toDataStream(
    options?: {
      data?: StreamData;
      getErrorMessage?: (error: unknown) =&amp;gt; string;
    } &amp;amp; DataStreamOptions,
  ): ReadableStream&amp;lt;Uint8Array&amp;gt;;
  /**
   * Merges the result as a data stream into another data stream.
   *
   * @param dataStream A data stream writer.
   * @param options.sendUsage Whether to send the usage information to the client. Defaults to true.
   * @param options.sendReasoning Whether to send the reasoning information to the client. Defaults to false.
   */
  mergeIntoDataStream(
    dataStream: DataStreamWriter,
    options?: DataStreamOptions,
  ): void;
  /**
  Writes data stream output to a Node.js response-like object.
  @param response A Node.js response-like object (ServerResponse).
  @param options.status The status code.
  @param options.statusText The status text.
  @param options.headers The headers.
  @param options.data The stream data.
  @param options.getErrorMessage An optional function that converts an error to an error message.
  @param options.sendUsage Whether to send the usage information to the client. Defaults to true.
  @param options.sendReasoning Whether to send the reasoning information to the client. Defaults to false.
     */
  pipeDataStreamToResponse(
    response: ServerResponse,
    options?: ResponseInit &amp;amp; {
      data?: StreamData;
      getErrorMessage?: (error: unknown) =&amp;gt; string;
    } &amp;amp; DataStreamOptions,
  ): void;
  /**
  Writes text delta output to a Node.js response-like object.
  It sets a `Content-Type` header to `text/plain; charset=utf-8` and
  writes each text delta as a separate chunk.
  @param response A Node.js response-like object (ServerResponse).
  @param init Optional headers, status code, and status text.
     */
  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit): void;
  /**
  Converts the result to a streamed response object with a stream data part stream.
  It can be used with the `useChat` and `useCompletion` hooks.
  @param options.status The status code.
  @param options.statusText The status text.
  @param options.headers The headers.
  @param options.data The stream data.
  @param options.getErrorMessage An optional function that converts an error to an error message.
  @param options.sendUsage Whether to send the usage information to the client. Defaults to true.
  @param options.sendReasoning Whether to send the reasoning information to the client. Defaults to false.
  @return A response object.
     */
  toDataStreamResponse(
    options?: ResponseInit &amp;amp; {
      data?: StreamData;
      getErrorMessage?: (error: unknown) =&amp;gt; string;
    } &amp;amp; DataStreamOptions,
  ): Response;
  /**
  Creates a simple text stream response.
  Each text delta is encoded as UTF-8 and sent as a separate chunk.
  Non-text-delta events are ignored.
  @param init Optional headers, status code, and status text.
     */
  toTextStreamResponse(init?: ResponseInit): Response;
}
⋮----
/**
Warnings from the model provider (e.g. unsupported settings) for the first step.
     */
⋮----
/**
The total token usage of the generated response.
When there are multiple steps, the usage is the sum of all step usages.
Resolved when the response is finished.
     */
⋮----
/**
Sources that have been used as input to generate the response.
For multi-step generation, the sources are accumulated from all steps.
Resolved when the response is finished.
   */
⋮----
/**
Files that have been generated by the model in the last step.
Resolved when the response is finished.
   */
⋮----
/**
The reason why the generation finished. Taken from the last step.
Resolved when the response is finished.
     */
⋮----
/**
Additional provider-specific metadata from the last step.
Metadata is passed through from the provider to the AI SDK and
enables provider-specific results that can be fully encapsulated in the provider.
   */
⋮----
/**
@deprecated Use `providerMetadata` instead.
   */
⋮----
/**
The full text that has been generated by the last step.
Resolved when the response is finished.
     */
⋮----
/**
The reasoning that has been generated by the last step.
Resolved when the response is finished.
     */
// TODO v5: rename to `reasoningText`
⋮----
/**
The full reasoning that the model has generated.
Resolved when the response is finished.
   */
// TODO v5: rename to `reasoning`
⋮----
/**
The tool calls that have been executed in the last step.
Resolved when the response is finished.
     */
⋮----
/**
The tool results that have been generated in the last step.
Resolved when the all tool executions are finished.
     */
⋮----
/**
Details for all steps.
You can use this to get information about intermediate steps,
such as the tool calls or the response headers.
   */
⋮----
/**
Additional request information from the last step.
 */
⋮----
/**
Additional response information from the last step.
 */
⋮----
/**
The response messages that were generated during the call. It consists of an assistant message,
potentially containing tool calls.
When there are tool results, there is an additional tool message with the tool results that are available.
If there are tools that do not have execute functions, they are not included in the tool results and
need to be added separately.
       */
⋮----
/**
  A text stream that returns only the generated text deltas. You can use it
  as either an AsyncIterable or a ReadableStream. When an error occurs, the
  stream will throw the error.
     */
⋮----
/**
  A stream with all events, including text deltas, tool calls, tool results, and
  errors.
  You can use it as either an AsyncIterable or a ReadableStream.
  Only errors that stop the stream, such as network errors, are thrown.
     */
⋮----
/**
A stream of partial outputs. It uses the `experimental_output` specification.
   */
⋮----
/**
Consumes the stream without processing the parts.
This is useful to force the stream to finish.
It effectively removes the backpressure and allows the stream to finish,
triggering the `onFinish` callback and the promise resolution.
If an error occurs, it is passed to the optional `onError` callback.
  */
consumeStream(options?: ConsumeStreamOptions): Promise&amp;lt;void&amp;gt;;
/**
  Converts the result to a data stream.
  @param data an optional StreamData object that will be merged into the stream.
  @param getErrorMessage an optional function that converts an error to an error message.
  @param sendUsage whether to send the usage information to the client. Defaults to true.
  @param sendReasoning whether to send the reasoning information to the client. Defaults to false.
  @return A data stream.
     */
toDataStream(
    options?: {
      data?: StreamData;
getErrorMessage?: (error: unknown)
/**
   * Merges the result as a data stream into another data stream.
   *
   * @param dataStream A data stream writer.
   * @param options.sendUsage Whether to send the usage information to the client. Defaults to true.
   * @param options.sendReasoning Whether to send the reasoning information to the client. Defaults to false.
   */
mergeIntoDataStream(
    dataStream: DataStreamWriter,
    options?: DataStreamOptions,
  ): void;
/**
  Writes data stream output to a Node.js response-like object.
  @param response A Node.js response-like object (ServerResponse).
  @param options.status The status code.
  @param options.statusText The status text.
  @param options.headers The headers.
  @param options.data The stream data.
  @param options.getErrorMessage An optional function that converts an error to an error message.
  @param options.sendUsage Whether to send the usage information to the client. Defaults to true.
  @param options.sendReasoning Whether to send the reasoning information to the client. Defaults to false.
     */
pipeDataStreamToResponse(
    response: ServerResponse,
    options?: ResponseInit &amp;amp; {
      data?: StreamData;
getErrorMessage?: (error: unknown)
/**
  Writes text delta output to a Node.js response-like object.
  It sets a `Content-Type` header to `text/plain; charset=utf-8` and
  writes each text delta as a separate chunk.
  @param response A Node.js response-like object (ServerResponse).
  @param init Optional headers, status code, and status text.
     */
pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit): void;
/**
  Converts the result to a streamed response object with a stream data part stream.
  It can be used with the `useChat` and `useCompletion` hooks.
  @param options.status The status code.
  @param options.statusText The status text.
  @param options.headers The headers.
  @param options.data The stream data.
  @param options.getErrorMessage An optional function that converts an error to an error message.
  @param options.sendUsage Whether to send the usage information to the client. Defaults to true.
  @param options.sendReasoning Whether to send the reasoning information to the client. Defaults to false.
  @return A response object.
     */
toDataStreamResponse(
    options?: ResponseInit &amp;amp; {
      data?: StreamData;
getErrorMessage?: (error: unknown)
/**
  Creates a simple text stream response.
  Each text delta is encoded as UTF-8 and sent as a separate chunk.
  Non-text-delta events are ignored.
  @param init Optional headers, status code, and status text.
     */
toTextStreamResponse(init?: ResponseInit): Response;
⋮----
export type TextStreamPart&amp;lt;TOOLS extends ToolSet&amp;gt; =
  | {
      type: &amp;apos;text-delta&amp;apos;;
      textDelta: string;
    }
  | {
      type: &amp;apos;reasoning&amp;apos;;
      textDelta: string;
    }
  | {
      type: &amp;apos;reasoning-signature&amp;apos;;
      signature: string;
    }
  | {
      type: &amp;apos;redacted-reasoning&amp;apos;;
      data: string;
    }
  | {
      type: &amp;apos;source&amp;apos;;
      source: Source;
    }
  | ({
      type: &amp;apos;file&amp;apos;;
    } &amp;amp; GeneratedFile)
  | ({
      type: &amp;apos;tool-call&amp;apos;;
    } &amp;amp; ToolCallUnion&amp;lt;TOOLS&amp;gt;)
  | {
      type: &amp;apos;tool-call-streaming-start&amp;apos;;
      toolCallId: string;
      toolName: string;
    }
  | {
      type: &amp;apos;tool-call-delta&amp;apos;;
      toolCallId: string;
      toolName: string;
      argsTextDelta: string;
    }
  | ({
      type: &amp;apos;tool-result&amp;apos;;
    } &amp;amp; ToolResultUnion&amp;lt;TOOLS&amp;gt;)
  | {
      type: &amp;apos;step-start&amp;apos;;
      messageId: string;
      request: LanguageModelRequestMetadata;
      warnings: CallWarning[];
    }
  | {
      type: &amp;apos;step-finish&amp;apos;;
      messageId: string;
      // TODO 5.0 breaking change: remove logprobs
      logprobs?: LogProbs;
      // TODO 5.0 breaking change: remove request (on start instead)
      request: LanguageModelRequestMetadata;
      // TODO 5.0 breaking change: remove warnings (on start instead)
      warnings: CallWarning[] | undefined;
      response: LanguageModelResponseMetadata;
      usage: LanguageModelUsage;
      finishReason: FinishReason;
      providerMetadata: ProviderMetadata | undefined;
      /**
       * @deprecated Use `providerMetadata` instead.
       */
      // TODO 5.0 breaking change: remove
      experimental_providerMetadata?: ProviderMetadata;
      isContinued: boolean;
    }
  | {
      type: &amp;apos;finish&amp;apos;;
      finishReason: FinishReason;
      usage: LanguageModelUsage;
      providerMetadata: ProviderMetadata | undefined;
      /**
       * @deprecated Use `providerMetadata` instead.
       */
      // TODO 5.0 breaking change: remove
      experimental_providerMetadata?: ProviderMetadata;
      /**
       * @deprecated will be moved into provider metadata
       */
      // TODO 5.0 breaking change: remove logprobs
      logprobs?: LogProbs;
      /**
       * @deprecated use response on step-finish instead
       */
      // TODO 5.0 breaking change: remove response (on step instead)
      response: LanguageModelResponseMetadata;
    }
  | {
      type: &amp;apos;error&amp;apos;;
      error: unknown;
    };
⋮----
// TODO 5.0 breaking change: remove logprobs
⋮----
// TODO 5.0 breaking change: remove request (on start instead)
⋮----
// TODO 5.0 breaking change: remove warnings (on start instead)
⋮----
/**
       * @deprecated Use `providerMetadata` instead.
       */
// TODO 5.0 breaking change: remove
⋮----
/**
       * @deprecated Use `providerMetadata` instead.
       */
// TODO 5.0 breaking change: remove
⋮----
/**
       * @deprecated will be moved into provider metadata
       */
// TODO 5.0 breaking change: remove logprobs
⋮----
/**
       * @deprecated use response on step-finish instead
       */
// TODO 5.0 breaking change: remove response (on step instead)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/stream-text.test.ts&quot;&gt;import {
  LanguageModelV1,
  LanguageModelV1CallOptions,
  LanguageModelV1CallWarning,
  LanguageModelV1StreamPart,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { delay } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import {
  convertArrayToReadableStream,
  convertAsyncIterableToArray,
  convertReadableStreamToArray,
  convertResponseStreamToArray,
  mockId,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { jsonSchema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import assert from &amp;apos;node:assert&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { ToolExecutionError } from &amp;apos;../../errors/tool-execution-error&amp;apos;;
import { StreamData } from &amp;apos;../../streams/stream-data&amp;apos;;
import { createDataStream } from &amp;apos;../data-stream/create-data-stream&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
import { createMockServerResponse } from &amp;apos;../test/mock-server-response&amp;apos;;
import { MockTracer } from &amp;apos;../test/mock-tracer&amp;apos;;
import { mockValues } from &amp;apos;../test/mock-values&amp;apos;;
import { tool } from &amp;apos;../tool/tool&amp;apos;;
import { object, text } from &amp;apos;./output&amp;apos;;
import { StepResult } from &amp;apos;./step-result&amp;apos;;
import { streamText } from &amp;apos;./stream-text&amp;apos;;
import { StreamTextResult, TextStreamPart } from &amp;apos;./stream-text-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
const defaultSettings = ()
function createTestModel({
  stream = convertArrayToReadableStream([
    {
      type: &amp;apos;response-metadata&amp;apos;,
      id: &amp;apos;id-0&amp;apos;,
      modelId: &amp;apos;mock-model-id&amp;apos;,
      timestamp: new Date(0),
    },
    { type: &amp;apos;text-delta&amp;apos;, textDelta: &amp;apos;Hello&amp;apos; },
    { type: &amp;apos;text-delta&amp;apos;, textDelta: &amp;apos;, &amp;apos; },
    { type: &amp;apos;text-delta&amp;apos;, textDelta: `world!` },
    {
      type: &amp;apos;finish&amp;apos;,
      finishReason: &amp;apos;stop&amp;apos;,
      logprobs: undefined,
      usage: { completionTokens: 10, promptTokens: 3 },
    },
  ]),
  rawCall = { rawPrompt: &amp;apos;prompt&amp;apos;, rawSettings: {} },
  rawResponse = undefined,
  request = undefined,
  warnings,
}: {
  stream?: ReadableStream&amp;lt;LanguageModelV1StreamPart&amp;gt;;
  rawResponse?: { headers: Record&amp;lt;string, string&amp;gt; };
  rawCall?: { rawPrompt: string; rawSettings: Record&amp;lt;string, unknown&amp;gt; };
  request?: { body: string };
  warnings?: LanguageModelV1CallWarning[];
} =
⋮----
await delay(50); // delay to show bug where step finish is sent before tool result
⋮----
execute(writer)
⋮----
start(controller)
⋮----
onChunk(event)
⋮----
onError(event)
⋮----
onFinish() {}, // just defined; do nothing
⋮----
// trailing text is to be discarded, trailing whitespace is to be kept:
⋮----
// case where there is no leading nor trailing whitespace:
⋮----
// set up trailing whitespace for next step:
⋮----
// leading whitespace is to be discarded when there is whitespace from previous step
// (for models such as Anthropic that trim trailing whitespace in their inputs):
{ type: &amp;apos;text-delta&amp;apos;, textDelta: &amp;apos; &amp;apos; }, // split into 2 chunks for test coverage
⋮----
class MockLanguageModelWithImageSupport extends MockLanguageModelV1
⋮----
constructor()
⋮----
supportsUrl(url: URL)
⋮----
// Reference &amp;apos;this&amp;apos; to verify context
⋮----
const upperCaseTransform =
&amp;lt;TOOLS extends ToolSet&amp;gt;()
⋮----
transform(chunk, controller)
⋮----
// assuming test arg structure:
⋮----
const toUppercaseAndAddCommaTransform =
&amp;lt;TOOLS extends ToolSet&amp;gt;()
const omitCommaTransform =
&amp;lt;TOOLS extends ToolSet&amp;gt;()
⋮----
const stopWordTransform =
&amp;lt;TOOLS extends ToolSet&amp;gt;()
⋮----
// note: this is a simplified transformation for testing;
// in a real-world version more there would need to be
// stream buffering and scanning to correctly emit prior text
// and to detect all STOP occurrences.
⋮----
// key difference: need to combine after `:`&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/stream-text.ts&quot;&gt;import { AISDKError, LanguageModelV1Source } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { createIdGenerator, IDGenerator } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { DataStreamString, formatDataStreamPart } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { Span } from &amp;apos;@opentelemetry/api&amp;apos;;
import { ServerResponse } from &amp;apos;node:http&amp;apos;;
import { InvalidArgumentError } from &amp;apos;../../errors/invalid-argument-error&amp;apos;;
import { InvalidStreamPartError } from &amp;apos;../../errors/invalid-stream-part-error&amp;apos;;
import { NoOutputSpecifiedError } from &amp;apos;../../errors/no-output-specified-error&amp;apos;;
import { StreamData } from &amp;apos;../../streams/stream-data&amp;apos;;
import { asArray } from &amp;apos;../../util/as-array&amp;apos;;
import { consumeStream } from &amp;apos;../../util/consume-stream&amp;apos;;
import { DelayedPromise } from &amp;apos;../../util/delayed-promise&amp;apos;;
import { DataStreamWriter } from &amp;apos;../data-stream/data-stream-writer&amp;apos;;
import { CallSettings } from &amp;apos;../prompt/call-settings&amp;apos;;
import { convertToLanguageModelPrompt } from &amp;apos;../prompt/convert-to-language-model-prompt&amp;apos;;
import { CoreAssistantMessage } from &amp;apos;../prompt/message&amp;apos;;
import { prepareCallSettings } from &amp;apos;../prompt/prepare-call-settings&amp;apos;;
import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { prepareToolsAndToolChoice } from &amp;apos;../prompt/prepare-tools-and-tool-choice&amp;apos;;
import { Prompt } from &amp;apos;../prompt/prompt&amp;apos;;
import { standardizePrompt } from &amp;apos;../prompt/standardize-prompt&amp;apos;;
import { assembleOperationName } from &amp;apos;../telemetry/assemble-operation-name&amp;apos;;
import { getBaseTelemetryAttributes } from &amp;apos;../telemetry/get-base-telemetry-attributes&amp;apos;;
import { getTracer } from &amp;apos;../telemetry/get-tracer&amp;apos;;
import { recordSpan } from &amp;apos;../telemetry/record-span&amp;apos;;
import { selectTelemetryAttributes } from &amp;apos;../telemetry/select-telemetry-attributes&amp;apos;;
import { TelemetrySettings } from &amp;apos;../telemetry/telemetry-settings&amp;apos;;
import {
  FinishReason,
  LanguageModel,
  LogProbs,
  ToolChoice,
} from &amp;apos;../types/language-model&amp;apos;;
import { LanguageModelResponseMetadata } from &amp;apos;../types/language-model-response-metadata&amp;apos;;
import { ProviderMetadata, ProviderOptions } from &amp;apos;../types/provider-metadata&amp;apos;;
import { addLanguageModelUsage, LanguageModelUsage } from &amp;apos;../types/usage&amp;apos;;
import {
  AsyncIterableStream,
  createAsyncIterableStream,
} from &amp;apos;../util/async-iterable-stream&amp;apos;;
import { createStitchableStream } from &amp;apos;../util/create-stitchable-stream&amp;apos;;
import { mergeStreams } from &amp;apos;../util/merge-streams&amp;apos;;
import { now as originalNow } from &amp;apos;../util/now&amp;apos;;
import { prepareOutgoingHttpHeaders } from &amp;apos;../util/prepare-outgoing-http-headers&amp;apos;;
import { prepareResponseHeaders } from &amp;apos;../util/prepare-response-headers&amp;apos;;
import { splitOnLastWhitespace } from &amp;apos;../util/split-on-last-whitespace&amp;apos;;
import { writeToServerResponse } from &amp;apos;../util/write-to-server-response&amp;apos;;
import { GeneratedFile } from &amp;apos;./generated-file&amp;apos;;
import { Output } from &amp;apos;./output&amp;apos;;
import { asReasoningText, ReasoningDetail } from &amp;apos;./reasoning-detail&amp;apos;;
import {
  runToolsTransformation,
  SingleRequestTextStreamPart,
} from &amp;apos;./run-tools-transformation&amp;apos;;
import { ResponseMessage, StepResult } from &amp;apos;./step-result&amp;apos;;
import {
  ConsumeStreamOptions,
  DataStreamOptions,
  StreamTextResult,
  TextStreamPart,
} from &amp;apos;./stream-text-result&amp;apos;;
import { toResponseMessages } from &amp;apos;./to-response-messages&amp;apos;;
import { ToolCallUnion } from &amp;apos;./tool-call&amp;apos;;
import { ToolCallRepairFunction } from &amp;apos;./tool-call-repair&amp;apos;;
import { ToolResultUnion } from &amp;apos;./tool-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
import { stringifyForTelemetry } from &amp;apos;../prompt/stringify-for-telemetry&amp;apos;;
⋮----
/**
A transformation that is applied to the stream.
@param stopStream - A function that stops the source stream.
@param tools - The tools that are accessible to and can be called by the model. The model needs to support calling tools.
 */
export type StreamTextTransform&amp;lt;TOOLS extends ToolSet&amp;gt; = (options: {
  tools: TOOLS; // for type inference
  stopStream: () =&amp;gt; void;
}) =&amp;gt; TransformStream&amp;lt;TextStreamPart&amp;lt;TOOLS&amp;gt;, TextStreamPart&amp;lt;TOOLS&amp;gt;&amp;gt;;
⋮----
tools: TOOLS; // for type inference
⋮----
/**
Callback that is set using the `onError` option.
@param event - The event that is passed to the callback.
 */
export type StreamTextOnErrorCallback = (event: {
  error: unknown;
}) =&amp;gt; Promise&amp;lt;void&amp;gt; | void;
/**
Callback that is set using the `onStepFinish` option.
@param stepResult - The result of the step.
 */
export type StreamTextOnStepFinishCallback&amp;lt;TOOLS extends ToolSet&amp;gt; = (
  stepResult: StepResult&amp;lt;TOOLS&amp;gt;,
) =&amp;gt; Promise&amp;lt;void&amp;gt; | void;
/**
Callback that is set using the `onChunk` option.
@param event - The event that is passed to the callback.
 */
export type StreamTextOnChunkCallback&amp;lt;TOOLS extends ToolSet&amp;gt; = (event: {
  chunk: Extract&amp;lt;
    TextStreamPart&amp;lt;TOOLS&amp;gt;,
    {
      type:
        | &amp;apos;text-delta&amp;apos;
        | &amp;apos;reasoning&amp;apos;
        | &amp;apos;source&amp;apos;
        | &amp;apos;tool-call&amp;apos;
        | &amp;apos;tool-call-streaming-start&amp;apos;
        | &amp;apos;tool-call-delta&amp;apos;
        | &amp;apos;tool-result&amp;apos;;
    }
  &amp;gt;;
}) =&amp;gt; Promise&amp;lt;void&amp;gt; | void;
/**
Callback that is set using the `onFinish` option.
@param event - The event that is passed to the callback.
 */
export type StreamTextOnFinishCallback&amp;lt;TOOLS extends ToolSet&amp;gt; = (
  event: Omit&amp;lt;StepResult&amp;lt;TOOLS&amp;gt;, &amp;apos;stepType&amp;apos; | &amp;apos;isContinued&amp;apos;&amp;gt; &amp;amp; {
    /**
Details for all steps.
   */
    readonly steps: StepResult&amp;lt;TOOLS&amp;gt;[];
  },
) =&amp;gt; Promise&amp;lt;void&amp;gt; | void;
⋮----
/**
Details for all steps.
   */
⋮----
/**
Generate a text and call tools for a given prompt using a language model.
This function streams the output. If you do not want to stream the output, use `generateText` instead.
@param model - The language model to use.
@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.
@param system - A system message that will be part of the prompt.
@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.
@param messages - A list of messages. You can either use `prompt` or `messages` but not both.
@param maxTokens - Maximum number of tokens to generate.
@param temperature - Temperature setting.
The value is passed through to the provider. The range depends on the provider and model.
It is recommended to set either `temperature` or `topP`, but not both.
@param topP - Nucleus sampling.
The value is passed through to the provider. The range depends on the provider and model.
It is recommended to set either `temperature` or `topP`, but not both.
@param topK - Only sample from the top K options for each subsequent token.
Used to remove &amp;quot;long tail&amp;quot; low probability responses.
Recommended for advanced use cases only. You usually only need to use temperature.
@param presencePenalty - Presence penalty setting.
It affects the likelihood of the model to repeat information that is already in the prompt.
The value is passed through to the provider. The range depends on the provider and model.
@param frequencyPenalty - Frequency penalty setting.
It affects the likelihood of the model to repeatedly use the same words or phrases.
The value is passed through to the provider. The range depends on the provider and model.
@param stopSequences - Stop sequences.
If set, the model will stop generating text when one of the stop sequences is generated.
@param seed - The seed (integer) to use for random sampling.
If set and supported by the model, calls will generate deterministic results.
@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.
@param abortSignal - An optional abort signal that can be used to cancel the call.
@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.
@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.
@param experimental_generateMessageId - Generate a unique ID for each message.
@param onChunk - Callback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.
@param onError - Callback that is called when an error occurs during streaming. You can use it to log errors.
@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.
@param onFinish - Callback that is called when the LLM response and all request tool executions
(for tools that have an `execute` function) are finished.
@return
A result object for accessing different stream types and additional information.
 */
export function streamText&amp;lt;
  TOOLS extends ToolSet,
  OUTPUT = never,
  PARTIAL_OUTPUT = never,
&amp;gt;({
  model,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  headers,
  maxSteps = 1,
  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,
  experimental_output: output,
  experimental_continueSteps: continueSteps = false,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  experimental_toolCallStreaming = false,
  toolCallStreaming = experimental_toolCallStreaming,
  experimental_activeTools: activeTools,
  experimental_repairToolCall: repairToolCall,
  experimental_transform: transform,
  onChunk,
  onError,
  onFinish,
  onStepFinish,
  _internal: {
    now = originalNow,
    generateId = originalGenerateId,
    currentDate = () =&amp;gt; new Date(),
  } = {},
  ...settings
}: CallSettings &amp;amp;
  Prompt &amp;amp; {
    /**
The language model to use.
     */
    model: LanguageModel;
    /**
The tools that the model can call. The model needs to support calling tools.
    */
    tools?: TOOLS;
    /**
The tool choice strategy. Default: &amp;apos;auto&amp;apos;.
     */
    toolChoice?: ToolChoice&amp;lt;TOOLS&amp;gt;;
    /**
Maximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.
A maximum number is required to prevent infinite loops in the case of misconfigured tools.
By default, it&amp;apos;s set to 1, which means that only a single LLM call is made.
 */
    maxSteps?: number;
    /**
Generate a unique ID for each message.
     */
    experimental_generateMessageId?: IDGenerator;
    /**
When enabled, the model will perform additional steps if the finish reason is &amp;quot;length&amp;quot; (experimental).
By default, it&amp;apos;s set to false.
     */
    experimental_continueSteps?: boolean;
    /**
Optional telemetry configuration (experimental).
     */
    experimental_telemetry?: TelemetrySettings;
    /**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
    providerOptions?: ProviderOptions;
    /**
@deprecated Use `providerOptions` instead.
 */
    experimental_providerMetadata?: ProviderMetadata;
    /**
Limits the tools that are available for the model to call without
changing the tool call and result types in the result.
     */
    experimental_activeTools?: Array&amp;lt;keyof TOOLS&amp;gt;;
    /**
Optional specification for parsing structured outputs from the LLM response.
     */
    experimental_output?: Output&amp;lt;OUTPUT, PARTIAL_OUTPUT&amp;gt;;
    /**
A function that attempts to repair a tool call that failed to parse.
     */
    experimental_repairToolCall?: ToolCallRepairFunction&amp;lt;TOOLS&amp;gt;;
    /**
Enable streaming of tool call deltas as they are generated. Disabled by default.
     */
    toolCallStreaming?: boolean;
    /**
@deprecated Use `toolCallStreaming` instead.
     */
    experimental_toolCallStreaming?: boolean;
    /**
Optional stream transformations.
They are applied in the order they are provided.
The stream transformations must maintain the stream structure for streamText to work correctly.
     */
    experimental_transform?:
      | StreamTextTransform&amp;lt;TOOLS&amp;gt;
      | Array&amp;lt;StreamTextTransform&amp;lt;TOOLS&amp;gt;&amp;gt;;
    /**
Callback that is called for each chunk of the stream.
The stream processing will pause until the callback promise is resolved.
     */
    onChunk?: StreamTextOnChunkCallback&amp;lt;TOOLS&amp;gt;;
    /**
Callback that is invoked when an error occurs during streaming.
You can use it to log errors.
The stream processing will pause until the callback promise is resolved.
     */
    onError?: StreamTextOnErrorCallback;
    /**
Callback that is called when the LLM response and all request tool executions
(for tools that have an `execute` function) are finished.
The usage is the combined usage of all steps.
     */
    onFinish?: StreamTextOnFinishCallback&amp;lt;TOOLS&amp;gt;;
    /**
Callback that is called when each step (LLM call) is finished, including intermediate steps.
    */
    onStepFinish?: StreamTextOnStepFinishCallback&amp;lt;TOOLS&amp;gt;;
    /**
Internal. For test use only. May change without notice.
     */
    _internal?: {
now?: ()
⋮----
/**
The language model to use.
     */
⋮----
/**
The tools that the model can call. The model needs to support calling tools.
    */
⋮----
/**
The tool choice strategy. Default: &amp;apos;auto&amp;apos;.
     */
⋮----
/**
Maximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.
A maximum number is required to prevent infinite loops in the case of misconfigured tools.
By default, it&amp;apos;s set to 1, which means that only a single LLM call is made.
 */
⋮----
/**
Generate a unique ID for each message.
     */
⋮----
/**
When enabled, the model will perform additional steps if the finish reason is &amp;quot;length&amp;quot; (experimental).
By default, it&amp;apos;s set to false.
     */
⋮----
/**
Optional telemetry configuration (experimental).
     */
⋮----
/**
Additional provider-specific options. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
Limits the tools that are available for the model to call without
changing the tool call and result types in the result.
     */
⋮----
/**
Optional specification for parsing structured outputs from the LLM response.
     */
⋮----
/**
A function that attempts to repair a tool call that failed to parse.
     */
⋮----
/**
Enable streaming of tool call deltas as they are generated. Disabled by default.
     */
⋮----
/**
@deprecated Use `toolCallStreaming` instead.
     */
⋮----
/**
Optional stream transformations.
They are applied in the order they are provided.
The stream transformations must maintain the stream structure for streamText to work correctly.
     */
⋮----
/**
Callback that is called for each chunk of the stream.
The stream processing will pause until the callback promise is resolved.
     */
⋮----
/**
Callback that is invoked when an error occurs during streaming.
You can use it to log errors.
The stream processing will pause until the callback promise is resolved.
     */
⋮----
/**
Callback that is called when the LLM response and all request tool executions
(for tools that have an `execute` function) are finished.
The usage is the combined usage of all steps.
     */
⋮----
/**
Callback that is called when each step (LLM call) is finished, including intermediate steps.
    */
⋮----
/**
Internal. For test use only. May change without notice.
     */
⋮----
type EnrichedStreamPart&amp;lt;TOOLS extends ToolSet, PARTIAL_OUTPUT&amp;gt; = {
  part: TextStreamPart&amp;lt;TOOLS&amp;gt;;
  partialOutput: PARTIAL_OUTPUT | undefined;
};
function createOutputTransformStream&amp;lt;
  TOOLS extends ToolSet,
  OUTPUT,
  PARTIAL_OUTPUT,
&amp;gt;(
  output: Output&amp;lt;OUTPUT, PARTIAL_OUTPUT&amp;gt; | undefined,
): TransformStream&amp;lt;
  TextStreamPart&amp;lt;TOOLS&amp;gt;,
  EnrichedStreamPart&amp;lt;TOOLS, PARTIAL_OUTPUT&amp;gt;
&amp;gt; {
if (!output)
⋮----
transform(chunk, controller)
⋮----
function publishTextChunk({
    controller,
    partialOutput = undefined,
  }: {
    controller: TransformStreamDefaultController&amp;lt;
      EnrichedStreamPart&amp;lt;TOOLS, PARTIAL_OUTPUT&amp;gt;
    &amp;gt;;
    partialOutput?: PARTIAL_OUTPUT;
})
⋮----
// ensure that we publish the last text chunk before the step finish:
⋮----
// only publish if partial json can be parsed:
⋮----
// only send new json if it has changed:
⋮----
flush(controller)
⋮----
// publish remaining text (there should be none if the content was correctly formatted):
⋮----
class DefaultStreamTextResult&amp;lt;TOOLS extends ToolSet, OUTPUT, PARTIAL_OUTPUT&amp;gt;
implements StreamTextResult&amp;lt;TOOLS, PARTIAL_OUTPUT&amp;gt;
⋮----
constructor({
    model,
    telemetry,
    headers,
    settings,
    maxRetries: maxRetriesArg,
    abortSignal,
    system,
    prompt,
    messages,
    tools,
    toolChoice,
    toolCallStreaming,
    transforms,
    activeTools,
    repairToolCall,
    maxSteps,
    output,
    continueSteps,
    providerOptions,
    now,
    currentDate,
    generateId,
    generateMessageId,
    onChunk,
    onError,
    onFinish,
    onStepFinish,
  }: {
    model: LanguageModel;
    telemetry: TelemetrySettings | undefined;
    headers: Record&amp;lt;string, string | undefined&amp;gt; | undefined;
    settings: Omit&amp;lt;CallSettings, &amp;apos;abortSignal&amp;apos; | &amp;apos;headers&amp;apos;&amp;gt;;
    maxRetries: number | undefined;
    abortSignal: AbortSignal | undefined;
    system: Prompt[&amp;apos;system&amp;apos;];
    prompt: Prompt[&amp;apos;prompt&amp;apos;];
    messages: Prompt[&amp;apos;messages&amp;apos;];
    tools: TOOLS | undefined;
    toolChoice: ToolChoice&amp;lt;TOOLS&amp;gt; | undefined;
    toolCallStreaming: boolean;
    transforms: Array&amp;lt;StreamTextTransform&amp;lt;TOOLS&amp;gt;&amp;gt;;
    activeTools: Array&amp;lt;keyof TOOLS&amp;gt; | undefined;
    repairToolCall: ToolCallRepairFunction&amp;lt;TOOLS&amp;gt; | undefined;
    maxSteps: number;
    output: Output&amp;lt;OUTPUT, PARTIAL_OUTPUT&amp;gt; | undefined;
    continueSteps: boolean;
    providerOptions: ProviderOptions | undefined;
now: ()
⋮----
// callbacks:
⋮----
// event processor for telemetry, invoking callbacks, etc.
// The event processor reads the transformed stream to enable correct
// recording of the final transformed outputs.
⋮----
async transform(chunk, controller)
⋮----
controller.enqueue(chunk); // forward the chunk to the next stream
⋮----
activeReasoningText = undefined; // signature concludes reasoning part
⋮----
// determine the next step type
⋮----
// only use continue when there are no tool calls:
⋮----
// there are tool calls:
⋮----
// all current tool calls have results:
⋮----
// Add step information (after response messages are updated):
⋮----
async flush(controller)
⋮----
return; // no steps recorded (e.g. in error scenario)
⋮----
// from last step (when there are errors there may be no last step)
⋮----
// derived:
⋮----
// from finish:
⋮----
// aggregate results:
⋮----
// call onFinish callback:
⋮----
// Add response information to the root span:
⋮----
// initialize the stitchable stream and the transformed stream:
⋮----
// transform the stream before output parsing
// to enable replacement of stream segments:
⋮----
stopStream()
⋮----
// specific settings that only make sense on the outer level:
⋮----
async function streamStep({
          currentStep,
          responseMessages,
          usage,
          stepType,
          previousStepText,
          hasLeadingWhitespace,
          messageId,
        }: {
          currentStep: number;
          responseMessages: Array&amp;lt;ResponseMessage&amp;gt;;
          usage: LanguageModelUsage;
          stepType: &amp;apos;initial&amp;apos; | &amp;apos;continue&amp;apos; | &amp;apos;tool-result&amp;apos;;
          previousStepText: string;
          hasLeadingWhitespace: boolean;
          messageId: string;
})
⋮----
// after the 1st step, we need to switch to messages format:
⋮----
modelSupportsUrl: model.supportsUrl?.bind(model), // support &amp;apos;this&amp;apos; context
⋮----
// convert the language model level tools:
⋮----
// standardized gen-ai llm span attributes:
⋮----
startTimestampMs: now(), // get before the call
⋮----
// chunk buffer when using continue:
⋮----
let hasWhitespaceSuffix = false; // for next step. when true, step ended with whitespace
async function publishTextChunk({
            controller,
            chunk,
          }: {
            controller: TransformStreamDefaultController&amp;lt;TextStreamPart&amp;lt;TOOLS&amp;gt;&amp;gt;;
            chunk: TextStreamPart&amp;lt;TOOLS&amp;gt; &amp;amp; { type: &amp;apos;text-delta&amp;apos; };
})
⋮----
async transform(chunk, controller): Promise&amp;lt;void&amp;gt;
⋮----
// Telemetry for first chunk:
⋮----
// Step start:
⋮----
// Filter out empty text deltas
⋮----
// when a new step starts, leading whitespace is to be discarded
// when there is already preceding whitespace in the chunk buffer
⋮----
// publish the text until the last whitespace:
⋮----
activeReasoningText = undefined; // signature concludes reasoning part
⋮----
// store tool calls for onFinish callback and toolCalls promise:
⋮----
// store tool results for onFinish callback and toolResults promise:
⋮----
// Note: tool executions might not be finished yet when the finish event is emitted.
// store usage and finish reason for promises and onFinish callback:
⋮----
// Telemetry for finish event timing
// (since tool executions can take longer and distort calculations)
⋮----
// forward:
⋮----
// invoke onFinish callback and resolve toolResults promise when the stream is about to close:
⋮----
// determine the next step type
⋮----
// only use continue when there are no tool calls:
⋮----
// there are tool calls:
⋮----
// all current tool calls have results:
⋮----
// when using continuation, publish buffer on final step or if there
// was no whitespace in the step:
⋮----
(nextStepType !== &amp;apos;continue&amp;apos; || // when the next step is a regular step, publish the buffer
(stepType === &amp;apos;continue&amp;apos; &amp;amp;&amp;amp; !chunkTextPublished)) // when the next step is a continue step, publish the buffer if no text was published in the step
⋮----
// record telemetry information first to ensure best effort timing
⋮----
// standardized gen-ai llm span attributes:
⋮----
// ignore error setting telemetry attributes
⋮----
// finish doStreamSpan before other operations for correct timing:
⋮----
self.closeStream(); // close the stitchable stream
⋮----
// append to messages for the next step:
⋮----
// continue step: update the last assistant message
// continue is only possible when there are no tool calls,
// so we can assume that there is a single last assistant message:
⋮----
// keep the same id when continuing a step:
⋮----
// add the initial stream to the stitchable stream
⋮----
// add an error stream part and close the streams:
⋮----
start(controller)
⋮----
get warnings()
get usage()
get finishReason()
get experimental_providerMetadata()
get providerMetadata()
get text()
get reasoning()
get reasoningDetails()
get sources()
get files()
get toolCalls()
get toolResults()
get request()
get response()
get steps()
/**
Split out a new stream from the original stream.
The original stream is replaced to allow for further splitting,
since we do not know how many times the stream will be split.
Note: this leads to buffering the stream content on the server.
However, the LLM results are expected to be small enough to not cause issues.
   */
private teeStream()
get textStream(): AsyncIterableStream&amp;lt;string&amp;gt;
⋮----
transform(
⋮----
get fullStream(): AsyncIterableStream&amp;lt;TextStreamPart&amp;lt;TOOLS&amp;gt;&amp;gt;
async consumeStream(options?: ConsumeStreamOptions): Promise&amp;lt;void&amp;gt;
get experimental_partialOutputStream(): AsyncIterableStream&amp;lt;PARTIAL_OUTPUT&amp;gt;
private toDataStreamInternal({
    getErrorMessage = () =&amp;gt; &amp;apos;An error occurred.&amp;apos;, // mask error messages for safety by default
    sendUsage = true,
    sendReasoning = false,
    sendSources = false,
    experimental_sendFinish = true,
  }: {
getErrorMessage: ((error: unknown)
⋮----
getErrorMessage = () =&amp;gt; &amp;apos;An error occurred.&amp;apos;, // mask error messages for safety by default
⋮----
pipeDataStreamToResponse(
    response: ServerResponse,
    {
      status,
      statusText,
      headers,
      data,
      getErrorMessage,
      sendUsage,
      sendReasoning,
      sendSources,
      experimental_sendFinish,
    }: ResponseInit &amp;amp;
      DataStreamOptions &amp;amp; {
        data?: StreamData;
getErrorMessage?: (error: unknown)
pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit)
// TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())
toDataStream(
    options?: DataStreamOptions &amp;amp; {
      data?: StreamData;
getErrorMessage?: (error: unknown)
mergeIntoDataStream(writer: DataStreamWriter, options?: DataStreamOptions)
toDataStreamResponse({
    headers,
    status,
    statusText,
    data,
    getErrorMessage,
    sendUsage,
    sendReasoning,
    sendSources,
    experimental_sendFinish,
  }: ResponseInit &amp;amp;
    DataStreamOptions &amp;amp; {
      data?: StreamData;
getErrorMessage?: (error: unknown)
toTextStreamResponse(init?: ResponseInit): Response&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/to-response-messages.test.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import { mockValues } from &amp;apos;../test/mock-values&amp;apos;;
import { tool } from &amp;apos;../tool&amp;apos;;
import { DefaultGeneratedFile } from &amp;apos;./generated-file&amp;apos;;
import { toResponseMessages } from &amp;apos;./to-response-messages&amp;apos;;
⋮----
experimental_toToolResultContent(result)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/to-response-messages.ts&quot;&gt;import { ToolResultPart } from &amp;apos;../prompt&amp;apos;;
import { GeneratedFile } from &amp;apos;./generated-file&amp;apos;;
import { ReasoningDetail } from &amp;apos;./reasoning-detail&amp;apos;;
import { ResponseMessage } from &amp;apos;./step-result&amp;apos;;
import { ToolCallArray } from &amp;apos;./tool-call&amp;apos;;
import { ToolResultArray } from &amp;apos;./tool-result&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
/**
Converts the result of a `generateText` or `streamText` call to a list of response messages.
 */
export function toResponseMessages&amp;lt;TOOLS extends ToolSet&amp;gt;({
  text = &amp;apos;&amp;apos;,
  files,
  reasoning,
  tools,
  toolCalls,
  toolResults,
  messageId,
  generateMessageId,
}: {
  text: string | undefined;
  files: Array&amp;lt;GeneratedFile&amp;gt;;
  reasoning: Array&amp;lt;ReasoningDetail&amp;gt;;
  tools: TOOLS;
  toolCalls: ToolCallArray&amp;lt;TOOLS&amp;gt;;
  toolResults: ToolResultArray&amp;lt;TOOLS&amp;gt;;
  messageId: string;
generateMessageId: ()
⋮----
// TODO language model v2: switch to order response content (instead of type-based ordering)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/tool-call-repair.ts&quot;&gt;import { JSONSchema7, LanguageModelV1FunctionToolCall } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { InvalidToolArgumentsError } from &amp;apos;../../errors/invalid-tool-arguments-error&amp;apos;;
import { NoSuchToolError } from &amp;apos;../../errors/no-such-tool-error&amp;apos;;
import { CoreMessage } from &amp;apos;../prompt&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
/**
 * A function that attempts to repair a tool call that failed to parse.
 *
 * It receives the error and the context as arguments and returns the repair
 * tool call JSON as text.
 *
 * @param options.system - The system prompt.
 * @param options.messages - The messages in the current generation step.
 * @param options.toolCall - The tool call that failed to parse.
 * @param options.tools - The tools that are available.
 * @param options.parameterSchema - A function that returns the JSON Schema for a tool.
 * @param options.error - The error that occurred while parsing the tool call.
 */
export type ToolCallRepairFunction&amp;lt;TOOLS extends ToolSet&amp;gt; = (options: {
  system: string | undefined;
  messages: CoreMessage[];
  toolCall: LanguageModelV1FunctionToolCall;
  tools: TOOLS;
  parameterSchema: (options: { toolName: string }) =&amp;gt; JSONSchema7;
  error: NoSuchToolError | InvalidToolArgumentsError;
}) =&amp;gt; Promise&amp;lt;LanguageModelV1FunctionToolCall | null&amp;gt;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/tool-call.ts&quot;&gt;import { inferParameters } from &amp;apos;../tool/tool&amp;apos;;
import { ValueOf } from &amp;apos;../util/value-of&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
⋮----
// transforms the tools into a tool call union
export type ToolCallUnion&amp;lt;TOOLS extends ToolSet&amp;gt; = ValueOf&amp;lt;{
  [NAME in keyof TOOLS]: {
    type: &amp;apos;tool-call&amp;apos;;
    toolCallId: string;
    toolName: NAME &amp;amp; string;
    args: inferParameters&amp;lt;TOOLS[NAME][&amp;apos;parameters&amp;apos;]&amp;gt;;
  };
}&amp;gt;;
/**
 * @deprecated Use `ToolCallUnion` instead.
 */
// TODO remove in v5
export type CoreToolCallUnion&amp;lt;TOOLS extends ToolSet&amp;gt; = ToolCallUnion&amp;lt;ToolSet&amp;gt;;
export type ToolCallArray&amp;lt;TOOLS extends ToolSet&amp;gt; = Array&amp;lt;ToolCallUnion&amp;lt;TOOLS&amp;gt;&amp;gt;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/tool-result.ts&quot;&gt;import { inferParameters } from &amp;apos;../tool/tool&amp;apos;;
import { ValueOf } from &amp;apos;../util/value-of&amp;apos;;
import { ToolSet } from &amp;apos;./tool-set&amp;apos;;
⋮----
// limits the tools to those with an execute value
type ToToolsWithExecute&amp;lt;TOOLS extends ToolSet&amp;gt; = {
  [K in keyof TOOLS as TOOLS[K] extends { execute: any } ? K : never]: TOOLS[K];
};
// limits the tools to those that have execute !== undefined
export type ToToolsWithDefinedExecute&amp;lt;TOOLS extends ToolSet&amp;gt; = {
  [K in keyof TOOLS as TOOLS[K][&amp;apos;execute&amp;apos;] extends undefined
    ? never
    : K]: TOOLS[K];
};
// transforms the tools into a tool result union
type ToToolResultObject&amp;lt;TOOLS extends ToolSet&amp;gt; = ValueOf&amp;lt;{
  [NAME in keyof TOOLS]: {
    type: &amp;apos;tool-result&amp;apos;;
    toolCallId: string;
    toolName: NAME &amp;amp; string;
    args: inferParameters&amp;lt;TOOLS[NAME][&amp;apos;parameters&amp;apos;]&amp;gt;;
    result: Awaited&amp;lt;ReturnType&amp;lt;Exclude&amp;lt;TOOLS[NAME][&amp;apos;execute&amp;apos;], undefined&amp;gt;&amp;gt;&amp;gt;;
  };
}&amp;gt;;
export type ToolResultUnion&amp;lt;TOOLS extends ToolSet&amp;gt; = ToToolResultObject&amp;lt;
  ToToolsWithDefinedExecute&amp;lt;ToToolsWithExecute&amp;lt;TOOLS&amp;gt;&amp;gt;
&amp;gt;;
/**
 * @deprecated Use `ToolResultUnion` instead.
 */
// TODO remove in v5
export type CoreToolResultUnion&amp;lt;TOOLS extends ToolSet&amp;gt; = ToolResultUnion&amp;lt;TOOLS&amp;gt;;
export type ToolResultArray&amp;lt;TOOLS extends ToolSet&amp;gt; = Array&amp;lt;
  ToolResultUnion&amp;lt;TOOLS&amp;gt;
&amp;gt;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/generate-text/tool-set.ts&quot;&gt;import { Tool } from &amp;apos;../tool&amp;apos;;
export type ToolSet = Record&amp;lt;string, Tool&amp;gt;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/default-settings-middleware.test.ts&quot;&gt;import { LanguageModelV1CallOptions } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { defaultSettingsMiddleware } from &amp;apos;./default-settings-middleware&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/default-settings-middleware.ts&quot;&gt;import {
  LanguageModelV1CallOptions,
  LanguageModelV1ProviderMetadata,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import type { LanguageModelV1Middleware } from &amp;apos;./language-model-v1-middleware&amp;apos;;
import { mergeObjects } from &amp;apos;../util/merge-objects&amp;apos;;
/**
 * Applies default settings for a language model.
 */
export function defaultSettingsMiddleware({
  settings,
}: {
  settings: Partial&amp;lt;
    LanguageModelV1CallOptions &amp;amp; {
      providerMetadata?: LanguageModelV1ProviderMetadata;
    }
  &amp;gt;;
}): LanguageModelV1Middleware
⋮----
// special case for temperature 0
// TODO remove when temperature defaults to undefined&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/extract-reasoning-middleware.test.ts&quot;&gt;import {
  convertArrayToReadableStream,
  convertAsyncIterableToArray,
  mockId,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { generateText, streamText } from &amp;apos;../generate-text&amp;apos;;
import { wrapLanguageModel } from &amp;apos;../middleware/wrap-language-model&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
import { extractReasoningMiddleware } from &amp;apos;./extract-reasoning-middleware&amp;apos;;
⋮----
async doGenerate()
⋮----
async doStream()&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/extract-reasoning-middleware.ts&quot;&gt;import type { LanguageModelV1StreamPart } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { getPotentialStartIndex } from &amp;apos;../util/get-potential-start-index&amp;apos;;
import type { LanguageModelV1Middleware } from &amp;apos;./language-model-v1-middleware&amp;apos;;
/**
 * Extract an XML-tagged reasoning section from the generated text and exposes it
 * as a `reasoning` property on the result.
 *
 * @param tagName - The name of the XML tag to extract reasoning from.
 * @param separator - The separator to use between reasoning and text sections.
 * @param startWithReasoning - Whether to start with reasoning tokens.
 */
export function extractReasoningMiddleware({
  tagName,
  separator = &amp;apos;\n&amp;apos;,
  startWithReasoning = false,
}: {
  tagName: string;
  separator?: string;
  startWithReasoning?: boolean;
}): LanguageModelV1Middleware
⋮----
function publish(text: string)
⋮----
// no opening or closing tag found, publish the buffer
⋮----
// publish text before the tag&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/language-model-v1-middleware.ts&quot;&gt;import { LanguageModelV1, LanguageModelV1CallOptions } from &amp;apos;@ai-sdk/provider&amp;apos;;
/**
 * Experimental middleware for LanguageModelV1.
 * This type defines the structure for middleware that can be used to modify
 * the behavior of LanguageModelV1 operations.
 */
export type LanguageModelV1Middleware = {
  /**
   * Middleware specification version. Use `v1` for the current version.
   */
  middlewareVersion?: &amp;apos;v1&amp;apos; | undefined; // backwards compatibility
  /**
   * Transforms the parameters before they are passed to the language model.
   * @param options - Object containing the type of operation and the parameters.
   * @param options.type - The type of operation (&amp;apos;generate&amp;apos; or &amp;apos;stream&amp;apos;).
   * @param options.params - The original parameters for the language model call.
   * @returns A promise that resolves to the transformed parameters.
   */
  transformParams?: (options: {
    type: &amp;apos;generate&amp;apos; | &amp;apos;stream&amp;apos;;
    params: LanguageModelV1CallOptions;
  }) =&amp;gt; PromiseLike&amp;lt;LanguageModelV1CallOptions&amp;gt;;
  /**
   * Wraps the generate operation of the language model.
   * @param options - Object containing the generate function, parameters, and model.
   * @param options.doGenerate - The original generate function.
   * @param options.doStream - The original stream function.
   * @param options.params - The parameters for the generate call. If the
   * `transformParams` middleware is used, this will be the transformed parameters.
   * @param options.model - The language model instance.
   * @returns A promise that resolves to the result of the generate operation.
   */
  wrapGenerate?: (options: {
    doGenerate: () =&amp;gt; ReturnType&amp;lt;LanguageModelV1[&amp;apos;doGenerate&amp;apos;]&amp;gt;;
    doStream: () =&amp;gt; ReturnType&amp;lt;LanguageModelV1[&amp;apos;doStream&amp;apos;]&amp;gt;;
    params: LanguageModelV1CallOptions;
    model: LanguageModelV1;
  }) =&amp;gt; Promise&amp;lt;Awaited&amp;lt;ReturnType&amp;lt;LanguageModelV1[&amp;apos;doGenerate&amp;apos;]&amp;gt;&amp;gt;&amp;gt;;
  /**
   * Wraps the stream operation of the language model.
   *
   * @param options - Object containing the stream function, parameters, and model.
   * @param options.doGenerate - The original generate function.
   * @param options.doStream - The original stream function.
   * @param options.params - The parameters for the stream call. If the
   * `transformParams` middleware is used, this will be the transformed parameters.
   * @param options.model - The language model instance.
   * @returns A promise that resolves to the result of the stream operation.
   */
  wrapStream?: (options: {
    doGenerate: () =&amp;gt; ReturnType&amp;lt;LanguageModelV1[&amp;apos;doGenerate&amp;apos;]&amp;gt;;
    doStream: () =&amp;gt; ReturnType&amp;lt;LanguageModelV1[&amp;apos;doStream&amp;apos;]&amp;gt;;
    params: LanguageModelV1CallOptions;
    model: LanguageModelV1;
  }) =&amp;gt; PromiseLike&amp;lt;Awaited&amp;lt;ReturnType&amp;lt;LanguageModelV1[&amp;apos;doStream&amp;apos;]&amp;gt;&amp;gt;&amp;gt;;
};
⋮----
/**
   * Middleware specification version. Use `v1` for the current version.
   */
middlewareVersion?: &amp;apos;v1&amp;apos; | undefined; // backwards compatibility
/**
   * Transforms the parameters before they are passed to the language model.
   * @param options - Object containing the type of operation and the parameters.
   * @param options.type - The type of operation (&amp;apos;generate&amp;apos; or &amp;apos;stream&amp;apos;).
   * @param options.params - The original parameters for the language model call.
   * @returns A promise that resolves to the transformed parameters.
   */
⋮----
/**
   * Wraps the generate operation of the language model.
   * @param options - Object containing the generate function, parameters, and model.
   * @param options.doGenerate - The original generate function.
   * @param options.doStream - The original stream function.
   * @param options.params - The parameters for the generate call. If the
   * `transformParams` middleware is used, this will be the transformed parameters.
   * @param options.model - The language model instance.
   * @returns A promise that resolves to the result of the generate operation.
   */
⋮----
/**
   * Wraps the stream operation of the language model.
   *
   * @param options - Object containing the stream function, parameters, and model.
   * @param options.doGenerate - The original generate function.
   * @param options.doStream - The original stream function.
   * @param options.params - The parameters for the stream call. If the
   * `transformParams` middleware is used, this will be the transformed parameters.
   * @param options.model - The language model instance.
   * @returns A promise that resolves to the result of the stream operation.
   */
⋮----
/**
 * @deprecated Use `LanguageModelV1Middleware` instead.
 */
// TODO remove in v5
export type Experimental_LanguageModelV1Middleware = LanguageModelV1Middleware;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/simulate-streaming-middleware.test.ts&quot;&gt;import {
  convertAsyncIterableToArray,
  mockId,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { streamText } from &amp;apos;../generate-text&amp;apos;;
import { wrapLanguageModel } from &amp;apos;../middleware/wrap-language-model&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
import { simulateStreamingMiddleware } from &amp;apos;./simulate-streaming-middleware&amp;apos;;
⋮----
async doGenerate()&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/simulate-streaming-middleware.ts&quot;&gt;import type { LanguageModelV1StreamPart } from &amp;apos;@ai-sdk/provider&amp;apos;;
import type { LanguageModelV1Middleware } from &amp;apos;./language-model-v1-middleware&amp;apos;;
/**
 * Simulates streaming chunks with the response from a generate call.
 */
export function simulateStreamingMiddleware(): LanguageModelV1Middleware
⋮----
start(controller)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/wrap-language-model.test.ts&quot;&gt;import { LanguageModelV1, LanguageModelV1CallOptions } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { wrapLanguageModel } from &amp;apos;../middleware/wrap-language-model&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
⋮----
class MockLanguageModelWithImageSupport implements LanguageModelV1
⋮----
supportsUrl(url: URL)
⋮----
// Reference &amp;apos;this&amp;apos; to verify context
⋮----
// The middlewares should wrap in order, applying wrapGenerate2 last
⋮----
// The middlewares should wrap in order, applying wrapStream2 last&lt;/file&gt;&lt;file path=&quot;packages/ai/core/middleware/wrap-language-model.ts&quot;&gt;import { LanguageModelV1, LanguageModelV1CallOptions } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { LanguageModelV1Middleware } from &amp;apos;./language-model-v1-middleware&amp;apos;;
import { asArray } from &amp;apos;../../util/as-array&amp;apos;;
/**
 * Wraps a LanguageModelV1 instance with middleware functionality.
 * This function allows you to apply middleware to transform parameters,
 * wrap generate operations, and wrap stream operations of a language model.
 *
 * @param options - Configuration options for wrapping the language model.
 * @param options.model - The original LanguageModelV1 instance to be wrapped.
 * @param options.middleware - The middleware to be applied to the language model. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.
 * @param options.modelId - Optional custom model ID to override the original model&amp;apos;s ID.
 * @param options.providerId - Optional custom provider ID to override the original model&amp;apos;s provider.
 * @returns A new LanguageModelV1 instance with middleware applied.
 */
export const wrapLanguageModel = ({
  model,
  middleware: middlewareArg,
  modelId,
  providerId,
}: {
  model: LanguageModelV1;
  middleware: LanguageModelV1Middleware | LanguageModelV1Middleware[];
  modelId?: string;
  providerId?: string;
}): LanguageModelV1 =&amp;gt;
const doWrap = ({
  model,
  middleware: { transformParams, wrapGenerate, wrapStream },
  modelId,
  providerId,
}: {
  model: LanguageModelV1;
  middleware: LanguageModelV1Middleware;
  modelId?: string;
  providerId?: string;
}): LanguageModelV1 =&amp;gt;
⋮----
async function doTransform({
    params,
    type,
  }: {
    params: LanguageModelV1CallOptions;
    type: &amp;apos;generate&amp;apos; | &amp;apos;stream&amp;apos;;
})
⋮----
async doGenerate(
      params: LanguageModelV1CallOptions,
): Promise&amp;lt;Awaited&amp;lt;ReturnType&amp;lt;LanguageModelV1[&amp;apos;doGenerate&amp;apos;]&amp;gt;&amp;gt;&amp;gt;
⋮----
const doGenerate = async ()
const doStream = async ()
⋮----
async doStream(
      params: LanguageModelV1CallOptions,
): Promise&amp;lt;Awaited&amp;lt;ReturnType&amp;lt;LanguageModelV1[&amp;apos;doStream&amp;apos;]&amp;gt;&amp;gt;&amp;gt;
⋮----
/**
 * @deprecated Use `wrapLanguageModel` instead.
 */
// TODO remove in v5&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/append-client-message.test.ts&quot;&gt;import { appendClientMessage } from &amp;apos;./append-client-message&amp;apos;;
import { Message } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/append-client-message.ts&quot;&gt;import { Message } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
/**
 * Appends a client message to the messages array.
 * If the last message in the array has the same id as the new message, it will be replaced.
 * Otherwise, the new message will be appended.
 */
export function appendClientMessage({
  messages,
  message,
}: {
  messages: Message[];
  message: Message;
})&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/append-response-messages.test.ts&quot;&gt;import { describe, expect, it } from &amp;apos;vitest&amp;apos;;
import { appendResponseMessages } from &amp;apos;./append-response-messages&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/append-response-messages.ts&quot;&gt;import {
  extractMaxToolInvocationStep,
  FileUIPart,
  Message,
  ReasoningUIPart,
  StepStartUIPart,
  TextUIPart,
  ToolInvocation,
  ToolInvocationUIPart,
} from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { ResponseMessage } from &amp;apos;../generate-text/step-result&amp;apos;;
import { convertDataContentToBase64String } from &amp;apos;./data-content&amp;apos;;
import { AISDKError } from &amp;apos;@ai-sdk/provider&amp;apos;;
/**
 * Appends the ResponseMessage[] from the response to a Message[] (for useChat).
 * The messages are converted to Messages before being appended.
 * Timestamps are generated for the new messages.
 *
 * @returns A new Message[] with the response messages appended.
 */
export function appendResponseMessages({
  messages,
  responseMessages,
  _internal: { currentDate = () =&amp;gt; new Date() } = {},
}: {
  messages: Message[];
  responseMessages: ResponseMessage[];
  /**
Internal. For test use only. May change without notice.
     */
  _internal?: {
currentDate?: ()
⋮----
/**
Internal. For test use only. May change without notice.
     */
⋮----
// check if the last message is an assistant message:
⋮----
function getToolInvocations(step: number)
⋮----
&amp;gt; = [{ type: &amp;apos;step-start&amp;apos; as const }]; // always start with a step-start part
⋮----
reasoningPart = undefined; // reset the reasoning part
⋮----
// last message was a user message, add the assistant message:
⋮----
createdAt: currentDate(), // generate a createdAt date for the message, will be overridden by the client
⋮----
// for tool call results, add the result to previous message:
lastMessage.toolInvocations ??= []; // ensure the toolInvocations array exists
⋮----
// find the tool call in the previous message:
⋮----
// add the result to the tool call:&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/attachments-to-parts.ts&quot;&gt;import { Attachment } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { FilePart, ImagePart, TextPart } from &amp;apos;./content-part&amp;apos;;
import {
  convertDataContentToUint8Array,
  convertUint8ArrayToText,
} from &amp;apos;./data-content&amp;apos;;
type ContentPart = TextPart | ImagePart | FilePart;
/**
 * Converts a list of attachments to a list of content parts
 * for consumption by `ai/core` functions.
 * Currently only supports images and text attachments.
 */
export function attachmentsToParts(attachments: Attachment[]): ContentPart[]&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/call-settings.ts&quot;&gt;export type CallSettings = {
  /**
Maximum number of tokens to generate.
   */
  maxTokens?: number;
  /**
Temperature setting. This is a number between 0 (almost no randomness) and
1 (very random).
It is recommended to set either `temperature` or `topP`, but not both.
@default 0
   */
  temperature?: number;
  /**
Nucleus sampling. This is a number between 0 and 1.
E.g. 0.1 would mean that only tokens with the top 10% probability mass
are considered.
It is recommended to set either `temperature` or `topP`, but not both.
   */
  topP?: number;
  /**
Only sample from the top K options for each subsequent token.
Used to remove &amp;quot;long tail&amp;quot; low probability responses.
Recommended for advanced use cases only. You usually only need to use temperature.
   */
  topK?: number;
  /**
Presence penalty setting. It affects the likelihood of the model to
repeat information that is already in the prompt.
The presence penalty is a number between -1 (increase repetition)
and 1 (maximum penalty, decrease repetition). 0 means no penalty.
   */
  presencePenalty?: number;
  /**
Frequency penalty setting. It affects the likelihood of the model
to repeatedly use the same words or phrases.
The frequency penalty is a number between -1 (increase repetition)
and 1 (maximum penalty, decrease repetition). 0 means no penalty.
   */
  frequencyPenalty?: number;
  /**
Stop sequences.
If set, the model will stop generating text when one of the stop sequences is generated.
Providers may have limits on the number of stop sequences.
   */
  stopSequences?: string[];
  /**
The seed (integer) to use for random sampling. If set and supported
by the model, calls will generate deterministic results.
   */
  seed?: number;
  /**
Maximum number of retries. Set to 0 to disable retries.
@default 2
   */
  maxRetries?: number;
  /**
Abort signal.
   */
  abortSignal?: AbortSignal;
  /**
Additional HTTP headers to be sent with the request.
Only applicable for HTTP-based providers.
   */
  headers?: Record&amp;lt;string, string | undefined&amp;gt;;
};
⋮----
/**
Maximum number of tokens to generate.
   */
⋮----
/**
Temperature setting. This is a number between 0 (almost no randomness) and
1 (very random).
It is recommended to set either `temperature` or `topP`, but not both.
@default 0
   */
⋮----
/**
Nucleus sampling. This is a number between 0 and 1.
E.g. 0.1 would mean that only tokens with the top 10% probability mass
are considered.
It is recommended to set either `temperature` or `topP`, but not both.
   */
⋮----
/**
Only sample from the top K options for each subsequent token.
Used to remove &amp;quot;long tail&amp;quot; low probability responses.
Recommended for advanced use cases only. You usually only need to use temperature.
   */
⋮----
/**
Presence penalty setting. It affects the likelihood of the model to
repeat information that is already in the prompt.
The presence penalty is a number between -1 (increase repetition)
and 1 (maximum penalty, decrease repetition). 0 means no penalty.
   */
⋮----
/**
Frequency penalty setting. It affects the likelihood of the model
to repeatedly use the same words or phrases.
The frequency penalty is a number between -1 (increase repetition)
and 1 (maximum penalty, decrease repetition). 0 means no penalty.
   */
⋮----
/**
Stop sequences.
If set, the model will stop generating text when one of the stop sequences is generated.
Providers may have limits on the number of stop sequences.
   */
⋮----
/**
The seed (integer) to use for random sampling. If set and supported
by the model, calls will generate deterministic results.
   */
⋮----
/**
Maximum number of retries. Set to 0 to disable retries.
@default 2
   */
⋮----
/**
Abort signal.
   */
⋮----
/**
Additional HTTP headers to be sent with the request.
Only applicable for HTTP-based providers.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/content-part.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import {
  ProviderMetadata,
  providerMetadataSchema,
  ProviderOptions,
} from &amp;apos;../types/provider-metadata&amp;apos;;
import { DataContent, dataContentSchema } from &amp;apos;./data-content&amp;apos;;
import {
  ToolResultContent,
  toolResultContentSchema,
} from &amp;apos;./tool-result-content&amp;apos;;
/**
Text content part of a prompt. It contains a string of text.
 */
export interface TextPart {
  type: &amp;apos;text&amp;apos;;
  /**
The text content.
   */
  text: string;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
 */
  experimental_providerMetadata?: ProviderMetadata;
}
⋮----
/**
The text content.
   */
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
@internal
 */
⋮----
/**
Image content part of a prompt. It contains an image.
 */
export interface ImagePart {
  type: &amp;apos;image&amp;apos;;
  /**
Image data. Can either be:
- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
- URL: a URL that points to the image
   */
  image: DataContent | URL;
  /**
Optional mime type of the image.
   */
  mimeType?: string;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
 */
  experimental_providerMetadata?: ProviderMetadata;
}
⋮----
/**
Image data. Can either be:
- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
- URL: a URL that points to the image
   */
⋮----
/**
Optional mime type of the image.
   */
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
@internal
 */
⋮----
/**
File content part of a prompt. It contains a file.
 */
export interface FilePart {
  type: &amp;apos;file&amp;apos;;
  /**
File data. Can either be:
- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
- URL: a URL that points to the image
   */
  data: DataContent | URL;
  /**
Optional filename of the file.
   */
  filename?: string;
  /**
Mime type of the file.
   */
  mimeType: string;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
 */
  experimental_providerMetadata?: ProviderMetadata;
}
⋮----
/**
File data. Can either be:
- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer
- URL: a URL that points to the image
   */
⋮----
/**
Optional filename of the file.
   */
⋮----
/**
Mime type of the file.
   */
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
@internal
 */
⋮----
/**
 * Reasoning content part of a prompt. It contains a reasoning.
 */
export interface ReasoningPart {
  type: &amp;apos;reasoning&amp;apos;;
  /**
The reasoning text.
   */
  text: string;
  /**
An optional signature for verifying that the reasoning originated from the model.
   */
  signature?: string;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
 */
  experimental_providerMetadata?: ProviderMetadata;
}
⋮----
/**
The reasoning text.
   */
⋮----
/**
An optional signature for verifying that the reasoning originated from the model.
   */
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
@internal
 */
⋮----
/**
Redacted reasoning content part of a prompt.
 */
export interface RedactedReasoningPart {
  type: &amp;apos;redacted-reasoning&amp;apos;;
  /**
Redacted reasoning data.
   */
  data: string;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
 */
  experimental_providerMetadata?: ProviderMetadata;
}
⋮----
/**
Redacted reasoning data.
   */
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
@internal
 */
⋮----
/**
Tool call content part of a prompt. It contains a tool call (usually generated by the AI model).
 */
export interface ToolCallPart {
  type: &amp;apos;tool-call&amp;apos;;
  /**
ID of the tool call. This ID is used to match the tool call with the tool result.
 */
  toolCallId: string;
  /**
Name of the tool that is being called.
 */
  toolName: string;
  /**
Arguments of the tool call. This is a JSON-serializable object that matches the tool&amp;apos;s input schema.
   */
  args: unknown;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
 */
  experimental_providerMetadata?: ProviderMetadata;
}
⋮----
/**
ID of the tool call. This ID is used to match the tool call with the tool result.
 */
⋮----
/**
Name of the tool that is being called.
 */
⋮----
/**
Arguments of the tool call. This is a JSON-serializable object that matches the tool&amp;apos;s input schema.
   */
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
@internal
 */
⋮----
}) as z.ZodType&amp;lt;ToolCallPart&amp;gt;; // necessary bc args is optional on Zod type
/**
Tool result content part of a prompt. It contains the result of the tool call with the matching ID.
 */
export interface ToolResultPart {
  type: &amp;apos;tool-result&amp;apos;;
  /**
ID of the tool call that this result is associated with.
 */
  toolCallId: string;
  /**
Name of the tool that generated this result.
  */
  toolName: string;
  /**
Result of the tool call. This is a JSON-serializable object.
   */
  result: unknown;
  /**
Multi-part content of the tool result. Only for tools that support multipart results.
   */
  experimental_content?: ToolResultContent;
  /**
Optional flag if the result is an error or an error message.
   */
  isError?: boolean;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
 */
  experimental_providerMetadata?: ProviderMetadata;
}
⋮----
/**
ID of the tool call that this result is associated with.
 */
⋮----
/**
Name of the tool that generated this result.
  */
⋮----
/**
Result of the tool call. This is a JSON-serializable object.
   */
⋮----
/**
Multi-part content of the tool result. Only for tools that support multipart results.
   */
⋮----
/**
Optional flag if the result is an error or an error message.
   */
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
@internal
 */
⋮----
}) as z.ZodType&amp;lt;ToolResultPart&amp;gt;; // necessary bc result is optional on Zod type&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/convert-to-core-messages.test.ts&quot;&gt;import { Attachment, Message } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { convertToCoreMessages } from &amp;apos;./convert-to-core-messages&amp;apos;;
import { tool } from &amp;apos;../tool/tool&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { CoreMessage } from &amp;apos;./message&amp;apos;;
⋮----
content: &amp;apos;&amp;apos;, // empty content
⋮----
content: &amp;apos;&amp;apos;, // empty content
⋮----
content: &amp;apos;&amp;apos;, // empty content
⋮----
content: &amp;apos;&amp;apos;, // empty content
⋮----
content: &amp;apos;&amp;apos;, // empty content
toolInvocations: [], // empty invocations
⋮----
{ tools }, // separate tools to ensure that types are inferred correctly
⋮----
content: &amp;apos;&amp;apos;, // empty content
toolInvocations: [], // empty invocations
⋮----
{ tools }, // separate tools to ensure that types are inferred correctly
⋮----
content: &amp;apos;&amp;apos;, // empty content
⋮----
{ tools }, // separate tools to ensure that types are inferred correctly
⋮----
content: &amp;apos;&amp;apos;, // empty content
toolInvocations: [], // empty invocations
⋮----
{ tools }, // separate tools to ensure that types are inferred correctly
⋮----
content: &amp;apos;&amp;apos;, // empty content
toolInvocations: [], // empty invocations
⋮----
{ tools }, // separate tools to ensure that types are inferred correctly
⋮----
{ tools }, // separate tools to ensure that types are inferred correctly
⋮----
{ tools }, // separate tools to ensure that types are inferred correctly&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/convert-to-core-messages.ts&quot;&gt;import {
  FileUIPart,
  Message,
  ReasoningUIPart,
  TextUIPart,
  ToolInvocationUIPart,
} from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { ToolSet } from &amp;apos;../generate-text/tool-set&amp;apos;;
import {
  AssistantContent,
  CoreMessage,
  ToolCallPart,
  ToolResultPart,
} from &amp;apos;../prompt&amp;apos;;
import { attachmentsToParts } from &amp;apos;./attachments-to-parts&amp;apos;;
import { MessageConversionError } from &amp;apos;./message-conversion-error&amp;apos;;
/**
Converts an array of messages from useChat into an array of CoreMessages that can be used
with the AI core functions (e.g. `streamText`).
 */
export function convertToCoreMessages&amp;lt;TOOLS extends ToolSet = never&amp;gt;(
  messages: Array&amp;lt;Omit&amp;lt;Message, &amp;apos;id&amp;apos;&amp;gt;&amp;gt;,
  options?: { tools?: TOOLS },
)
⋮----
function processBlock()
⋮----
// check if there are tool invocations with results in the block
⋮----
// tool message with tool results
⋮----
// updates for next block
⋮----
processBlock(); // text must come before tool invocations
⋮----
// assistant message with tool calls
⋮----
// tool message with tool results
⋮----
// ignore&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/convert-to-language-model-prompt.test.ts&quot;&gt;import { convertUint8ArrayToBase64 } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import {
  convertToLanguageModelMessage,
  convertToLanguageModelPrompt,
} from &amp;apos;./convert-to-language-model-prompt&amp;apos;;
⋮----
const base64Data = &amp;apos;SGVsbG8sIFdvcmxkIQ==&amp;apos;; // &amp;quot;Hello, World!&amp;quot; in base64
⋮----
const uint8Data = new Uint8Array([72, 101, 108, 108, 111]); // &amp;quot;Hello&amp;quot; in ASCII
⋮----
data: &amp;apos;SGVsbG8=&amp;apos;, // base64 encoded &amp;quot;Hello&amp;quot;
⋮----
data: &amp;apos;SGVsbG8sIFdvcmxkIQ==&amp;apos;, // &amp;quot;Hello, World!&amp;quot; in base64
⋮----
// incorrect mimetype:
⋮----
data: &amp;apos;dGVzdA==&amp;apos;, // &amp;quot;test&amp;quot; in base64&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/convert-to-language-model-prompt.ts&quot;&gt;import {
  LanguageModelV1FilePart,
  LanguageModelV1ImagePart,
  LanguageModelV1Message,
  LanguageModelV1Prompt,
  LanguageModelV1TextPart,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { download } from &amp;apos;../../util/download&amp;apos;;
import { CoreMessage } from &amp;apos;../prompt/message&amp;apos;;
import {
  detectMimeType,
  imageMimeTypeSignatures,
} from &amp;apos;../util/detect-mimetype&amp;apos;;
import { FilePart, ImagePart, TextPart } from &amp;apos;./content-part&amp;apos;;
import {
  convertDataContentToBase64String,
  convertDataContentToUint8Array,
  DataContent,
} from &amp;apos;./data-content&amp;apos;;
import { InvalidMessageRoleError } from &amp;apos;./invalid-message-role-error&amp;apos;;
import { splitDataUrl } from &amp;apos;./split-data-url&amp;apos;;
import { StandardizedPrompt } from &amp;apos;./standardize-prompt&amp;apos;;
export async function convertToLanguageModelPrompt({
  prompt,
  modelSupportsImageUrls = true,
  modelSupportsUrl = () =&amp;gt; false,
  downloadImplementation = download,
}: {
  prompt: StandardizedPrompt;
  modelSupportsImageUrls: boolean | undefined;
modelSupportsUrl: undefined | ((url: URL)
/**
 * Convert a CoreMessage to a LanguageModelV1Message.
 *
 * @param message The CoreMessage to convert.
 * @param downloadedAssets A map of URLs to their downloaded data. Only
 *   available if the model does not support URLs, null otherwise.
 */
export function convertToLanguageModelMessage(
  message: CoreMessage,
  downloadedAssets: Record&amp;lt;
    string,
    { mimeType: string | undefined; data: Uint8Array }
  &amp;gt;,
): LanguageModelV1Message
⋮----
// remove empty text parts:
⋮----
// remove empty text parts:
⋮----
/**
 * Downloads images and files from URLs in the messages.
 */
async function downloadAssets(
  messages: CoreMessage[],
  downloadImplementation: typeof download,
  modelSupportsImageUrls: boolean | undefined,
  modelSupportsUrl: (url: URL) =&amp;gt; boolean,
): Promise&amp;lt;Record&amp;lt;string,
⋮----
/**
     * Filter out image parts if the model supports image URLs, before letting it
     * decide if it supports a particular URL.
     */
⋮----
// support string urls:
⋮----
/**
     * Filter out URLs that the model supports natively, so we don&amp;apos;t download them.
     */
⋮----
// download in parallel:
⋮----
/**
 * Convert part of a message to a LanguageModelV1Part.
 * @param part The part to convert.
 * @param downloadedAssets A map of URLs to their downloaded data. Only
 *  available if the model does not support URLs, null otherwise.
 *
 * @returns The converted part.
 */
function convertPartToLanguageModelPart(
  part: TextPart | ImagePart | FilePart,
  downloadedAssets: Record&amp;lt;
    string,
    { mimeType: string | undefined; data: Uint8Array }
  &amp;gt;,
):
  | LanguageModelV1TextPart
  | LanguageModelV1ImagePart
  | LanguageModelV1FilePart {
if (part.type === &amp;apos;text&amp;apos;)
⋮----
// Attempt to create a URL from the data. If it fails, we can assume the data
// is not a URL and likely some other sort of data.
⋮----
// If we successfully created a URL, we can use that to normalize the data
// either by passing it through or converting normalizing the base64 content
// to a Uint8Array.
⋮----
// If the content is a data URL, we want to convert that to a Uint8Array
⋮----
/**
       * If the content is a URL, we should first see if it was downloaded. And if not,
       * we can let the model decide if it wants to support the URL. This also allows
       * for non-HTTP URLs to be passed through (e.g. gs://).
       */
⋮----
// Since we know now the content is not a URL, we can attempt to normalize
// the data assuming it is some sort of data.
⋮----
// Now that we have the normalized data either as a URL or a Uint8Array,
// we can create the LanguageModelV1Part.
⋮----
// When possible, try to detect the mimetype automatically
// to deal with incorrect mimetype inputs.
// When detection fails, use provided mimetype.
⋮----
// We should have a mimeType at this point, if not, throw an error.&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/data-content.test.ts&quot;&gt;import { dataContentSchema } from &amp;apos;./data-content&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/data-content.ts&quot;&gt;import {
  convertBase64ToUint8Array,
  convertUint8ArrayToBase64,
} from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { InvalidDataContentError } from &amp;apos;./invalid-data-content-error&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
/**
Data content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.
 */
export type DataContent = string | Uint8Array | ArrayBuffer | Buffer;
/**
@internal
 */
⋮----
// Buffer might not be available in some environments such as CloudFlare:
⋮----
/**
Converts data content to a base64-encoded string.
@param content - Data content to convert.
@returns Base64-encoded string.
*/
export function convertDataContentToBase64String(content: DataContent): string
/**
Converts data content to a Uint8Array.
@param content - Data content to convert.
@returns Uint8Array.
 */
export function convertDataContentToUint8Array(
  content: DataContent,
): Uint8Array
/**
 * Converts a Uint8Array to a string of text.
 *
 * @param uint8Array - The Uint8Array to convert.
 * @returns The converted string.
 */
export function convertUint8ArrayToText(uint8Array: Uint8Array): string&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/invalid-data-content-error.ts&quot;&gt;import { AISDKError } from &amp;apos;@ai-sdk/provider&amp;apos;;
⋮----
export class InvalidDataContentError extends AISDKError
⋮----
private readonly [symbol] = true; // used in isInstance
⋮----
constructor({
    content,
    cause,
    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,
  }: {
    content: unknown;
    cause?: unknown;
    message?: string;
})
static isInstance(error: unknown): error is InvalidDataContentError&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/invalid-message-role-error.ts&quot;&gt;import { AISDKError } from &amp;apos;@ai-sdk/provider&amp;apos;;
⋮----
export class InvalidMessageRoleError extends AISDKError
⋮----
private readonly [symbol] = true; // used in isInstance
⋮----
constructor({
    role,
    message = `Invalid message role: &amp;apos;${role}&amp;apos;. Must be one of: &amp;quot;system&amp;quot;, &amp;quot;user&amp;quot;, &amp;quot;assistant&amp;quot;, &amp;quot;tool&amp;quot;.`,
  }: {
    role: string;
    message?: string;
})
static isInstance(error: unknown): error is InvalidMessageRoleError&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/message-conversion-error.ts&quot;&gt;import { AISDKError } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { Message } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
⋮----
export class MessageConversionError extends AISDKError
⋮----
private readonly [symbol] = true; // used in isInstance
⋮----
constructor({
    originalMessage,
    message,
  }: {
    originalMessage: Omit&amp;lt;Message, &amp;apos;id&amp;apos;&amp;gt;;
    message: string;
})
static isInstance(error: unknown): error is MessageConversionError&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/message.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import { ProviderMetadata } from &amp;apos;../types&amp;apos;;
import {
  providerMetadataSchema,
  ProviderOptions,
} from &amp;apos;../types/provider-metadata&amp;apos;;
import {
  FilePart,
  filePartSchema,
  ImagePart,
  imagePartSchema,
  ReasoningPart,
  reasoningPartSchema,
  RedactedReasoningPart,
  redactedReasoningPartSchema,
  TextPart,
  textPartSchema,
  ToolCallPart,
  toolCallPartSchema,
  ToolResultPart,
  toolResultPartSchema,
} from &amp;apos;./content-part&amp;apos;;
/**
 A system message. It can contain system information.
 Note: using the &amp;quot;system&amp;quot; part of the prompt is strongly preferred
 to increase the resilience against prompt injection attacks,
 and because not all providers support several system messages.
 */
export type CoreSystemMessage = {
  role: &amp;apos;system&amp;apos;;
  content: string;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
 */
  experimental_providerMetadata?: ProviderMetadata;
};
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
 */
⋮----
/**
A user message. It can contain text or a combination of text and images.
 */
export type CoreUserMessage = {
  role: &amp;apos;user&amp;apos;;
  content: UserContent;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
*/
  experimental_providerMetadata?: ProviderMetadata;
};
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
Content of a user message. It can be a string or an array of text and image parts.
 */
export type UserContent = string | Array&amp;lt;TextPart | ImagePart | FilePart&amp;gt;;
/**
An assistant message. It can contain text, tool calls, or a combination of text and tool calls.
 */
export type CoreAssistantMessage = {
  role: &amp;apos;assistant&amp;apos;;
  content: AssistantContent;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
*/
  experimental_providerMetadata?: ProviderMetadata;
};
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
Content of an assistant message.
It can be a string or an array of text, image, reasoning, redacted reasoning, and tool call parts.
 */
export type AssistantContent =
  | string
  | Array&amp;lt;
      TextPart | FilePart | ReasoningPart | RedactedReasoningPart | ToolCallPart
    &amp;gt;;
/**
A tool message. It contains the result of one or more tool calls.
 */
export type CoreToolMessage = {
  role: &amp;apos;tool&amp;apos;;
  content: ToolContent;
  /**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
  providerOptions?: ProviderOptions;
  /**
@deprecated Use `providerOptions` instead.
*/
  experimental_providerMetadata?: ProviderMetadata;
};
⋮----
/**
Additional provider-specific metadata. They are passed through
to the provider from the AI SDK and enable provider-specific
functionality that can be fully encapsulated in the provider.
 */
⋮----
/**
@deprecated Use `providerOptions` instead.
*/
⋮----
/**
Content of a tool message. It is an array of tool result parts.
 */
export type ToolContent = Array&amp;lt;ToolResultPart&amp;gt;;
/**
A message that can be used in the `messages` field of a prompt.
It can be a user message, an assistant message, or a tool message.
 */
export type CoreMessage =
  | CoreSystemMessage
  | CoreUserMessage
  | CoreAssistantMessage
  | CoreToolMessage;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/prepare-call-settings.test.ts&quot;&gt;import { expect, it } from &amp;apos;vitest&amp;apos;;
import { prepareCallSettings } from &amp;apos;./prepare-call-settings&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/prepare-call-settings.ts&quot;&gt;import { InvalidArgumentError } from &amp;apos;../../errors/invalid-argument-error&amp;apos;;
import { CallSettings } from &amp;apos;./call-settings&amp;apos;;
/**
 * Validates call settings and sets default values.
 */
export function prepareCallSettings({
  maxTokens,
  temperature,
  topP,
  topK,
  presencePenalty,
  frequencyPenalty,
  stopSequences,
  seed,
}: Omit&amp;lt;CallSettings, &amp;apos;abortSignal&amp;apos; | &amp;apos;headers&amp;apos; | &amp;apos;maxRetries&amp;apos;&amp;gt;): Omit&amp;lt;
  CallSettings,
  &amp;apos;abortSignal&amp;apos; | &amp;apos;headers&amp;apos; | &amp;apos;maxRetries&amp;apos;
&amp;gt; {
if (maxTokens != null)
⋮----
// TODO v5 remove default 0 for temperature&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/prepare-retries.test.ts&quot;&gt;import { expect, it } from &amp;apos;vitest&amp;apos;;
import { prepareRetries } from &amp;apos;./prepare-retries&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/prepare-retries.ts&quot;&gt;import { InvalidArgumentError } from &amp;apos;../../errors/invalid-argument-error&amp;apos;;
import {
  RetryFunction,
  retryWithExponentialBackoff,
} from &amp;apos;../../util/retry-with-exponential-backoff&amp;apos;;
/**
 * Validate and prepare retries.
 */
export function prepareRetries({
  maxRetries,
}: {
  maxRetries: number | undefined;
}):&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/prepare-tools-and-tool-choice.test.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import { ToolSet } from &amp;apos;../generate-text/tool-set&amp;apos;;
import { Tool, tool } from &amp;apos;../tool/tool&amp;apos;;
import { prepareToolsAndToolChoice } from &amp;apos;./prepare-tools-and-tool-choice&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/prepare-tools-and-tool-choice.ts&quot;&gt;import {
  LanguageModelV1FunctionTool,
  LanguageModelV1ProviderDefinedTool,
  LanguageModelV1ToolChoice,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { asSchema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { ToolSet } from &amp;apos;../generate-text&amp;apos;;
import { ToolChoice } from &amp;apos;../types/language-model&amp;apos;;
import { isNonEmptyObject } from &amp;apos;../util/is-non-empty-object&amp;apos;;
export function prepareToolsAndToolChoice&amp;lt;TOOLS extends ToolSet&amp;gt;({
  tools,
  toolChoice,
  activeTools,
}: {
  tools: TOOLS | undefined;
  toolChoice: ToolChoice&amp;lt;TOOLS&amp;gt; | undefined;
  activeTools: Array&amp;lt;keyof TOOLS&amp;gt; | undefined;
}):
⋮----
// when activeTools is provided, we only include the tools that are in the list:&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/prompt.ts&quot;&gt;import { Message } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { CoreMessage } from &amp;apos;./message&amp;apos;;
/**
Prompt part of the AI function options.
It contains a system message, a simple text prompt, or a list of messages.
 */
export type Prompt = {
  /**
System message to include in the prompt. Can be used with `prompt` or `messages`.
   */
  system?: string;
  /**
A simple text prompt. You can either use `prompt` or `messages` but not both.
 */
  prompt?: string;
  /**
A list of messages. You can either use `prompt` or `messages` but not both.
   */
  messages?: Array&amp;lt;CoreMessage&amp;gt; | Array&amp;lt;Omit&amp;lt;Message, &amp;apos;id&amp;apos;&amp;gt;&amp;gt;;
};
⋮----
/**
System message to include in the prompt. Can be used with `prompt` or `messages`.
   */
⋮----
/**
A simple text prompt. You can either use `prompt` or `messages` but not both.
 */
⋮----
/**
A list of messages. You can either use `prompt` or `messages` but not both.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/split-data-url.ts&quot;&gt;export function splitDataUrl(dataUrl: string):&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/standardize-prompt.test.ts&quot;&gt;import { Message } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { standardizePrompt } from &amp;apos;./standardize-prompt&amp;apos;;
import { CoreMessage } from &amp;apos;./message&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/standardize-prompt.ts&quot;&gt;import { InvalidPromptError } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { safeValidateTypes } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { Message } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { ToolSet } from &amp;apos;../generate-text/tool-set&amp;apos;;
import { convertToCoreMessages } from &amp;apos;./convert-to-core-messages&amp;apos;;
import { CoreMessage, coreMessageSchema } from &amp;apos;./message&amp;apos;;
import { Prompt } from &amp;apos;./prompt&amp;apos;;
export type StandardizedPrompt = {
  /**
   * Original prompt type. This is forwarded to the providers and can be used
   * to write send raw text to providers that support it.
   */
  type: &amp;apos;prompt&amp;apos; | &amp;apos;messages&amp;apos;;
  /**
   * System message.
   */
  system?: string;
  /**
   * Messages.
   */
  messages: CoreMessage[];
};
⋮----
/**
   * Original prompt type. This is forwarded to the providers and can be used
   * to write send raw text to providers that support it.
   */
⋮----
/**
   * System message.
   */
⋮----
/**
   * Messages.
   */
⋮----
export function standardizePrompt&amp;lt;TOOLS extends ToolSet&amp;gt;({
  prompt,
  tools,
}: {
  prompt: Prompt;
  tools: undefined | TOOLS;
}): StandardizedPrompt
⋮----
// validate that system is a string
⋮----
// type: prompt
⋮----
// validate that prompt is a string
⋮----
// type: messages
⋮----
function detectPromptType(
  prompt: Array&amp;lt;any&amp;gt;,
): &amp;apos;ui-messages&amp;apos; | &amp;apos;messages&amp;apos; | &amp;apos;other&amp;apos;
function detectSingleMessageCharacteristics(
  message: any,
): &amp;apos;has-ui-specific-parts&amp;apos; | &amp;apos;has-core-specific-parts&amp;apos; | &amp;apos;message&amp;apos; | &amp;apos;other&amp;apos;
⋮----
(message.role === &amp;apos;function&amp;apos; || // UI-only role
message.role === &amp;apos;data&amp;apos; || // UI-only role
&amp;apos;toolInvocations&amp;apos; in message || // UI-specific field
&amp;apos;parts&amp;apos; in message || // UI-specific field
⋮----
(Array.isArray(message.content) || // Core messages can have array content&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/stringify-for-telemetry.test.ts&quot;&gt;import { describe, expect, it } from &amp;apos;vitest&amp;apos;;
import { stringifyForTelemetry } from &amp;apos;./stringify-for-telemetry&amp;apos;;
import { LanguageModelV1Prompt } from &amp;apos;@ai-sdk/provider&amp;apos;;
⋮----
// https://cryptii.com/pipes/binary-to-base64 with 010203 in hex format input
⋮----
// https://cryptii.com/pipes/binary-to-base64 with 010203 in hex format input
⋮----
// We expect the URL to be preserved as is
⋮----
// https://cryptii.com/pipes/binary-to-base64 with 010203 in hex format input&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/stringify-for-telemetry.ts&quot;&gt;/**
 * Helper utility to serialize prompt content for OpenTelemetry tracing.
 * It is initially created because normalized LanguageModelV1Prompt carries
 * images as Uint8Arrays, on which JSON.stringify acts weirdly, converting
 * them to objects with stringified indices as keys, e.g. {&amp;quot;0&amp;quot;: 42, &amp;quot;1&amp;quot;: 69 }.
 */
import {
  LanguageModelV1ImagePart,
  LanguageModelV1Message,
  LanguageModelV1Prompt,
  LanguageModelV1ProviderMetadata,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { convertDataContentToBase64String } from &amp;apos;./data-content&amp;apos;;
export function stringifyForTelemetry(prompt: LanguageModelV1Prompt): string
type MessageContentPart = Exclude&amp;lt;
  LanguageModelV1Message[&amp;apos;content&amp;apos;],
  string
&amp;gt;[number];
type ProcessedMessageContentPart =
  | Exclude&amp;lt;MessageContentPart, LanguageModelV1ImagePart&amp;gt;
  | {
      type: &amp;apos;image&amp;apos;;
      image: string | URL;
      mimeType?: string;
      providerMetadata?: LanguageModelV1ProviderMetadata;
    };
function processPart(part: MessageContentPart): ProcessedMessageContentPart&lt;/file&gt;&lt;file path=&quot;packages/ai/core/prompt/tool-result-content.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
export type ToolResultContent = Array&amp;lt;
  | {
      type: &amp;apos;text&amp;apos;;
      text: string;
    }
  | {
      type: &amp;apos;image&amp;apos;;
      data: string; // base64 encoded png image, e.g. screenshot
      mimeType?: string; // e.g. &amp;apos;image/png&amp;apos;;
    }
&amp;gt;;
⋮----
data: string; // base64 encoded png image, e.g. screenshot
mimeType?: string; // e.g. &amp;apos;image/png&amp;apos;;
⋮----
export function isToolResultContent(
  value: unknown,
): value is ToolResultContent&lt;/file&gt;&lt;file path=&quot;packages/ai/core/registry/custom-provider.test.ts&quot;&gt;import { NoSuchModelError } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { describe, expect, it, vi } from &amp;apos;vitest&amp;apos;;
import { MockEmbeddingModelV1 } from &amp;apos;../test/mock-embedding-model-v1&amp;apos;;
import { MockImageModelV1 } from &amp;apos;../test/mock-image-model-v1&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
import { customProvider } from &amp;apos;./custom-provider&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/registry/custom-provider.ts&quot;&gt;import { NoSuchModelError, ProviderV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { EmbeddingModel, ImageModel, LanguageModel, Provider } from &amp;apos;../types&amp;apos;;
/**
 * Creates a custom provider with specified language models, text embedding models, and an optional fallback provider.
 *
 * @param {Object} options - The options for creating the custom provider.
 * @param {Record&amp;lt;string, LanguageModel&amp;gt;} [options.languageModels] - A record of language models, where keys are model IDs and values are LanguageModel instances.
 * @param {Record&amp;lt;string, EmbeddingModel&amp;lt;string&amp;gt;&amp;gt;} [options.textEmbeddingModels] - A record of text embedding models, where keys are model IDs and values are EmbeddingModel&amp;lt;string&amp;gt; instances.
 * @param {Record&amp;lt;string, ImageModel&amp;gt;} [options.imageModels] - A record of image models, where keys are model IDs and values are ImageModel instances.
 * @param {Provider} [options.fallbackProvider] - An optional fallback provider to use when a requested model is not found in the custom provider.
 * @returns {Provider} A Provider object with languageModel, textEmbeddingModel, and imageModel methods.
 *
 * @throws {NoSuchModelError} Throws when a requested model is not found and no fallback provider is available.
 */
export function customProvider&amp;lt;
  LANGUAGE_MODELS extends Record&amp;lt;string, LanguageModel&amp;gt;,
  EMBEDDING_MODELS extends Record&amp;lt;string, EmbeddingModel&amp;lt;string&amp;gt;&amp;gt;,
  IMAGE_MODELS extends Record&amp;lt;string, ImageModel&amp;gt;,
&amp;gt;({
  languageModels,
  textEmbeddingModels,
  imageModels,
  fallbackProvider,
}: {
  languageModels?: LANGUAGE_MODELS;
  textEmbeddingModels?: EMBEDDING_MODELS;
  imageModels?: IMAGE_MODELS;
  fallbackProvider?: ProviderV1;
}): Provider &amp;amp;
⋮----
languageModel(modelId: ExtractModelId&amp;lt;LANGUAGE_MODELS&amp;gt;): LanguageModel;
textEmbeddingModel(
    modelId: ExtractModelId&amp;lt;EMBEDDING_MODELS&amp;gt;,
  ): EmbeddingModel&amp;lt;string&amp;gt;;
imageModel(modelId: ExtractModelId&amp;lt;IMAGE_MODELS&amp;gt;): ImageModel;
⋮----
languageModel(modelId: ExtractModelId&amp;lt;LANGUAGE_MODELS&amp;gt;): LanguageModel
textEmbeddingModel(
      modelId: ExtractModelId&amp;lt;EMBEDDING_MODELS&amp;gt;,
): EmbeddingModel&amp;lt;string&amp;gt;
imageModel(modelId: ExtractModelId&amp;lt;IMAGE_MODELS&amp;gt;): ImageModel
⋮----
/**
 * @deprecated Use `customProvider` instead.
 */
⋮----
type ExtractModelId&amp;lt;MODELS extends Record&amp;lt;string, unknown&amp;gt;&amp;gt; = Extract&amp;lt;
  keyof MODELS,
  string
&amp;gt;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/registry/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/registry/no-such-provider-error.ts&quot;&gt;import { AISDKError, NoSuchModelError } from &amp;apos;@ai-sdk/provider&amp;apos;;
⋮----
export class NoSuchProviderError extends NoSuchModelError
⋮----
private readonly [symbol] = true; // used in isInstance
⋮----
constructor({
    modelId,
    modelType,
    providerId,
    availableProviders,
    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`,
  }: {
    modelId: string;
    modelType: &amp;apos;languageModel&amp;apos; | &amp;apos;textEmbeddingModel&amp;apos;;
    providerId: string;
    availableProviders: string[];
    message?: string;
})
static isInstance(error: unknown): error is NoSuchProviderError&lt;/file&gt;&lt;file path=&quot;packages/ai/core/registry/provider-registry.test.ts&quot;&gt;import { NoSuchModelError } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { MockEmbeddingModelV1 } from &amp;apos;../test/mock-embedding-model-v1&amp;apos;;
import { MockLanguageModelV1 } from &amp;apos;../test/mock-language-model-v1&amp;apos;;
import { NoSuchProviderError } from &amp;apos;./no-such-provider-error&amp;apos;;
import { createProviderRegistry } from &amp;apos;./provider-registry&amp;apos;;
import { MockImageModelV1 } from &amp;apos;../test/mock-image-model-v1&amp;apos;;
⋮----
// @ts-expect-error - should not accept arbitrary strings
⋮----
// @ts-expect-error - should not accept arbitrary strings
⋮----
// @ts-expect-error - should not accept arbitrary strings
⋮----
// @ts-expect-error - should not accept arbitrary strings
⋮----
// @ts-expect-error - should not accept arbitrary strings
⋮----
// @ts-expect-error - should not accept arbitrary strings&lt;/file&gt;&lt;file path=&quot;packages/ai/core/registry/provider-registry.ts&quot;&gt;import { NoSuchModelError, ProviderV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { EmbeddingModel, ImageModel, LanguageModel } from &amp;apos;../types&amp;apos;;
import { NoSuchProviderError } from &amp;apos;./no-such-provider-error&amp;apos;;
type ExtractLiteralUnion&amp;lt;T&amp;gt; = T extends string
  ? string extends T
    ? never
    : T
  : never;
export interface ProviderRegistryProvider&amp;lt;
  PROVIDERS extends Record&amp;lt;string, ProviderV1&amp;gt; = Record&amp;lt;string, ProviderV1&amp;gt;,
  SEPARATOR extends string = &amp;apos;:&amp;apos;,
&amp;gt; {
  languageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string
      ? `${KEY &amp;amp; string}${SEPARATOR}${ExtractLiteralUnion&amp;lt;Parameters&amp;lt;NonNullable&amp;lt;PROVIDERS[KEY][&amp;apos;languageModel&amp;apos;]&amp;gt;&amp;gt;[0]&amp;gt;}`
      : never,
  ): LanguageModel;
  languageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string ? `${KEY &amp;amp; string}${SEPARATOR}${string}` : never,
  ): LanguageModel;
  textEmbeddingModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string
      ? `${KEY &amp;amp; string}${SEPARATOR}${ExtractLiteralUnion&amp;lt;Parameters&amp;lt;NonNullable&amp;lt;PROVIDERS[KEY][&amp;apos;textEmbeddingModel&amp;apos;]&amp;gt;&amp;gt;[0]&amp;gt;}`
      : never,
  ): EmbeddingModel&amp;lt;string&amp;gt;;
  textEmbeddingModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string ? `${KEY &amp;amp; string}${SEPARATOR}${string}` : never,
  ): EmbeddingModel&amp;lt;string&amp;gt;;
  imageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string
      ? `${KEY &amp;amp; string}${SEPARATOR}${ExtractLiteralUnion&amp;lt;Parameters&amp;lt;NonNullable&amp;lt;PROVIDERS[KEY][&amp;apos;imageModel&amp;apos;]&amp;gt;&amp;gt;[0]&amp;gt;}`
      : never,
  ): ImageModel;
  imageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string ? `${KEY &amp;amp; string}${SEPARATOR}${string}` : never,
  ): ImageModel;
}
⋮----
languageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string
      ? `${KEY &amp;amp; string}${SEPARATOR}${ExtractLiteralUnion&amp;lt;Parameters&amp;lt;NonNullable&amp;lt;PROVIDERS[KEY][&amp;apos;languageModel&amp;apos;]&amp;gt;&amp;gt;[0]&amp;gt;}`
      : never,
  ): LanguageModel;
languageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string ? `${KEY &amp;amp; string}${SEPARATOR}${string}` : never,
  ): LanguageModel;
textEmbeddingModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string
      ? `${KEY &amp;amp; string}${SEPARATOR}${ExtractLiteralUnion&amp;lt;Parameters&amp;lt;NonNullable&amp;lt;PROVIDERS[KEY][&amp;apos;textEmbeddingModel&amp;apos;]&amp;gt;&amp;gt;[0]&amp;gt;}`
      : never,
  ): EmbeddingModel&amp;lt;string&amp;gt;;
textEmbeddingModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string ? `${KEY &amp;amp; string}${SEPARATOR}${string}` : never,
  ): EmbeddingModel&amp;lt;string&amp;gt;;
imageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string
      ? `${KEY &amp;amp; string}${SEPARATOR}${ExtractLiteralUnion&amp;lt;Parameters&amp;lt;NonNullable&amp;lt;PROVIDERS[KEY][&amp;apos;imageModel&amp;apos;]&amp;gt;&amp;gt;[0]&amp;gt;}`
      : never,
  ): ImageModel;
imageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: KEY extends string ? `${KEY &amp;amp; string}${SEPARATOR}${string}` : never,
  ): ImageModel;
⋮----
/**
 * Creates a registry for the given providers.
 */
export function createProviderRegistry&amp;lt;
  PROVIDERS extends Record&amp;lt;string, ProviderV1&amp;gt;,
  SEPARATOR extends string = &amp;apos;:&amp;apos;,
&amp;gt;(
  providers: PROVIDERS,
  {
    separator = &amp;apos;:&amp;apos; as SEPARATOR,
  }: {
    separator?: SEPARATOR;
  } = {},
): ProviderRegistryProvider&amp;lt;PROVIDERS, SEPARATOR&amp;gt;
/**
 * @deprecated Use `createProviderRegistry` instead.
 */
⋮----
class DefaultProviderRegistry&amp;lt;
PROVIDERS extends Record&amp;lt;string, ProviderV1&amp;gt;,
⋮----
constructor(
registerProvider&amp;lt;K extends keyof PROVIDERS&amp;gt;({
    id,
    provider,
  }: {
    id: K;
    provider: PROVIDERS[K];
}): void
private getProvider(id: string): ProviderV1
private splitId(
    id: string,
    modelType: &amp;apos;languageModel&amp;apos; | &amp;apos;textEmbeddingModel&amp;apos; | &amp;apos;imageModel&amp;apos;,
): [string, string]
languageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: `${KEY &amp;amp; string}${SEPARATOR}${string}`,
): LanguageModel
textEmbeddingModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: `${KEY &amp;amp; string}${SEPARATOR}${string}`,
): EmbeddingModel&amp;lt;string&amp;gt;
imageModel&amp;lt;KEY extends keyof PROVIDERS&amp;gt;(
    id: `${KEY &amp;amp; string}${SEPARATOR}${string}`,
): ImageModel&lt;/file&gt;&lt;file path=&quot;packages/ai/core/telemetry/assemble-operation-name.ts&quot;&gt;import { TelemetrySettings } from &amp;apos;./telemetry-settings&amp;apos;;
export function assembleOperationName({
  operationId,
  telemetry,
}: {
  operationId: string;
  telemetry?: TelemetrySettings;
})
⋮----
// standardized operation and resource name:
⋮----
// detailed, AI SDK specific data:&lt;/file&gt;&lt;file path=&quot;packages/ai/core/telemetry/get-base-telemetry-attributes.ts&quot;&gt;import { Attributes } from &amp;apos;@opentelemetry/api&amp;apos;;
import { CallSettings } from &amp;apos;../prompt/call-settings&amp;apos;;
import { TelemetrySettings } from &amp;apos;./telemetry-settings&amp;apos;;
export function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry,
  headers,
}: {
  model: { modelId: string; provider: string };
  settings: Omit&amp;lt;CallSettings, &amp;apos;abortSignal&amp;apos; | &amp;apos;headers&amp;apos;&amp;gt;;
  telemetry: TelemetrySettings | undefined;
  headers: Record&amp;lt;string, string | undefined&amp;gt; | undefined;
}): Attributes
⋮----
// settings:
⋮----
// add metadata as attributes:
⋮----
// request headers&lt;/file&gt;&lt;file path=&quot;packages/ai/core/telemetry/get-tracer.ts&quot;&gt;import { Tracer, trace } from &amp;apos;@opentelemetry/api&amp;apos;;
import { noopTracer } from &amp;apos;./noop-tracer&amp;apos;;
export function getTracer({
  isEnabled = false,
  tracer,
}: {
  isEnabled?: boolean;
  tracer?: Tracer;
} =&lt;/file&gt;&lt;file path=&quot;packages/ai/core/telemetry/noop-tracer.ts&quot;&gt;import { Span, SpanContext, Tracer } from &amp;apos;@opentelemetry/api&amp;apos;;
/**
 * Tracer implementation that does nothing (null object).
 */
⋮----
startSpan(): Span
startActiveSpan&amp;lt;F extends (span: Span) =&amp;gt; unknown&amp;gt;(
    name: unknown,
    arg1: unknown,
    arg2?: unknown,
    arg3?: F,
): ReturnType&amp;lt;any&amp;gt;
⋮----
spanContext()
setAttribute()
setAttributes()
addEvent()
addLink()
addLinks()
setStatus()
updateName()
end()
isRecording()
recordException()&lt;/file&gt;&lt;file path=&quot;packages/ai/core/telemetry/record-span.ts&quot;&gt;import { Attributes, Span, Tracer, SpanStatusCode } from &amp;apos;@opentelemetry/api&amp;apos;;
export function recordSpan&amp;lt;T&amp;gt;({
  name,
  tracer,
  attributes,
  fn,
  endWhenDone = true,
}: {
  name: string;
  tracer: Tracer;
  attributes: Attributes;
fn: (span: Span)
⋮----
// always stop the span when there is an error:&lt;/file&gt;&lt;file path=&quot;packages/ai/core/telemetry/select-telemetry-attributes.ts&quot;&gt;import type { Attributes, AttributeValue } from &amp;apos;@opentelemetry/api&amp;apos;;
import type { TelemetrySettings } from &amp;apos;./telemetry-settings&amp;apos;;
export function selectTelemetryAttributes({
  telemetry,
  attributes,
}: {
  telemetry?: TelemetrySettings;
  attributes: {
    [attributeKey: string]:
      | AttributeValue
      | { input: () =&amp;gt; AttributeValue | undefined }
      | { output: () =&amp;gt; AttributeValue | undefined }
      | undefined;
  };
}): Attributes
⋮----
// when telemetry is disabled, return an empty object to avoid serialization overhead:
⋮----
// input value, check if it should be recorded:
⋮----
// default to true:
⋮----
// output value, check if it should be recorded:
⋮----
// default to true:
⋮----
// value is an attribute value already:&lt;/file&gt;&lt;file path=&quot;packages/ai/core/telemetry/select-temetry-attributes.test.ts&quot;&gt;import { selectTelemetryAttributes } from &amp;apos;./select-telemetry-attributes&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/telemetry/telemetry-settings.ts&quot;&gt;import { AttributeValue, Tracer } from &amp;apos;@opentelemetry/api&amp;apos;;
/**
 * Telemetry configuration.
 */
// This is meant to be both flexible for custom app requirements (metadata)
// and extensible for standardization (example: functionId, more to come).
export type TelemetrySettings = {
  /**
   * Enable or disable telemetry. Disabled by default while experimental.
   */
  isEnabled?: boolean;
  /**
   * Enable or disable input recording. Enabled by default.
   *
   * You might want to disable input recording to avoid recording sensitive
   * information, to reduce data transfers, or to increase performance.
   */
  recordInputs?: boolean;
  /**
   * Enable or disable output recording. Enabled by default.
   *
   * You might want to disable output recording to avoid recording sensitive
   * information, to reduce data transfers, or to increase performance.
   */
  recordOutputs?: boolean;
  /**
   * Identifier for this function. Used to group telemetry data by function.
   */
  functionId?: string;
  /**
   * Additional information to include in the telemetry data.
   */
  metadata?: Record&amp;lt;string, AttributeValue&amp;gt;;
  /**
   * A custom tracer to use for the telemetry data.
   */
  tracer?: Tracer;
};
⋮----
/**
   * Enable or disable telemetry. Disabled by default while experimental.
   */
⋮----
/**
   * Enable or disable input recording. Enabled by default.
   *
   * You might want to disable input recording to avoid recording sensitive
   * information, to reduce data transfers, or to increase performance.
   */
⋮----
/**
   * Enable or disable output recording. Enabled by default.
   *
   * You might want to disable output recording to avoid recording sensitive
   * information, to reduce data transfers, or to increase performance.
   */
⋮----
/**
   * Identifier for this function. Used to group telemetry data by function.
   */
⋮----
/**
   * Additional information to include in the telemetry data.
   */
⋮----
/**
   * A custom tracer to use for the telemetry data.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/mock-embedding-model-v1.ts&quot;&gt;import { EmbeddingModelV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { Embedding } from &amp;apos;../types&amp;apos;;
import { EmbeddingModelUsage } from &amp;apos;../types/usage&amp;apos;;
import { notImplemented } from &amp;apos;./not-implemented&amp;apos;;
export class MockEmbeddingModelV1&amp;lt;VALUE&amp;gt; implements EmbeddingModelV1&amp;lt;VALUE&amp;gt;
⋮----
constructor({
    provider = &amp;apos;mock-provider&amp;apos;,
    modelId = &amp;apos;mock-model-id&amp;apos;,
    maxEmbeddingsPerCall = 1,
    supportsParallelCalls = false,
    doEmbed = notImplemented,
  }: {
    provider?: EmbeddingModelV1&amp;lt;VALUE&amp;gt;[&amp;apos;provider&amp;apos;];
    modelId?: EmbeddingModelV1&amp;lt;VALUE&amp;gt;[&amp;apos;modelId&amp;apos;];
    maxEmbeddingsPerCall?:
      | EmbeddingModelV1&amp;lt;VALUE&amp;gt;[&amp;apos;maxEmbeddingsPerCall&amp;apos;]
      | null;
    supportsParallelCalls?: EmbeddingModelV1&amp;lt;VALUE&amp;gt;[&amp;apos;supportsParallelCalls&amp;apos;];
    doEmbed?: EmbeddingModelV1&amp;lt;VALUE&amp;gt;[&amp;apos;doEmbed&amp;apos;];
} =
⋮----
export function mockEmbed&amp;lt;VALUE&amp;gt;(
  expectedValues: Array&amp;lt;VALUE&amp;gt;,
  embeddings: Array&amp;lt;Embedding&amp;gt;,
  usage?: EmbeddingModelUsage,
): EmbeddingModelV1&amp;lt;VALUE&amp;gt;[&amp;apos;doEmbed&amp;apos;]&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/mock-image-model-v1.ts&quot;&gt;import { ImageModelV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { notImplemented } from &amp;apos;./not-implemented&amp;apos;;
export class MockImageModelV1 implements ImageModelV1
⋮----
constructor({
    provider = &amp;apos;mock-provider&amp;apos;,
    modelId = &amp;apos;mock-model-id&amp;apos;,
    maxImagesPerCall = 1,
    doGenerate = notImplemented,
  }: {
    provider?: ImageModelV1[&amp;apos;provider&amp;apos;];
    modelId?: ImageModelV1[&amp;apos;modelId&amp;apos;];
    maxImagesPerCall?: ImageModelV1[&amp;apos;maxImagesPerCall&amp;apos;];
    doGenerate?: ImageModelV1[&amp;apos;doGenerate&amp;apos;];
} =&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/mock-language-model-v1.ts&quot;&gt;import { LanguageModelV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { notImplemented } from &amp;apos;./not-implemented&amp;apos;;
export class MockLanguageModelV1 implements LanguageModelV1
⋮----
constructor({
    provider = &amp;apos;mock-provider&amp;apos;,
    modelId = &amp;apos;mock-model-id&amp;apos;,
    supportsUrl = undefined,
    doGenerate = notImplemented,
    doStream = notImplemented,
    defaultObjectGenerationMode = undefined,
    supportsStructuredOutputs = undefined,
  }: {
    provider?: LanguageModelV1[&amp;apos;provider&amp;apos;];
    modelId?: LanguageModelV1[&amp;apos;modelId&amp;apos;];
    supportsUrl?: LanguageModelV1[&amp;apos;supportsUrl&amp;apos;];
    doGenerate?: LanguageModelV1[&amp;apos;doGenerate&amp;apos;];
    doStream?: LanguageModelV1[&amp;apos;doStream&amp;apos;];
    defaultObjectGenerationMode?: LanguageModelV1[&amp;apos;defaultObjectGenerationMode&amp;apos;];
    supportsStructuredOutputs?: LanguageModelV1[&amp;apos;supportsStructuredOutputs&amp;apos;];
} =&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/mock-server-response.ts&quot;&gt;import { ServerResponse } from &amp;apos;node:http&amp;apos;;
class MockServerResponse
⋮----
write(chunk: any): void
end(): void
⋮----
// You might want to mark the response as ended to simulate the real behavior
⋮----
writeHead(
    statusCode: number,
    statusMessage: string,
    headers: Record&amp;lt;string, string&amp;gt;,
): void
get body()
⋮----
// Combine all written chunks into a single string
⋮----
/**
   * Get the decoded chunks as strings.
   */
getDecodedChunks()
/**
   * Wait for the stream to finish writing to the mock response.
   */
async waitForEnd()
⋮----
const checkIfEnded = () =&amp;gt;
⋮----
export function createMockServerResponse(): ServerResponse &amp;amp;
  MockServerResponse {
  return new MockServerResponse() as ServerResponse &amp;amp; MockServerResponse;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/mock-speech-model-v1.ts&quot;&gt;import { SpeechModelV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { notImplemented } from &amp;apos;./not-implemented&amp;apos;;
export class MockSpeechModelV1 implements SpeechModelV1
⋮----
constructor({
    provider = &amp;apos;mock-provider&amp;apos;,
    modelId = &amp;apos;mock-model-id&amp;apos;,
    doGenerate = notImplemented,
  }: {
    provider?: SpeechModelV1[&amp;apos;provider&amp;apos;];
    modelId?: SpeechModelV1[&amp;apos;modelId&amp;apos;];
    doGenerate?: SpeechModelV1[&amp;apos;doGenerate&amp;apos;];
} =&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/mock-tracer.ts&quot;&gt;import {
  AttributeValue,
  Attributes,
  Context,
  Span,
  SpanContext,
  SpanOptions,
  Tracer,
} from &amp;apos;@opentelemetry/api&amp;apos;;
export class MockTracer implements Tracer
⋮----
get jsonSpans()
startSpan(name: string, options?: SpanOptions, context?: Context): Span
startActiveSpan&amp;lt;F extends (span: Span) =&amp;gt; unknown&amp;gt;(
    name: string,
    arg1: unknown,
    arg2?: unknown,
    arg3?: F,
): ReturnType&amp;lt;any&amp;gt;
⋮----
class MockSpan implements Span
⋮----
constructor({
    name,
    options,
    context,
  }: {
    name: string;
    options?: SpanOptions;
    context?: Context;
})
spanContext(): SpanContext
setAttribute(key: string, value: AttributeValue): this
setAttributes(attributes: Attributes): this
addEvent(name: string, attributes?: Attributes): this
addLink()
addLinks()
setStatus()
updateName()
end()
isRecording()
recordException()
⋮----
class MockSpanContext implements SpanContext&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/mock-transcription-model-v1.ts&quot;&gt;import { TranscriptionModelV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { notImplemented } from &amp;apos;./not-implemented&amp;apos;;
export class MockTranscriptionModelV1 implements TranscriptionModelV1
⋮----
constructor({
    provider = &amp;apos;mock-provider&amp;apos;,
    modelId = &amp;apos;mock-model-id&amp;apos;,
    doGenerate = notImplemented,
  }: {
    provider?: TranscriptionModelV1[&amp;apos;provider&amp;apos;];
    modelId?: TranscriptionModelV1[&amp;apos;modelId&amp;apos;];
    doGenerate?: TranscriptionModelV1[&amp;apos;doGenerate&amp;apos;];
} =&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/mock-values.ts&quot;&gt;export function mockValues&amp;lt;T&amp;gt;(...values: T[]): () =&amp;gt; T&lt;/file&gt;&lt;file path=&quot;packages/ai/core/test/not-implemented.ts&quot;&gt;export function notImplemented(): never&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/mcp/json-rpc-message.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import { BaseParamsSchema, RequestSchema, ResultSchema } from &amp;apos;./types&amp;apos;;
⋮----
export type JSONRPCRequest = z.infer&amp;lt;typeof JSONRPCRequestSchema&amp;gt;;
⋮----
export type JSONRPCResponse = z.infer&amp;lt;typeof JSONRPCResponseSchema&amp;gt;;
⋮----
export type JSONRPCError = z.infer&amp;lt;typeof JSONRPCErrorSchema&amp;gt;;
⋮----
export type JSONRPCNotification = z.infer&amp;lt;typeof JSONRPCNotificationSchema&amp;gt;;
⋮----
export type JSONRPCMessage = z.infer&amp;lt;typeof JSONRPCMessageSchema&amp;gt;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/mcp/mcp-client.test.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import { MCPClientError } from &amp;apos;../../../errors&amp;apos;;
import { createMCPClient } from &amp;apos;./mcp-client&amp;apos;;
import { MockMCPTransport } from &amp;apos;./mock-mcp-transport&amp;apos;;
import { CallToolResult } from &amp;apos;./types&amp;apos;;
⋮----
type ToolParams = Parameters&amp;lt;typeof tool.execute&amp;gt;[0];
⋮----
// Because isCustomMcpTransport will return false, the client will fallback to createMcpTransport, but it will throw because the transport is invalid:
⋮----
// @ts-expect-error - invalid transport
⋮----
// @ts-expect-error - invalid transport&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/mcp/mcp-client.ts&quot;&gt;import { JSONSchema7 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { jsonSchema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { z, ZodType } from &amp;apos;zod&amp;apos;;
import { MCPClientError } from &amp;apos;../../../errors&amp;apos;;
import { inferParameters, tool, Tool, ToolExecutionOptions } from &amp;apos;../tool&amp;apos;;
import {
  JSONRPCError,
  JSONRPCNotification,
  JSONRPCRequest,
  JSONRPCResponse,
} from &amp;apos;./json-rpc-message&amp;apos;;
import {
  createMcpTransport,
  isCustomMcpTransport,
  MCPTransport,
  MCPTransportConfig,
} from &amp;apos;./mcp-transport&amp;apos;;
import {
  CallToolResult,
  CallToolResultSchema,
  Configuration as ClientConfiguration,
  InitializeResultSchema,
  LATEST_PROTOCOL_VERSION,
  ListToolsResult,
  ListToolsResultSchema,
  McpToolSet,
  Notification,
  PaginatedRequest,
  Request,
  RequestOptions,
  ServerCapabilities,
  SUPPORTED_PROTOCOL_VERSIONS,
  ToolSchemas,
} from &amp;apos;./types&amp;apos;;
⋮----
interface MCPClientConfig {
  /** Transport configuration for connecting to the MCP server */
  transport: MCPTransportConfig | MCPTransport;
  /** Optional callback for uncaught errors */
  onUncaughtError?: (error: unknown) =&amp;gt; void;
  /** Optional client name, defaults to &amp;apos;ai-sdk-mcp-client&amp;apos; */
  name?: string;
}
⋮----
/** Transport configuration for connecting to the MCP server */
⋮----
/** Optional callback for uncaught errors */
⋮----
/** Optional client name, defaults to &amp;apos;ai-sdk-mcp-client&amp;apos; */
⋮----
export async function createMCPClient(
  config: MCPClientConfig,
): Promise&amp;lt;MCPClient&amp;gt;
/**
 * A lightweight MCP Client implementation
 *
 * The primary purpose of this client is tool conversion between MCP&amp;lt;&amp;gt;AI SDK
 * but can later be extended to support other MCP features
 *
 * Tool parameters are automatically inferred from the server&amp;apos;s JSON schema
 * if not explicitly provided in the tools configuration
 *
 * This client is meant to be used to communicate with a single server. To communicate and fetch tools across multiple servers, it&amp;apos;s recommended to create a new client instance per server.
 *
 * Not supported:
 * - Client options (e.g. sampling, roots) as they are not needed for tool conversion
 * - Accepting notifications
 * - Session management (when passing a sessionId to an instance of the Streamable HTTP transport)
 * - Resumable SSE streams
 */
class MCPClient
⋮----
constructor({
    transport: transportConfig,
    name = &amp;apos;ai-sdk-mcp-client&amp;apos;,
    onUncaughtError,
}: MCPClientConfig)
⋮----
// This lightweight client implementation does not support
// receiving notifications or requests from server.
// If we get an unsupported message, we can safely ignore it and pass to the onError handler:
⋮----
async init(): Promise&amp;lt;this&amp;gt;
⋮----
// Complete initialization handshake:
⋮----
async close(): Promise&amp;lt;void&amp;gt;
private assertCapability(method: string): void
private async request&amp;lt;T extends ZodType&amp;lt;object&amp;gt;&amp;gt;({
    request,
    resultSchema,
    options,
  }: {
    request: Request;
    resultSchema: T;
    options?: RequestOptions;
}): Promise&amp;lt;z.infer&amp;lt;T&amp;gt;&amp;gt;
⋮----
const cleanup = () =&amp;gt;
⋮----
private async listTools({
    params,
    options,
  }: {
    params?: PaginatedRequest[&amp;apos;params&amp;apos;];
    options?: RequestOptions;
} =
private async callTool({
    name,
    args,
    options,
  }: {
    name: string;
    args: Record&amp;lt;string, unknown&amp;gt;;
    options?: ToolExecutionOptions;
}): Promise&amp;lt;CallToolResult&amp;gt;
private async notification(notification: Notification): Promise&amp;lt;void&amp;gt;
/**
   * Returns a set of AI SDK tools from the MCP server
   * @returns A record of tool names to their implementations
   */
async tools&amp;lt;TOOL_SCHEMAS extends ToolSchemas = &amp;apos;automatic&amp;apos;&amp;gt;({
    schemas = &amp;apos;automatic&amp;apos;,
  }: {
    schemas?: TOOL_SCHEMAS;
} =
private onClose(): void
private onError(error: unknown): void
private onResponse(response: JSONRPCResponse | JSONRPCError): void&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/mcp/mcp-sse-transport.test.ts&quot;&gt;import {
  createTestServer,
  TestResponseController,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { MCPClientError } from &amp;apos;../../../errors&amp;apos;;
import { SseMCPTransport } from &amp;apos;./mcp-sse-transport&amp;apos;;
⋮----
// Verify SSE connection headers
⋮----
// Verify POST request headers&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/mcp/mcp-sse-transport.ts&quot;&gt;import { createEventSourceParserStream } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { MCPClientError } from &amp;apos;../../../errors&amp;apos;;
import { JSONRPCMessage, JSONRPCMessageSchema } from &amp;apos;./json-rpc-message&amp;apos;;
import { MCPTransport } from &amp;apos;./mcp-transport&amp;apos;;
export class SseMCPTransport implements MCPTransport
⋮----
constructor({
    url,
    headers,
  }: {
    url: string;
    headers?: Record&amp;lt;string, string&amp;gt;;
})
async start(): Promise&amp;lt;void&amp;gt;
⋮----
const establishConnection = async () =&amp;gt;
⋮----
const processEvents = async () =&amp;gt;
⋮----
// We do not throw here so we continue processing events after reporting the error
⋮----
async close(): Promise&amp;lt;void&amp;gt;
async send(message: JSONRPCMessage): Promise&amp;lt;void&amp;gt;
⋮----
export function deserializeMessage(line: string): JSONRPCMessage&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/mcp/mcp-transport.ts&quot;&gt;import { MCPClientError } from &amp;apos;../../../errors&amp;apos;;
import { JSONRPCMessage } from &amp;apos;./json-rpc-message&amp;apos;;
import { SseMCPTransport } from &amp;apos;./mcp-sse-transport&amp;apos;;
/**
 * Transport interface for MCP (Model Context Protocol) communication.
 * Maps to the `Transport` interface in the MCP spec.
 */
export interface MCPTransport {
  /**
   * Initialize and start the transport
   */
  start(): Promise&amp;lt;void&amp;gt;;
  /**
   * Send a JSON-RPC message through the transport
   * @param message The JSON-RPC message to send
   */
  send(message: JSONRPCMessage): Promise&amp;lt;void&amp;gt;;
  /**
   * Clean up and close the transport
   */
  close(): Promise&amp;lt;void&amp;gt;;
  /**
   * Event handler for transport closure
   */
  onclose?: () =&amp;gt; void;
  /**
   * Event handler for transport errors
   */
  onerror?: (error: Error) =&amp;gt; void;
  /**
   * Event handler for received messages
   */
  onmessage?: (message: JSONRPCMessage) =&amp;gt; void;
}
⋮----
/**
   * Initialize and start the transport
   */
start(): Promise&amp;lt;void&amp;gt;;
/**
   * Send a JSON-RPC message through the transport
   * @param message The JSON-RPC message to send
   */
send(message: JSONRPCMessage): Promise&amp;lt;void&amp;gt;;
/**
   * Clean up and close the transport
   */
close(): Promise&amp;lt;void&amp;gt;;
/**
   * Event handler for transport closure
   */
⋮----
/**
   * Event handler for transport errors
   */
⋮----
/**
   * Event handler for received messages
   */
⋮----
export type MCPTransportConfig = {
  type: &amp;apos;sse&amp;apos;;
  /**
   * The URL of the MCP server.
   */
  url: string;
  /**
   * Additional HTTP headers to be sent with requests.
   */
  headers?: Record&amp;lt;string, string&amp;gt;;
};
⋮----
/**
   * The URL of the MCP server.
   */
⋮----
/**
   * Additional HTTP headers to be sent with requests.
   */
⋮----
export function createMcpTransport(config: MCPTransportConfig): MCPTransport
export function isCustomMcpTransport(
  transport: MCPTransportConfig | MCPTransport,
): transport is MCPTransport&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/mcp/mock-mcp-transport.ts&quot;&gt;import { delay } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
import { JSONRPCMessage } from &amp;apos;./json-rpc-message&amp;apos;;
import { MCPTransport } from &amp;apos;./mcp-transport&amp;apos;;
import { MCPTool } from &amp;apos;./types&amp;apos;;
⋮----
export class MockMCPTransport implements MCPTransport
⋮----
constructor({
    overrideTools = DEFAULT_TOOLS,
    failOnInvalidToolParams = false,
    initializeResult,
    sendError = false,
  }: {
    overrideTools?: MCPTool[];
    failOnInvalidToolParams?: boolean;
    initializeResult?: Record&amp;lt;string, unknown&amp;gt;;
    sendError?: boolean;
} =
async start(): Promise&amp;lt;void&amp;gt;
async send(message: JSONRPCMessage): Promise&amp;lt;void&amp;gt;
⋮----
// Mock server response implementation - extend as necessary:
⋮----
async close(): Promise&amp;lt;void&amp;gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/mcp/types.ts&quot;&gt;import { z } from &amp;apos;zod&amp;apos;;
import {
  inferParameters,
  Tool,
  ToolExecutionOptions,
  ToolParameters,
} from &amp;apos;../tool&amp;apos;;
⋮----
export type ToolSchemas =
  | Record&amp;lt;string, { parameters: ToolParameters }&amp;gt;
  | &amp;apos;automatic&amp;apos;
  | undefined;
export type McpToolSet&amp;lt;TOOL_SCHEMAS extends ToolSchemas = &amp;apos;automatic&amp;apos;&amp;gt; =
  TOOL_SCHEMAS extends Record&amp;lt;string, { parameters: ToolParameters }&amp;gt;
    ? {
        [K in keyof TOOL_SCHEMAS]: Tool&amp;lt;
          TOOL_SCHEMAS[K][&amp;apos;parameters&amp;apos;],
          CallToolResult
        &amp;gt; &amp;amp; {
          execute: (
            args: inferParameters&amp;lt;TOOL_SCHEMAS[K][&amp;apos;parameters&amp;apos;]&amp;gt;,
            options: ToolExecutionOptions,
          ) =&amp;gt; PromiseLike&amp;lt;CallToolResult&amp;gt;;
        };
      }
    : {
        [k: string]: Tool&amp;lt;z.ZodUnknown, CallToolResult&amp;gt; &amp;amp; {
          execute: (
            args: unknown,
            options: ToolExecutionOptions,
          ) =&amp;gt; PromiseLike&amp;lt;CallToolResult&amp;gt;;
        };
      };
⋮----
export type Configuration = z.infer&amp;lt;typeof ClientOrServerImplementationSchema&amp;gt;;
⋮----
type BaseParams = z.infer&amp;lt;typeof BaseParamsSchema&amp;gt;;
⋮----
export type Request = z.infer&amp;lt;typeof RequestSchema&amp;gt;;
export type RequestOptions = {
  signal?: AbortSignal;
  timeout?: number;
  maxTotalTimeout?: number;
};
export type Notification = z.infer&amp;lt;typeof RequestSchema&amp;gt;;
⋮----
export type ServerCapabilities = z.infer&amp;lt;typeof ServerCapabilitiesSchema&amp;gt;;
⋮----
export type InitializeResult = z.infer&amp;lt;typeof InitializeResultSchema&amp;gt;;
export type PaginatedRequest = Request &amp;amp; {
  params?: BaseParams &amp;amp; {
    cursor?: string;
  };
};
⋮----
export type MCPTool = z.infer&amp;lt;typeof ToolSchema&amp;gt;;
⋮----
export type ListToolsResult = z.infer&amp;lt;typeof ListToolsResultSchema&amp;gt;;
⋮----
/**
     * The URI of this resource.
     */
⋮----
/**
     * The MIME type of this resource, if known.
     */
⋮----
export type CallToolResult = z.infer&amp;lt;typeof CallToolResultSchema&amp;gt;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/tool/tool.ts&quot;&gt;import { Schema } from &amp;apos;@ai-sdk/ui-utils&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { ToolResultContent } from &amp;apos;../prompt/tool-result-content&amp;apos;;
import { CoreMessage } from &amp;apos;../prompt/message&amp;apos;;
export type ToolParameters = z.ZodTypeAny | Schema&amp;lt;any&amp;gt;;
export type inferParameters&amp;lt;PARAMETERS extends ToolParameters&amp;gt; =
  PARAMETERS extends Schema&amp;lt;any&amp;gt;
    ? PARAMETERS[&amp;apos;_type&amp;apos;]
    : PARAMETERS extends z.ZodTypeAny
      ? z.infer&amp;lt;PARAMETERS&amp;gt;
      : never;
export interface ToolExecutionOptions {
  /**
   * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.
   */
  toolCallId: string;
  /**
   * Messages that were sent to the language model to initiate the response that contained the tool call.
   * The messages **do not** include the system prompt nor the assistant response that contained the tool call.
   */
  messages: CoreMessage[];
  /**
   * An optional abort signal that indicates that the overall operation should be aborted.
   */
  abortSignal?: AbortSignal;
}
⋮----
/**
   * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.
   */
⋮----
/**
   * Messages that were sent to the language model to initiate the response that contained the tool call.
   * The messages **do not** include the system prompt nor the assistant response that contained the tool call.
   */
⋮----
/**
   * An optional abort signal that indicates that the overall operation should be aborted.
   */
⋮----
/**
A tool contains the description and the schema of the input that the tool expects.
This enables the language model to generate the input.
The tool can also contain an optional execute function for the actual execution function of the tool.
 */
export type Tool&amp;lt;PARAMETERS extends ToolParameters = any, RESULT = any&amp;gt; = {
  /**
The schema of the input that the tool expects. The language model will use this to generate the input.
It is also used to validate the output of the language model.
Use descriptions to make the input understandable for the language model.
   */
  parameters: PARAMETERS;
  /**
An optional description of what the tool does.
Will be used by the language model to decide whether to use the tool.
Not used for provider-defined tools.
   */
  description?: string;
  /**
Optional conversion function that maps the tool result to multi-part tool content for LLMs.
   */
  experimental_toToolResultContent?: (result: RESULT) =&amp;gt; ToolResultContent;
  /**
An async function that is called with the arguments from the tool call and produces a result.
If not provided, the tool will not be executed automatically.
@args is the input of the tool call.
@options.abortSignal is a signal that can be used to abort the tool call.
   */
  execute?: (
    args: inferParameters&amp;lt;PARAMETERS&amp;gt;,
    options: ToolExecutionOptions,
  ) =&amp;gt; PromiseLike&amp;lt;RESULT&amp;gt;;
} &amp;amp; (
  | {
      /**
Function tool.
       */
      type?: undefined | &amp;apos;function&amp;apos;;
    }
  | {
      /**
Provider-defined tool.
       */
      type: &amp;apos;provider-defined&amp;apos;;
      /**
The ID of the tool. Should follow the format `&amp;lt;provider-name&amp;gt;.&amp;lt;tool-name&amp;gt;`.
       */
      id: `${string}.${string}`;
      /**
The arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.
       */
      args: Record&amp;lt;string, unknown&amp;gt;;
    }
);
⋮----
/**
The schema of the input that the tool expects. The language model will use this to generate the input.
It is also used to validate the output of the language model.
Use descriptions to make the input understandable for the language model.
   */
⋮----
/**
An optional description of what the tool does.
Will be used by the language model to decide whether to use the tool.
Not used for provider-defined tools.
   */
⋮----
/**
Optional conversion function that maps the tool result to multi-part tool content for LLMs.
   */
⋮----
/**
An async function that is called with the arguments from the tool call and produces a result.
If not provided, the tool will not be executed automatically.
@args is the input of the tool call.
@options.abortSignal is a signal that can be used to abort the tool call.
   */
⋮----
/**
Function tool.
       */
⋮----
/**
Provider-defined tool.
       */
⋮----
/**
The ID of the tool. Should follow the format `&amp;lt;provider-name&amp;gt;.&amp;lt;tool-name&amp;gt;`.
       */
⋮----
/**
The arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.
       */
⋮----
/**
 * @deprecated Use `Tool` instead.
 */
// TODO remove in v5
export type CoreTool&amp;lt;
  PARAMETERS extends ToolParameters = any,
  RESULT = any,
&amp;gt; = Tool&amp;lt;PARAMETERS, RESULT&amp;gt;;
/**
Helper function for inferring the execute args of a tool.
 */
// Note: special type inference is needed for the execute function args to make sure they are inferred correctly.
export function tool&amp;lt;PARAMETERS extends ToolParameters, RESULT&amp;gt;(
  tool: Tool&amp;lt;PARAMETERS, RESULT&amp;gt; &amp;amp; {
    execute: (
      args: inferParameters&amp;lt;PARAMETERS&amp;gt;,
      options: ToolExecutionOptions,
)
export function tool&amp;lt;PARAMETERS extends ToolParameters, RESULT&amp;gt;(
  tool: Tool&amp;lt;PARAMETERS, RESULT&amp;gt; &amp;amp; {
    execute?: undefined;
  },
): Tool&amp;lt;PARAMETERS, RESULT&amp;gt; &amp;amp;
export function tool&amp;lt;PARAMETERS extends ToolParameters, RESULT = any&amp;gt;(
  tool: Tool&amp;lt;PARAMETERS, RESULT&amp;gt;,
): Tool&amp;lt;PARAMETERS, RESULT&amp;gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/transcribe/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/transcribe/transcribe-result.ts&quot;&gt;import { JSONValue } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { TranscriptionWarning } from &amp;apos;../types/transcription-model&amp;apos;;
import { TranscriptionModelResponseMetadata } from &amp;apos;../types/transcription-model-response-metadata&amp;apos;;
/**
The result of a `transcribe` call.
It contains the transcript and additional information.
 */
export interface TranscriptionResult {
  /**
   * The complete transcribed text from the audio.
   */
  readonly text: string;
  /**
   * Array of transcript segments with timing information.
   * Each segment represents a portion of the transcribed text with start and end times.
   */
  readonly segments: Array&amp;lt;{
    /**
     * The text content of this segment.
     */
    readonly text: string;
    /**
     * The start time of this segment in seconds.
     */
    readonly startSecond: number;
    /**
     * The end time of this segment in seconds.
     */
    readonly endSecond: number;
  }&amp;gt;;
  /**
   * The detected language of the audio content, as an ISO-639-1 code (e.g., &amp;apos;en&amp;apos; for English).
   * May be undefined if the language couldn&amp;apos;t be detected.
   */
  readonly language: string | undefined;
  /**
   * The total duration of the audio file in seconds.
   * May be undefined if the duration couldn&amp;apos;t be determined.
   */
  readonly durationInSeconds: number | undefined;
  /**
  Warnings for the call, e.g. unsupported settings.
     */
  readonly warnings: Array&amp;lt;TranscriptionWarning&amp;gt;;
  /**
  Response metadata from the provider. There may be multiple responses if we made multiple calls to the model.
   */
  readonly responses: Array&amp;lt;TranscriptionModelResponseMetadata&amp;gt;;
  /**
  Provider metadata from the provider.
   */
  readonly providerMetadata: Record&amp;lt;string, Record&amp;lt;string, JSONValue&amp;gt;&amp;gt;;
}
⋮----
/**
   * The complete transcribed text from the audio.
   */
⋮----
/**
   * Array of transcript segments with timing information.
   * Each segment represents a portion of the transcribed text with start and end times.
   */
⋮----
/**
     * The text content of this segment.
     */
⋮----
/**
     * The start time of this segment in seconds.
     */
⋮----
/**
     * The end time of this segment in seconds.
     */
⋮----
/**
   * The detected language of the audio content, as an ISO-639-1 code (e.g., &amp;apos;en&amp;apos; for English).
   * May be undefined if the language couldn&amp;apos;t be detected.
   */
⋮----
/**
   * The total duration of the audio file in seconds.
   * May be undefined if the duration couldn&amp;apos;t be determined.
   */
⋮----
/**
  Warnings for the call, e.g. unsupported settings.
     */
⋮----
/**
  Response metadata from the provider. There may be multiple responses if we made multiple calls to the model.
   */
⋮----
/**
  Provider metadata from the provider.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/transcribe/transcribe.test.ts&quot;&gt;import {
  JSONValue,
  TranscriptionModelV1,
  TranscriptionModelV1CallWarning,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
import { MockTranscriptionModelV1 } from &amp;apos;../test/mock-transcription-model-v1&amp;apos;;
import { transcribe } from &amp;apos;./transcribe&amp;apos;;
const audioData = new Uint8Array([1, 2, 3, 4]); // Sample audio data
⋮----
const createMockResponse = (options: {
  text: string;
  segments: Array&amp;lt;{
    text: string;
    startSecond: number;
    endSecond: number;
  }&amp;gt;;
  language?: string;
  durationInSeconds?: number;
  warnings?: TranscriptionModelV1CallWarning[];
  timestamp?: Date;
  modelId?: string;
  headers?: Record&amp;lt;string, string&amp;gt;;
  providerMetadata?: Record&amp;lt;string, Record&amp;lt;string, JSONValue&amp;gt;&amp;gt;;
}) =&amp;gt; (&lt;/file&gt;&lt;file path=&quot;packages/ai/core/transcribe/transcribe.ts&quot;&gt;import { JSONValue, TranscriptionModelV1 } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { NoTranscriptGeneratedError } from &amp;apos;../../errors/no-transcript-generated-error&amp;apos;;
import { download } from &amp;apos;../../util/download&amp;apos;;
import { DataContent } from &amp;apos;../prompt&amp;apos;;
import { convertDataContentToUint8Array } from &amp;apos;../prompt/data-content&amp;apos;;
import { prepareRetries } from &amp;apos;../prompt/prepare-retries&amp;apos;;
import { ProviderOptions } from &amp;apos;../types/provider-metadata&amp;apos;;
import { TranscriptionWarning } from &amp;apos;../types/transcription-model&amp;apos;;
import { TranscriptionModelResponseMetadata } from &amp;apos;../types/transcription-model-response-metadata&amp;apos;;
import {
  audioMimeTypeSignatures,
  detectMimeType,
} from &amp;apos;../util/detect-mimetype&amp;apos;;
import { TranscriptionResult } from &amp;apos;./transcribe-result&amp;apos;;
/**
Generates transcripts using a transcription model.
@param model - The transcription model to use.
@param audio - The audio data to transcribe as DataContent (string | Uint8Array | ArrayBuffer | Buffer) or a URL.
@param providerOptions - Additional provider-specific options that are passed through to the provider
as body parameters.
@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.
@param abortSignal - An optional abort signal that can be used to cancel the call.
@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.
@returns A result object that contains the generated transcript.
 */
export async function transcribe({
  model,
  audio,
  providerOptions = {},
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
}: {
  /**
The transcription model to use.
     */
  model: TranscriptionModelV1;
  /**
The audio data to transcribe.
   */
  audio: DataContent | URL;
  /**
Additional provider-specific options that are passed through to the provider
as body parameters.
The outer record is keyed by the provider name, and the inner
record is keyed by the provider-specific metadata key.
```ts
{
  &amp;quot;openai&amp;quot;: {
    &amp;quot;temperature&amp;quot;: 0
  }
}
```
     */
  providerOptions?: ProviderOptions;
  /**
Maximum number of retries per transcript model call. Set to 0 to disable retries.
@default 2
   */
  maxRetries?: number;
  /**
Abort signal.
 */
  abortSignal?: AbortSignal;
  /**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
  headers?: Record&amp;lt;string, string&amp;gt;;
}): Promise&amp;lt;TranscriptionResult&amp;gt;
⋮----
/**
The transcription model to use.
     */
⋮----
/**
The audio data to transcribe.
   */
⋮----
/**
Additional provider-specific options that are passed through to the provider
as body parameters.
The outer record is keyed by the provider name, and the inner
record is keyed by the provider-specific metadata key.
```ts
{
  &amp;quot;openai&amp;quot;: {
    &amp;quot;temperature&amp;quot;: 0
  }
}
```
     */
⋮----
/**
Maximum number of retries per transcript model call. Set to 0 to disable retries.
@default 2
   */
⋮----
/**
Abort signal.
 */
⋮----
/**
Additional headers to include in the request.
Only applicable for HTTP-based providers.
 */
⋮----
class DefaultTranscriptionResult implements TranscriptionResult
⋮----
constructor(options: {
    text: string;
    segments: Array&amp;lt;{
      text: string;
      startSecond: number;
      endSecond: number;
    }&amp;gt;;
    language: string | undefined;
    durationInSeconds: number | undefined;
    warnings: Array&amp;lt;TranscriptionWarning&amp;gt;;
    responses: Array&amp;lt;TranscriptionModelResponseMetadata&amp;gt;;
    providerMetadata: Record&amp;lt;string, Record&amp;lt;string, JSONValue&amp;gt;&amp;gt; | undefined;
})&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/embedding-model.ts&quot;&gt;import { EmbeddingModelV1, EmbeddingModelV1Embedding } from &amp;apos;@ai-sdk/provider&amp;apos;;
/**
Embedding model that is used by the AI SDK Core functions.
*/
export type EmbeddingModel&amp;lt;VALUE&amp;gt; = EmbeddingModelV1&amp;lt;VALUE&amp;gt;;
/**
Embedding.
 */
export type Embedding = EmbeddingModelV1Embedding;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/image-model-response-metadata.ts&quot;&gt;export type ImageModelResponseMetadata = {
  /**
Timestamp for the start of the generated response.
   */
  timestamp: Date;
  /**
The ID of the response model that was used to generate the response.
   */
  modelId: string;
  /**
Response headers.
   */
  headers?: Record&amp;lt;string, string&amp;gt;;
};
⋮----
/**
Timestamp for the start of the generated response.
   */
⋮----
/**
The ID of the response model that was used to generate the response.
   */
⋮----
/**
Response headers.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/image-model.ts&quot;&gt;import { ImageModelV1, ImageModelV1CallWarning } from &amp;apos;@ai-sdk/provider&amp;apos;;
/**
Image model that is used by the AI SDK Core functions.
  */
export type ImageModel = ImageModelV1;
/**
Warning from the model provider for this call. The call will proceed, but e.g.
some settings might not be supported, which can lead to suboptimal results.
  */
export type ImageGenerationWarning = ImageModelV1CallWarning;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/json-value.ts&quot;&gt;import { JSONValue } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/language-model-request-metadata.ts&quot;&gt;export type LanguageModelRequestMetadata = {
  /**
  Raw request HTTP body that was sent to the provider API as a string (JSON should be stringified).
     */
  body?: string;
};
⋮----
/**
  Raw request HTTP body that was sent to the provider API as a string (JSON should be stringified).
     */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/language-model-response-metadata.ts&quot;&gt;export type LanguageModelResponseMetadata = {
  /**
  ID for the generated response.
     */
  id: string;
  /**
  Timestamp for the start of the generated response.
  */
  timestamp: Date;
  /**
  The ID of the response model that was used to generate the response.
  */
  modelId: string;
  /**
Response headers (available only for providers that use HTTP requests).
     */
  headers?: Record&amp;lt;string, string&amp;gt;;
};
⋮----
/**
  ID for the generated response.
     */
⋮----
/**
  Timestamp for the start of the generated response.
  */
⋮----
/**
  The ID of the response model that was used to generate the response.
  */
⋮----
/**
Response headers (available only for providers that use HTTP requests).
     */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/language-model.ts&quot;&gt;import {
  LanguageModelV1,
  LanguageModelV1CallWarning,
  LanguageModelV1FinishReason,
  LanguageModelV1LogProbs,
  LanguageModelV1Source,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
// Re-export LanguageModelV1 types for the middleware:
⋮----
/**
Language model that is used by the AI SDK Core functions.
*/
export type LanguageModel = LanguageModelV1;
/**
Reason why a language model finished generating a response.
Can be one of the following:
- `stop`: model generated stop sequence
- `length`: model generated maximum number of tokens
- `content-filter`: content filter violation stopped the model
- `tool-calls`: model triggered tool calls
- `error`: model stopped because of an error
- `other`: model stopped for other reasons
*/
export type FinishReason = LanguageModelV1FinishReason;
/**
Log probabilities for each token and its top log probabilities.
@deprecated Will become a provider extension in the future.
 */
export type LogProbs = LanguageModelV1LogProbs;
/**
Warning from the model provider for this call. The call will proceed, but e.g.
some settings might not be supported, which can lead to suboptimal results.
*/
export type CallWarning = LanguageModelV1CallWarning;
/**
A source that has been used as input to generate the response.
*/
export type Source = LanguageModelV1Source;
/**
Tool choice for the generation. It supports the following settings:
- `auto` (default): the model can choose whether and which tools to call.
- `required`: the model must call a tool. It can choose which tool to call.
- `none`: the model must not call tools
- `{ type: &amp;apos;tool&amp;apos;, toolName: string (typed) }`: the model must call the specified tool
 */
export type ToolChoice&amp;lt;TOOLS extends Record&amp;lt;string, unknown&amp;gt;&amp;gt; =
  | &amp;apos;auto&amp;apos;
  | &amp;apos;none&amp;apos;
  | &amp;apos;required&amp;apos;
  | { type: &amp;apos;tool&amp;apos;; toolName: keyof TOOLS };
/**
 * @deprecated Use `ToolChoice` instead.
 */
// TODO remove in v5
export type CoreToolChoice&amp;lt;TOOLS extends Record&amp;lt;string, unknown&amp;gt;&amp;gt; =
  ToolChoice&amp;lt;TOOLS&amp;gt;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/provider-metadata.ts&quot;&gt;import { LanguageModelV1ProviderMetadata } from &amp;apos;@ai-sdk/provider&amp;apos;;
import { z } from &amp;apos;zod&amp;apos;;
import { jsonValueSchema } from &amp;apos;./json-value&amp;apos;;
/**
Additional provider-specific metadata that is returned from the provider.
This is needed to enable provider-specific functionality that can be
fully encapsulated in the provider.
 */
export type ProviderMetadata = LanguageModelV1ProviderMetadata;
/**
Additional provider-specific options.
They are passed through to the provider from the AI SDK and enable
provider-specific functionality that can be fully encapsulated in the provider.
 */
// TODO change to LanguageModelV2ProviderOptions in language model v2
export type ProviderOptions = LanguageModelV1ProviderMetadata;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/provider.ts&quot;&gt;import { EmbeddingModel } from &amp;apos;./embedding-model&amp;apos;;
import { LanguageModel } from &amp;apos;./language-model&amp;apos;;
import { ImageModel } from &amp;apos;./image-model&amp;apos;;
/**
 * Provider for language, text embedding, and image models.
 */
export type Provider = {
  /**
  Returns the language model with the given id.
  The model id is then passed to the provider function to get the model.
  @param {string} id - The id of the model to return.
  @returns {LanguageModel} The language model associated with the id
  @throws {NoSuchModelError} If no such model exists.
     */
  languageModel(modelId: string): LanguageModel;
  /**
  Returns the text embedding model with the given id.
  The model id is then passed to the provider function to get the model.
  @param {string} id - The id of the model to return.
  @returns {LanguageModel} The language model associated with the id
  @throws {NoSuchModelError} If no such model exists.
     */
  textEmbeddingModel(modelId: string): EmbeddingModel&amp;lt;string&amp;gt;;
  /**
  Returns the image model with the given id.
  The model id is then passed to the provider function to get the model.
  @param {string} id - The id of the model to return.
  @returns {ImageModel} The image model associated with the id
  */
  imageModel(modelId: string): ImageModel;
};
⋮----
/**
  Returns the language model with the given id.
  The model id is then passed to the provider function to get the model.
  @param {string} id - The id of the model to return.
  @returns {LanguageModel} The language model associated with the id
  @throws {NoSuchModelError} If no such model exists.
     */
languageModel(modelId: string): LanguageModel;
/**
  Returns the text embedding model with the given id.
  The model id is then passed to the provider function to get the model.
  @param {string} id - The id of the model to return.
  @returns {LanguageModel} The language model associated with the id
  @throws {NoSuchModelError} If no such model exists.
     */
textEmbeddingModel(modelId: string): EmbeddingModel&amp;lt;string&amp;gt;;
/**
  Returns the image model with the given id.
  The model id is then passed to the provider function to get the model.
  @param {string} id - The id of the model to return.
  @returns {ImageModel} The image model associated with the id
  */
imageModel(modelId: string): ImageModel;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/speech-model-response-metadata.ts&quot;&gt;export type SpeechModelResponseMetadata = {
  /**
Timestamp for the start of the generated response.
   */
  timestamp: Date;
  /**
The ID of the response model that was used to generate the response.
   */
  modelId: string;
  /**
Response headers.
   */
  headers?: Record&amp;lt;string, string&amp;gt;;
};
⋮----
/**
Timestamp for the start of the generated response.
   */
⋮----
/**
The ID of the response model that was used to generate the response.
   */
⋮----
/**
Response headers.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/speech-model.ts&quot;&gt;import { SpeechModelV1, SpeechModelV1CallWarning } from &amp;apos;@ai-sdk/provider&amp;apos;;
/**
Speech model that is used by the AI SDK Core functions.
  */
export type SpeechModel = SpeechModelV1;
/**
Warning from the model provider for this call. The call will proceed, but e.g.
some settings might not be supported, which can lead to suboptimal results.
  */
export type SpeechWarning = SpeechModelV1CallWarning;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/transcription-model-response-metadata.ts&quot;&gt;export type TranscriptionModelResponseMetadata = {
  /**
Timestamp for the start of the generated response.
   */
  timestamp: Date;
  /**
The ID of the response model that was used to generate the response.
   */
  modelId: string;
  /**
Response headers.
   */
  headers?: Record&amp;lt;string, string&amp;gt;;
};
⋮----
/**
Timestamp for the start of the generated response.
   */
⋮----
/**
The ID of the response model that was used to generate the response.
   */
⋮----
/**
Response headers.
   */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/transcription-model.ts&quot;&gt;import {
  TranscriptionModelV1,
  TranscriptionModelV1CallWarning,
} from &amp;apos;@ai-sdk/provider&amp;apos;;
/**
Transcription model that is used by the AI SDK Core functions.
  */
export type TranscriptionModel = TranscriptionModelV1;
/**
Warning from the model provider for this call. The call will proceed, but e.g.
some settings might not be supported, which can lead to suboptimal results.
  */
export type TranscriptionWarning = TranscriptionModelV1CallWarning;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/types/usage.ts&quot;&gt;/**
Represents the number of tokens used in a prompt and completion.
 */
export type LanguageModelUsage = {
  /**
The number of tokens used in the prompt.
   */
  promptTokens: number;
  /**
The number of tokens used in the completion.
 */
  completionTokens: number;
  /**
The total number of tokens used (promptTokens + completionTokens).
   */
  totalTokens: number;
};
⋮----
/**
The number of tokens used in the prompt.
   */
⋮----
/**
The number of tokens used in the completion.
 */
⋮----
/**
The total number of tokens used (promptTokens + completionTokens).
   */
⋮----
/**
Represents the number of tokens used in an embedding.
 */
export type EmbeddingModelUsage = {
  /**
The number of tokens used in the embedding.
   */
  tokens: number;
};
⋮----
/**
The number of tokens used in the embedding.
   */
⋮----
export function calculateLanguageModelUsage({
  promptTokens,
  completionTokens,
}: {
  promptTokens: number;
  completionTokens: number;
}): LanguageModelUsage
export function addLanguageModelUsage(
  usage1: LanguageModelUsage,
  usage2: LanguageModelUsage,
): LanguageModelUsage&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/async-iterable-stream.test.ts&quot;&gt;import {
  convertArrayToReadableStream,
  convertAsyncIterableToArray,
  convertReadableStreamToArray,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { describe, expect, it } from &amp;apos;vitest&amp;apos;;
import { createAsyncIterableStream } from &amp;apos;./async-iterable-stream&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/async-iterable-stream.ts&quot;&gt;export type AsyncIterableStream&amp;lt;T&amp;gt; = AsyncIterable&amp;lt;T&amp;gt; &amp;amp; ReadableStream&amp;lt;T&amp;gt;;
export function createAsyncIterableStream&amp;lt;T&amp;gt;(
  source: ReadableStream&amp;lt;T&amp;gt;,
): AsyncIterableStream&amp;lt;T&amp;gt;
⋮----
async next(): Promise&amp;lt;IteratorResult&amp;lt;T&amp;gt;&amp;gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/cosine-similarity.test.ts&quot;&gt;import { cosineSimilarity } from &amp;apos;./cosine-similarity&amp;apos;;
⋮----
// test against pre-calculated value:
⋮----
// test against pre-calculated value:&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/cosine-similarity.ts&quot;&gt;import { InvalidArgumentError } from &amp;apos;../../errors/invalid-argument-error&amp;apos;;
/**
 * Calculates the cosine similarity between two vectors. This is a useful metric for
 * comparing the similarity of two vectors such as embeddings.
 *
 * @param vector1 - The first vector.
 * @param vector2 - The second vector.
 * @param options - Optional configuration.
 * @param options.throwErrorForEmptyVectors - If true, throws an error for empty vectors. Default: false.
 *
 * @returns The cosine similarity between vector1 and vector2.
 * @returns 0 if either vector is the zero vector.
 *
 * @throws {InvalidArgumentError} If throwErrorForEmptyVectors is true and vectors are empty.
 * @throws {InvalidArgumentError} If the vectors do not have the same length.
 */
export function cosineSimilarity(
  vector1: number[],
  vector2: number[],
  // TODO remove throw option in 5.0
  options?: {
    /**
     * @deprecated will be removed in 5.0
     */
    throwErrorForEmptyVectors?: boolean;
  },
): number
⋮----
// TODO remove throw option in 5.0
⋮----
/**
     * @deprecated will be removed in 5.0
     */
⋮----
return 0; // Return 0 for empty vectors if no error is thrown&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/create-stitchable-stream.test.ts&quot;&gt;import {
  convertArrayToReadableStream,
  convertReadableStreamToArray,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { expect } from &amp;apos;vitest&amp;apos;;
import { createStitchableStream } from &amp;apos;./create-stitchable-stream&amp;apos;;
⋮----
// Start reading before any values are added
⋮----
// Add value with delay after starting read
⋮----
// Value should be returned once available
⋮----
// Stream should complete after value is read
⋮----
// read 5 values from the stream before they are added
// (added asynchronously)
⋮----
// wait for the stream to finish via await:
⋮----
start(controller)
⋮----
cancel()
⋮----
// Start reading from the stream
⋮----
// Should immediately close without reading remaining values&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/create-stitchable-stream.ts&quot;&gt;import { createResolvablePromise } from &amp;apos;../../util/create-resolvable-promise&amp;apos;;
/**
 * Creates a stitchable stream that can pipe one stream at a time.
 *
 * @template T - The type of values emitted by the streams.
 * @returns {Object} An object containing the stitchable stream and control methods.
 */
export function createStitchableStream&amp;lt;T&amp;gt;():
⋮----
const processPull = async () =&amp;gt;
⋮----
// Case 1: Outer stream is closed and no more inner streams
⋮----
// Case 2: No inner streams available, but outer stream is open
// wait for a new inner stream to be added or the outer stream to close
⋮----
// Case 3: Current inner stream is done
innerStreamReaders.shift(); // Remove the finished stream
// Continue pulling from the next stream if available
⋮----
// Case 4: Current inner stream returns an item
⋮----
// Case 5: Current inner stream throws an error
⋮----
innerStreamReaders.shift(); // Remove the errored stream
⋮----
start(controllerParam)
⋮----
async cancel()
⋮----
/**
     * Gracefully close the outer stream. This will let the inner streams
     * finish processing and then close the outer stream.
     */
⋮----
/**
     * Immediately close the outer stream. This will cancel all inner streams
     * and close the outer stream.
     */&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/detect-mimetype.test.ts&quot;&gt;import { describe, it, expect } from &amp;apos;vitest&amp;apos;;
import {
  detectMimeType,
  imageMimeTypeSignatures,
  audioMimeTypeSignatures,
} from &amp;apos;./detect-mimetype&amp;apos;;
import { convertUint8ArrayToBase64 } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
⋮----
const gifBase64 = &amp;apos;R0lGabc123&amp;apos;; // Base64 string starting with GIF signature
⋮----
const pngBase64 = &amp;apos;iVBORwabc123&amp;apos;; // Base64 string starting with PNG signature
⋮----
const jpegBase64 = &amp;apos;/9j/abc123&amp;apos;; // Base64 string starting with JPEG signature
⋮----
const webpBase64 = &amp;apos;UklGRgabc123&amp;apos;; // Base64 string starting with WebP signature
⋮----
const bmpBase64 = &amp;apos;Qkabc123&amp;apos;; // Base64 string starting with BMP signature
⋮----
const tiffLEBase64 = &amp;apos;SUkqAAabc123&amp;apos;; // Base64 string starting with TIFF LE signature
⋮----
const tiffBEBase64 = &amp;apos;TU0AKgabc123&amp;apos;; // Base64 string starting with TIFF BE signature
⋮----
const avifBase64 = &amp;apos;AAAAIGZ0eXBhdmlmabc123&amp;apos;; // Base64 string starting with AVIF signature
⋮----
const heicBase64 = &amp;apos;AAAAIGZ0eXBoZWljabc123&amp;apos;; // Base64 string starting with HEIC signature
⋮----
const mp3Base64 = &amp;apos;//s=&amp;apos;; // Base64 string starting with MP3 signature
⋮----
0x33, // &amp;apos;ID3&amp;apos;
⋮----
0x00, // version
0x00, // flags
⋮----
0x0a, // size (10 bytes)
// 10 bytes of ID3 data
⋮----
// MP3 frame header
⋮----
0x33, // &amp;apos;ID3&amp;apos;
⋮----
0x00, // version
0x00, // flags
⋮----
0x0a, // size (10 bytes)
// 10 bytes of ID3 data
⋮----
// MP3 frame header
⋮----
const wavBase64 = &amp;apos;UklGRiQ=&amp;apos;; // Base64 string starting with WAV signature
⋮----
const oggBase64 = &amp;apos;T2dnUw&amp;apos;; // Base64 string starting with OGG signature
⋮----
const flacBase64 = &amp;apos;ZkxhQw&amp;apos;; // Base64 string starting with FLAC signature
⋮----
const aacBase64 = &amp;apos;QBUA&amp;apos;; // Base64 string starting with AAC signature
⋮----
const mp4Base64 = &amp;apos;ZnR5cA&amp;apos;; // Base64 string starting with MP4 signature
⋮----
const shortBytes = new Uint8Array([0x89, 0x50]); // Incomplete PNG signature
⋮----
const shortBytes = new Uint8Array([0x4f, 0x67]); // Incomplete OGG signature&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/detect-mimetype.ts&quot;&gt;import { convertBase64ToUint8Array } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
⋮----
const stripID3 = (data: Uint8Array | string) =&amp;gt;
⋮----
// The raw MP3 starts here
⋮----
function stripID3TagsIfPresent(data: Uint8Array | string): Uint8Array | string
⋮----
data[0] === 0x49 &amp;amp;&amp;amp; // &amp;apos;I&amp;apos;
data[1] === 0x44 &amp;amp;&amp;amp; // &amp;apos;D&amp;apos;
data[2] === 0x33); // &amp;apos;3&amp;apos;
⋮----
export function detectMimeType({
  data,
  signatures,
}: {
  data: Uint8Array | string;
  signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;
}): (typeof signatures)[number][&amp;apos;mimeType&amp;apos;] | undefined&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/get-potential-start-index.test.ts&quot;&gt;import { getPotentialStartIndex } from &amp;apos;./get-potential-start-index&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/get-potential-start-index.ts&quot;&gt;/**
 * Returns the index of the start of the searchedText in the text, or null if it
 * is not found.
 */
export function getPotentialStartIndex(
  text: string,
  searchedText: string,
): number | null
⋮----
// Return null immediately if searchedText is empty.
⋮----
// Check if the searchedText exists as a direct substring of text.
⋮----
// Otherwise, look for the largest suffix of &amp;quot;text&amp;quot; that matches
// a prefix of &amp;quot;searchedText&amp;quot;. We go from the end of text inward.&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/is-non-empty-object.ts&quot;&gt;export function isNonEmptyObject(
  object: Record&amp;lt;string, unknown&amp;gt; | undefined | null,
): object is Record&amp;lt;string, unknown&amp;gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/merge-objects.test.ts&quot;&gt;import { describe, it, expect } from &amp;apos;vitest&amp;apos;;
import { mergeObjects } from &amp;apos;./merge-objects&amp;apos;;
⋮----
// Original objects should not be modified
⋮----
// Both inputs undefined
⋮----
// One input undefined&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/merge-objects.ts&quot;&gt;/**
 * Deeply merges two objects together.
 * - Properties from the second object override those in the first object with the same key
 * - For nested objects, the merge is performed recursively (deep merge)
 * - Arrays are replaced, not merged
 * - Primitive values are replaced
 * - If both inputs are undefined, returns undefined
 * - If one input is undefined, returns the other
 *
 * @param target The target object to merge into
 * @param source The source object to merge from
 * @returns A new object with the merged properties, or undefined if both inputs are undefined
 */
export function mergeObjects&amp;lt;T extends object, U extends object&amp;gt;(
  target: T | undefined,
  source: U | undefined,
): (T &amp;amp; U) | T | U | undefined
⋮----
// If both inputs are undefined, return undefined
⋮----
// If target is undefined, return source
⋮----
// If source is undefined, return target
⋮----
// Create a new object to avoid mutating the inputs
⋮----
// Iterate through all keys in the source object
⋮----
// Skip if the source value is undefined
⋮----
// Get the target value if it exists
⋮----
// Check if both values are objects that can be deeply merged
⋮----
// If both values are mergeable objects, merge them recursively
⋮----
// For primitives, arrays, or when one value is not a mergeable object,
// simply override with the source value&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/merge-streams.test.ts&quot;&gt;import {
  convertArrayToReadableStream,
  convertReadableStreamToArray,
} from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
import { expect, it } from &amp;apos;vitest&amp;apos;;
import { mergeStreams } from &amp;apos;./merge-streams&amp;apos;;
⋮----
start(controller)
⋮----
async function pull()
⋮----
stream2Controller!.enqueue(&amp;apos;2d&amp;apos;); // comes later
⋮----
stream2Controller!.enqueue(&amp;apos;2e&amp;apos;); // comes later&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/merge-streams.ts&quot;&gt;/**
 * Merges two readable streams into a single readable stream, emitting values
 * from each stream as they become available.
 *
 * The first stream is prioritized over the second stream. If both streams have
 * values available, the first stream&amp;apos;s value is emitted first.
 *
 * @template VALUE1 - The type of values emitted by the first stream.
 * @template VALUE2 - The type of values emitted by the second stream.
 * @param {ReadableStream&amp;lt;VALUE1&amp;gt;} stream1 - The first readable stream.
 * @param {ReadableStream&amp;lt;VALUE2&amp;gt;} stream2 - The second readable stream.
 * @returns {ReadableStream&amp;lt;VALUE1 | VALUE2&amp;gt;} A new readable stream that emits values from both input streams.
 */
export function mergeStreams&amp;lt;VALUE1, VALUE2&amp;gt;(
  stream1: ReadableStream&amp;lt;VALUE1&amp;gt;,
  stream2: ReadableStream&amp;lt;VALUE2&amp;gt;,
): ReadableStream&amp;lt;VALUE1 | VALUE2&amp;gt;
⋮----
// only use when stream 2 is done:
async function readStream1(
    controller: ReadableStreamDefaultController&amp;lt;VALUE1 | VALUE2&amp;gt;,
)
// only use when stream 1 is done:
async function readStream2(
    controller: ReadableStreamDefaultController&amp;lt;VALUE1 | VALUE2&amp;gt;,
)
⋮----
async pull(controller)
⋮----
// stream 1 is done, we can only read from stream 2:
⋮----
// stream 2 is done, we can only read from stream 1:
⋮----
// pull the next value from the stream that was read last:
⋮----
// Note on Promise.race (prioritizing stream 1 over stream 2):
// If the iterable contains one or more non-promise values and/or an already settled promise,
// then Promise.race() will settle to the first of these values found in the iterable.
⋮----
// stream 1 is done, we can only read from stream 2:
⋮----
// stream 2 is done, we can only read from stream 1:
⋮----
cancel()&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/now.ts&quot;&gt;// Shim for performance.now() to support environments that don&amp;apos;t have it:
export function now(): number&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/prepare-outgoing-http-headers.test.ts&quot;&gt;import { prepareOutgoingHttpHeaders } from &amp;apos;./prepare-outgoing-http-headers&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/prepare-outgoing-http-headers.ts&quot;&gt;export function prepareOutgoingHttpHeaders(
  headers: HeadersInit | undefined,
  {
    contentType,
    dataStreamVersion,
  }: { contentType: string; dataStreamVersion?: &amp;apos;v1&amp;apos; | undefined },
)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/prepare-response-headers.test.ts&quot;&gt;import { prepareResponseHeaders } from &amp;apos;./prepare-response-headers&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/prepare-response-headers.ts&quot;&gt;export function prepareResponseHeaders(
  headers: HeadersInit | undefined,
  {
    contentType,
    dataStreamVersion,
  }: { contentType: string; dataStreamVersion?: &amp;apos;v1&amp;apos; | undefined },
)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/remove-text-after-last-whitespace.test.ts&quot;&gt;import { removeTextAfterLastWhitespace } from &amp;apos;./remove-text-after-last-whitespace&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/remove-text-after-last-whitespace.ts&quot;&gt;import { splitOnLastWhitespace } from &amp;apos;./split-on-last-whitespace&amp;apos;;
export function removeTextAfterLastWhitespace(text: string): string&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/simulate-readable-stream.test.ts&quot;&gt;import { simulateReadableStream } from &amp;apos;./simulate-readable-stream&amp;apos;;
import { convertReadableStreamToArray } from &amp;apos;@ai-sdk/provider-utils/test&amp;apos;;
⋮----
const mockDelay = (ms: number | null) =&amp;gt;
⋮----
await convertReadableStreamToArray(stream); // consume stream
⋮----
await convertReadableStreamToArray(stream); // consume stream
⋮----
await convertReadableStreamToArray(stream); // consume stream
⋮----
await convertReadableStreamToArray(stream); // consume stream&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/simulate-readable-stream.ts&quot;&gt;import { delay as delayFunction } from &amp;apos;@ai-sdk/provider-utils&amp;apos;;
/**
 * Creates a ReadableStream that emits the provided values with an optional delay between each value.
 *
 * @param options - The configuration options
 * @param options.chunks - Array of values to be emitted by the stream
 * @param options.initialDelayInMs - Optional initial delay in milliseconds before emitting the first value (default: 0). Can be set to `null` to skip the initial delay. The difference between `initialDelayInMs: null` and `initialDelayInMs: 0` is that `initialDelayInMs: null` will emit the values without any delay, while `initialDelayInMs: 0` will emit the values with a delay of 0 milliseconds.
 * @param options.chunkDelayInMs - Optional delay in milliseconds between emitting each value (default: 0). Can be set to `null` to skip the delay. The difference between `chunkDelayInMs: null` and `chunkDelayInMs: 0` is that `chunkDelayInMs: null` will emit the values without any delay, while `chunkDelayInMs: 0` will emit the values with a delay of 0 milliseconds.
 * @returns A ReadableStream that emits the provided values
 */
export function simulateReadableStream&amp;lt;T&amp;gt;({
  chunks,
  initialDelayInMs = 0,
  chunkDelayInMs = 0,
  _internal,
}: {
  chunks: T[];
  initialDelayInMs?: number | null;
  chunkDelayInMs?: number | null;
  _internal?: {
delay?: (ms: number | null)
⋮----
async pull(controller)&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/split-array.test.ts&quot;&gt;import { expect, it } from &amp;apos;vitest&amp;apos;;
import { splitArray } from &amp;apos;./split-array&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/split-array.ts&quot;&gt;/**
 * Splits an array into chunks of a specified size.
 *
 * @template T - The type of elements in the array.
 * @param {T[]} array - The array to split.
 * @param {number} chunkSize - The size of each chunk.
 * @returns {T[][]} - A new array containing the chunks.
 */
export function splitArray&amp;lt;T&amp;gt;(array: T[], chunkSize: number): T[][]&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/split-on-last-whitespace.test.ts&quot;&gt;import { splitOnLastWhitespace } from &amp;apos;./split-on-last-whitespace&amp;apos;;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/split-on-last-whitespace.ts&quot;&gt;/**
 * Splits the text on the last whitespace.
 *
 * Whitespace is defined as one or more whitespace characters,
 * e.g. space, tab, newline, etc.
 *
 * @param text - The text to split.
 * @returns The prefix, whitespace, and suffix. Undefined if there is no whitespace.
 */
export function splitOnLastWhitespace(text: string):
  | {
      prefix: string;
      whitespace: string;
      suffix: string;
    }
  | undefined {
  const match = text.match(lastWhitespaceRegexp);&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/value-of.ts&quot;&gt;// License for this File only:
//
// MIT License
//
// Copyright (c) Sindre Sorhus &amp;lt;sindresorhus@gmail.com&amp;gt; (https://sindresorhus.com)
// Copyright (c) Vercel, Inc. (https://vercel.com)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
// documentation files (the &amp;quot;Software&amp;quot;), to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions
// of the Software.
//
// THE SOFTWARE IS PROVIDED &amp;quot;AS IS&amp;quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
/**
Create a union of the given object&amp;apos;s values, and optionally specify which keys to get the values from.
Please upvote [this issue](https://github.com/microsoft/TypeScript/issues/31438) if you want to have this type as a built-in in TypeScript.
@example
```
// data.json
{
	&amp;apos;foo&amp;apos;: 1,
	&amp;apos;bar&amp;apos;: 2,
	&amp;apos;biz&amp;apos;: 3
}
// main.ts
import type {ValueOf} from &amp;apos;type-fest&amp;apos;;
import data = require(&amp;apos;./data.json&amp;apos;);
export function getData(name: string): ValueOf&amp;lt;typeof data&amp;gt; {
	return data[name];
}
export function onlyBar(name: string): ValueOf&amp;lt;typeof data, &amp;apos;bar&amp;apos;&amp;gt; {
	return data[name];
}
// file.ts
import {getData, onlyBar} from &amp;apos;./main&amp;apos;;
getData(&amp;apos;foo&amp;apos;);
//=&amp;gt; 1
onlyBar(&amp;apos;foo&amp;apos;);
//=&amp;gt; TypeError ...
onlyBar(&amp;apos;bar&amp;apos;);
//=&amp;gt; 2
```
* @see https://github.com/sindresorhus/type-fest/blob/main/source/value-of.d.ts
*/
export type ValueOf&amp;lt;
  ObjectType,
  ValueType extends keyof ObjectType = keyof ObjectType,
&amp;gt; = ObjectType[ValueType];&lt;/file&gt;&lt;file path=&quot;packages/ai/core/util/write-to-server-response.ts&quot;&gt;import { ServerResponse } from &amp;apos;node:http&amp;apos;;
/**
 * Writes the content of a stream to a server response.
 */
export function writeToServerResponse({
  response,
  status,
  statusText,
  headers,
  stream,
}: {
  response: ServerResponse;
  status?: number;
  statusText?: string;
  headers?: Record&amp;lt;string, string | number | string[]&amp;gt;;
  stream: ReadableStream&amp;lt;Uint8Array&amp;gt;;
}): void
⋮----
const read = async () =&amp;gt;&lt;/file&gt;&lt;file path=&quot;packages/ai/core/index.ts&quot;&gt;// re-exports:
⋮----
// directory exports:
⋮----
// telemetry types:
⋮----
// util exports:&lt;/file&gt;&lt;/files&gt;&lt;/repomix&gt;</file><file path=".hypermix/YieldRay/json-rpc-ts.xml">&lt;repomix&gt;This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).&lt;file_summary&gt;This section contains a summary of this file.&lt;purpose&gt;This file contains a packed representation of the entire repository&amp;apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.&lt;/purpose&gt;&lt;file_format&gt;The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file&lt;/file_format&gt;&lt;usage_guidelines&gt;- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.&lt;/usage_guidelines&gt;&lt;notes&gt;- Some files may have been excluded based on .gitignore rules and Repomix&amp;apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)&lt;/notes&gt;&lt;additional_info&gt;&lt;/additional_info&gt;&lt;/file_summary&gt;&lt;directory_structure&gt;src/
  dto/
    errors.test.ts
    errors.ts
    index.ts
    request.test.ts
    request.ts
    response.test.ts
    response.ts
  client.test.ts
  client.ts
  id.test.ts
  id.ts
  index.test.ts
  index.ts
  server.test.ts
  server.ts
  types.ts&lt;/directory_structure&gt;&lt;files&gt;This section contains the contents of the repository&amp;apos;s files.&lt;file path=&quot;src/dto/errors.test.ts&quot;&gt;import { assertEquals, assertInstanceOf } from &amp;apos;@std/assert&amp;apos;
import {
    isJSONRPCError,
    JSONRPCError,
    JSONRPCInternalError,
    JSONRPCInvalidParamsError,
    JSONRPCInvalidRequestError,
    JSONRPCMethodNotFoundError,
    JSONRPCParseError,
} from &amp;apos;./errors.ts&amp;apos;&lt;/file&gt;&lt;file path=&quot;src/dto/errors.ts&quot;&gt;import type { JSONRPCValue } from &amp;apos;../types.ts&amp;apos;
export interface JSONRPCErrorInterface {
    /**
     * A Number that indicates the error type that occurred.
     * This MUST be an integer.
     */
    code: number
    /**
     * A String providing a short description of the error.
     * The message SHOULD be limited to a concise single sentence.
     */
    message: string
    /**
     * A Primitive or Structured value that contains additional information about the error.
     * This may be omitted.
     * The value of this member is defined by the Server (e.g. detailed error information, nested errors etc.).
     */
    data?: JSONRPCValue
}
⋮----
/**
     * A Number that indicates the error type that occurred.
     * This MUST be an integer.
     */
⋮----
/**
     * A String providing a short description of the error.
     * The message SHOULD be limited to a concise single sentence.
     */
⋮----
/**
     * A Primitive or Structured value that contains additional information about the error.
     * This may be omitted.
     * The value of this member is defined by the Server (e.g. detailed error information, nested errors etc.).
     */
⋮----
export class JSONRPCError extends Error implements JSONRPCErrorInterface
⋮----
/**
     * The error codes from and including -32768 to -32000 are reserved for pre-defined errors. Any code within this range, but not defined explicitly below is reserved for future use. The error codes are nearly the same as those suggested for XML-RPC at the following url: http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php
     */
⋮----
public constructor(object: JSONRPCErrorInterface)
⋮----
/**
 * This ONLY check if `x` is `JSONRPCErrorInterface`
 *
 * Because it&amp;apos;a shared method between client and server, but `JSONRPCError` is server side only
 */
export function isJSONRPCError(x: unknown): x is JSONRPCErrorInterface
export class JSONRPCParseError extends JSONRPCError
⋮----
constructor(data?: JSONRPCValue)
⋮----
export class JSONRPCInvalidRequestError extends JSONRPCError
export class JSONRPCMethodNotFoundError extends JSONRPCError
export class JSONRPCInvalidParamsError extends JSONRPCError
export class JSONRPCInternalError extends JSONRPCError&lt;/file&gt;&lt;file path=&quot;src/dto/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;src/dto/request.test.ts&quot;&gt;import { assertEquals } from &amp;apos;@std/assert&amp;apos;
import {
    isJSONRPCRequest,
    JSONRPCNotification,
    JSONRPCRequest,
} from &amp;apos;./request.ts&amp;apos;
⋮----
/*json*/ `{&amp;quot;jsonrpc&amp;quot;:&amp;quot;2.0&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;foo&amp;quot;}`,
⋮----
/*json*/ `{&amp;quot;jsonrpc&amp;quot;:&amp;quot;2.0&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;foo&amp;quot;,&amp;quot;id&amp;quot;:1}`,&lt;/file&gt;&lt;file path=&quot;src/dto/request.ts&quot;&gt;import type { JSONRPCValue, WithOptionalJSONRPCVersion } from &amp;apos;../types.ts&amp;apos;
import { isJSONRPCID, type JSONRPCID } from &amp;apos;../id.ts&amp;apos;
/**
 * You should create this object via method from `JSONRPCClient`, it generate id for you.
 *
 * It&amp;apos;s less likely that you need to create this object manually.
 */
export class JSONRPCNotification
⋮----
/**
     * A String containing the name of the method to be invoked. Method names that begin with the word rpc followed by a period character (U+002E or ASCII 46) are reserved for rpc-internal methods and extensions and MUST NOT be used for anything else.
     */
⋮----
/**
     * A Structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted.
     */
⋮----
public constructor(
        object: WithOptionalJSONRPCVersion&amp;lt;JSONRPCNotification&amp;gt;,
)
public toString(): string
⋮----
/**
 * You should create this object via method from `JSONRPCClient`, it generate id for you.
 *
 * It&amp;apos;s less likely that you need to create this object manually.
 */
export class JSONRPCRequest extends JSONRPCNotification
⋮----
/**
     * An identifier established by the Client that MUST contain a String, Number, or NULL value if included. If it is not included it is assumed to be a notification. The value SHOULD normally not be Null and Numbers SHOULD NOT contain fractional parts
     */
⋮----
public constructor(object: WithOptionalJSONRPCVersion&amp;lt;JSONRPCRequest&amp;gt;)
public override toString(): string
⋮----
/**
 * WARN: this check if `x` is `JSONRPCNotification` or `JSONRPCRequest`
 *
 * To check if `x` is `JSONRPCRequest`, ONLY need to check `&amp;apos;id&amp;apos; in x`
 */
export function isJSONRPCRequest(
    x: unknown,
): x is JSONRPCNotification | JSONRPCRequest&lt;/file&gt;&lt;file path=&quot;src/dto/response.test.ts&quot;&gt;import { assertEquals } from &amp;apos;@std/assert&amp;apos;
import { isJSONRPCResponse } from &amp;apos;./response.ts&amp;apos;&lt;/file&gt;&lt;file path=&quot;src/dto/response.ts&quot;&gt;import type { JSONRPCValue, WithOptionalJSONRPCVersion } from &amp;apos;../types.ts&amp;apos;
import { isJSONRPCID, type JSONRPCID } from &amp;apos;../id.ts&amp;apos;
import { isJSONRPCError, type JSONRPCErrorInterface } from &amp;apos;./errors.ts&amp;apos;
export class JSONRPCSuccessResponse
⋮----
/**
     * The value of this member is determined by the method invoked on the Server.
     */
⋮----
public constructor(
        object: WithOptionalJSONRPCVersion&amp;lt;JSONRPCSuccessResponse&amp;gt;,
)
public toString(): string
⋮----
export class JSONRPCErrorResponse
⋮----
/**
     * If there was an error in detecting the id in the Request object (e.g. Parse error/Invalid Request), it MUST be Null.
     */
⋮----
public constructor(
        object: WithOptionalJSONRPCVersion&amp;lt;JSONRPCErrorResponse&amp;gt;,
)
⋮----
export type JSONRPCResponse = JSONRPCSuccessResponse | JSONRPCErrorResponse
export function isJSONRPCResponse(x: unknown): x is JSONRPCResponse&lt;/file&gt;&lt;file path=&quot;src/client.test.ts&quot;&gt;import { assertEquals, assertInstanceOf, assertObjectMatch } from &amp;apos;@std/assert&amp;apos;
import type { JSONRPCFulfilledResult } from &amp;apos;./types.ts&amp;apos;
import type { JSONRPCRequest } from &amp;apos;./dto/request.ts&amp;apos;
import { JSONRPCErrorResponse, JSONRPCSuccessResponse } from &amp;apos;./dto/response.ts&amp;apos;
import { JSONRPCClient, JSONRPCClientParseError } from &amp;apos;./client.ts&amp;apos;
import { JSONRPCError } from &amp;apos;./dto/errors.ts&amp;apos;
⋮----
// also need to run `aria2c --enable-rpc`
⋮----
// skip when no aria2c jsonrpc is running&lt;/file&gt;&lt;file path=&quot;src/client.ts&quot;&gt;import type { JSONRPCMethods, JSONRPCSettledResult } from &amp;apos;./types.ts&amp;apos;
import type {
    JSONRPCErrorResponse,
    JSONRPCSuccessResponse,
} from &amp;apos;./dto/response.ts&amp;apos;
import { JSONRPCNotification, JSONRPCRequest } from &amp;apos;./dto/request.ts&amp;apos;
import { isJSONRPCResponse, type JSONRPCResponse } from &amp;apos;./dto/response.ts&amp;apos;
import { JSONRPCError } from &amp;apos;./dto/errors.ts&amp;apos;
import {
    getIDFromGenerator,
    type IDGenerator,
    selfAddIdGenerator,
} from &amp;apos;./id.ts&amp;apos;
/**
 * Provide a external `requestForResponse` function to the constructor,
 * it should accept a `string` (json encoded from one or more json rpc request)
 * and your customized function should send this string to a json rpc server
 * for any response represented as `string`
 *
 * The constructor optionally accept a customized id generator, otherwise it use a
 * self added number
 *
 * To customize the request or response, you can extend `JSONRPCClient`.
 *
 * To customize request, overwrite `createRequest` and `createNotification` methods.
 *
 * To customize response, overwrite `request` `notify` and `batch` methods.
 */
export class JSONRPCClient&amp;lt;
Methods extends JSONRPCMethods = JSONRPCMethods,
⋮----
/**
     * MUST be an infinite iterator
     */
⋮----
/**
     * The external function to send the json string to any rpc server,
     * and fetch for response as string
     */
⋮----
/**
     * @param requestForResponse An external function to send the json string to any rpc server,
     * and fetch for response as string
     */
public constructor(
        requestForResponse: (input: string) =&amp;gt; string | Promise&amp;lt;string&amp;gt;,
        idGenerator?: IDGenerator,
)
public createRequest&amp;lt;T extends keyof Methods&amp;gt;(
        method: T extends string ? T : never,
        params: Parameters&amp;lt;Methods[T]&amp;gt;[0],
): JSONRPCRequest
public createNotification&amp;lt;T extends keyof Methods&amp;gt;(
        method: T extends string ? T : never,
        params: Parameters&amp;lt;Methods[T]&amp;gt;[0],
): JSONRPCNotification
/**
     * Send `JSONRPCRequest` to server, returns `JSONRPCValue` or throw `JSONRPCErrorInterface` (or `JSONRPCClientParseError`)
     */
public async request&amp;lt;T extends keyof Methods&amp;gt;(
        method: T extends string ? T : never,
        params: Parameters&amp;lt;Methods[T]&amp;gt;[0],
): Promise&amp;lt;ReturnType&amp;lt;Methods[T]&amp;gt;&amp;gt;
⋮----
// responded json string
⋮----
// parsed response
⋮----
// now jsonValue become JSONRPCResponse
⋮----
// according the spec, response id MUST as same as the request id
⋮----
// response.result is now JSONRPCValue
⋮----
/**
     * Send `JSONRPCNotification` to server, no returns,
     * only throws if your provided `processor` function throws
     */
public async notify&amp;lt;T extends keyof Methods&amp;gt;(
        method: T extends string ? T : never,
        params: Parameters&amp;lt;Methods[T]&amp;gt;[0],
): Promise&amp;lt;void&amp;gt;
/**
     * You should use the `createRequest()` or `createNotification()` method to
     * create the requests array. Response order is always matched by id.
     *
     * Throws `JSONRPCClientParseError` if server response cannot be parsed,
     * note that it does not throws for any `JSONRPCErrorResponse`, in this
     * case it will be a single object: `{ status: &amp;apos;rejected&amp;apos;, reason: {...} }`
     *
     * Usually it returns be like (same as the `Promise.allSettled()` method):
     * ```js
     * [
     *    { status: &amp;apos;fulfilled&amp;apos;, value: &amp;apos;...&amp;apos; },
     *    {
     *        status: &amp;apos;rejected&amp;apos;,
     *        reason: {
     *            code: -32601,
     *            message: &amp;apos;Method not found&amp;apos;,
     *        },
     *    },
     * ]
     * ```
     * @throws `JSONRPCError` - when server return single JSONRPCErrorResponse
     * @throws `JSONRPCClientParseError` - when server response cannot be parsed
     */
public async batch(
        ...requests: Array&amp;lt;JSONRPCRequest | JSONRPCNotification&amp;gt;
): Promise&amp;lt;JSONRPCSettledResult[]&amp;gt;
⋮----
// responded json string
⋮----
// all the requests are notification
// note that the server should return nothing, so we ignore any response
⋮----
// parsed response
⋮----
// if the batch rpc call itself fails to be recognized as an valid JSON or as an Array with at least one value,
// the response from the Server MUST be a single Response object.
⋮----
// requests contains request, so response must be an array
⋮----
const responses: JSONRPCSettledResult[] = [] // ordered
⋮----
// The Response objects being returned from a batch call MAY be returned in any order within the Array.
// The Client SHOULD match contexts between the set of Request objects and the resulting set of Response objects based on the id member within each Object.
⋮----
// no corresponding id, so the response will be JSONRPCErrorResponse
// find the first (not been scanned) error
⋮----
// this implementation expect that all the JSONRPCErrorResponse are ordered
⋮----
// update the error start index
⋮----
type JSONRPCAnyRequest =
    | JSONRPCNotification
    | JSONRPCRequest
    | Array&amp;lt;JSONRPCNotification | JSONRPCRequest&amp;gt;
/**
 * The client cannot parse the server response
 */
export class JSONRPCClientParseError extends Error
⋮----
constructor(message: string, request: JSONRPCAnyRequest)
⋮----
/**
 * Just wrap the JSON.parse function, with potential `JSONRPCClientParseError`
 */
function parseJSON(
    text: string,
    associatedRequest: JSONRPCAnyRequest,
): unknown&lt;/file&gt;&lt;file path=&quot;src/id.test.ts&quot;&gt;import { assertEquals } from &amp;apos;@std/assert&amp;apos;
import { getIDFromGenerator, isJSONRPCID } from &amp;apos;./id.ts&amp;apos;&lt;/file&gt;&lt;file path=&quot;src/id.ts&quot;&gt;export type JSONRPCID =
    | string
    | number // SHOULD NOT contain fractional parts
    | null // unknown id
⋮----
| number // SHOULD NOT contain fractional parts
| null // unknown id
⋮----
/**
 * This can be but not mean to javascript Generator
 * Just means a source of ID
 */
export type IDGenerator = Iterator&amp;lt;JSONRPCID&amp;gt; | (() =&amp;gt; JSONRPCID)
export function getIDFromGenerator(g: IDGenerator): JSONRPCID
export function isJSONRPCID(x: unknown): x is JSONRPCID&lt;/file&gt;&lt;file path=&quot;src/index.test.ts&quot;&gt;import { assertEquals, assertObjectMatch } from &amp;apos;@std/assert&amp;apos;
import { JSONRPCClient, JSONRPCServer } from &amp;apos;./index.ts&amp;apos;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----&lt;/file&gt;&lt;file path=&quot;src/index.ts&quot;&gt;&lt;/file&gt;&lt;file path=&quot;src/server.test.ts&quot;&gt;import { assertEquals, assertInstanceOf, assertObjectMatch } from &amp;apos;@std/assert&amp;apos;
import { JSONRPCServer } from &amp;apos;./server.ts&amp;apos;
import { isJSONRPCError } from &amp;apos;./dto/errors.ts&amp;apos;
⋮----
const trim = (str: string)
const trimStart = (str: string)
const trimEnd = (str: string)&lt;/file&gt;&lt;file path=&quot;src/server.ts&quot;&gt;import {
    isJSONRPCError,
    JSONRPCInternalError,
    JSONRPCInvalidRequestError,
    JSONRPCMethodNotFoundError,
    JSONRPCParseError,
} from &amp;apos;./dto/errors.ts&amp;apos;
import {
    isJSONRPCRequest,
    type JSONRPCNotification,
    type JSONRPCRequest,
} from &amp;apos;./dto/request.ts&amp;apos;
import {
    JSONRPCErrorResponse,
    type JSONRPCResponse,
    JSONRPCSuccessResponse,
} from &amp;apos;./dto/response.ts&amp;apos;
import { isJSONRPCID } from &amp;apos;./id.ts&amp;apos;
import type { JSONRPCMethods, JSONRPCValue } from &amp;apos;./types.ts&amp;apos;
/**
 * Provide a method set object to the constructor, it should contains
 * a record with it&amp;apos;s key is a string and value is a function
 * that handle the rpc calls.
 *
 * See `JSONRPCMethods` for how method in method set should be.
 *
 * Note: avoid using `this` in method!
 *
 * To customize how your server handle request, extend `JSONRPCServer` and
 * overwrite `getMethod` method, using this method, you can forward request
 * params to an existing method in `methods`
 */
export class JSONRPCServer&amp;lt;
Methods extends JSONRPCMethods = JSONRPCMethods,
⋮----
constructor()
constructor(methods: Methods)
constructor(methods?: Methods)
/**
     * Override this function, to customize the behavior
     * when method is not in `methods`.
     *
     * You can also use this method to handle dynamic
     * method name if you like, but make sure you manually
     * throw `JSONRPCMethodNotFoundError` when required
     */
// deno-lint-ignore no-unused-vars no-explicit-any
public methodNotFound(params: any): JSONRPCValue
/**
     * Use this to get method in `methods` by method name
     */
public getMethod&amp;lt;T extends keyof Methods&amp;gt;(
        method: T,
): Methods[T] | undefined
/**
     * Use this to replace or add more methods
     */
public setMethod&amp;lt;T extends keyof Methods&amp;gt;(
        method: T,
        fn: Methods[T],
): this
/**
     * Given any string as input, return response as json string
     * @noexcept
     */
public async handleRequest(input: string): Promise&amp;lt;string&amp;gt;
/**
     * Process request or batch request, return corresponding value
     * @returns Corresponding response object or array or some other thing
     * @noexcept
     */
private async processAnyJsonString(
        jsonString: string,
): Promise&amp;lt;undefined | JSONRPCResponse | JSONRPCResponse[]&amp;gt;
⋮----
// If the batch rpc call itself fails to be recognized as an valid JSON or as an Array with at least one value,
// the response from the Server MUST be a single Response object.
⋮----
// batch request
⋮----
// all the requests are notification
// just run each method in the event loop
// and immediately return nothing
⋮----
// If there are no Response objects contained within the Response array as it is to be sent to the client,
// the server MUST NOT return an empty Array and should return nothing at all.
⋮----
// there SHOULD NOT be any Response objects for notifications
⋮----
//? `batchReturnValue.length` MUST greater that 0
// if (batchReturnValue.length === 0) {
//     return
// }
⋮----
// single request
⋮----
/**
     * @param jsonValue the parse json value, can be any unknown javascript value
     * @returns `JSONRPCResponse` if is request, or `undefined` if is Notification
     * @noexcept
     */
private async processSingleJsonValue(
        jsonValue: unknown,
): Promise&amp;lt;JSONRPCResponse | undefined&amp;gt;
⋮----
// request or notification
⋮----
// jsonValue is not a valid Request object
⋮----
// make best efforts to return corresponding id
⋮----
/**
     * WARN: this process `JSONRPCNotification` or `JSONRPCRequest`
     * @noexcept
     */
private async processSingleRequest(
        request: JSONRPCNotification | JSONRPCRequest,
): Promise&amp;lt;JSONRPCResponse | undefined&amp;gt;
⋮----
// load method from `methods` or use the `methodNotFound()` function as fallback
⋮----
// request
⋮----
// note that here `result` can be anything, including undefined
// although undefined will make the property disappear in the json object
// we loosely accept it, so client should make additional check for this
⋮----
// method in method set should throw JSONRPCError
⋮----
// otherwise it will be treated as internal error
⋮----
// ignore as request is notification&lt;/file&gt;&lt;file path=&quot;src/types.ts&quot;&gt;import type { JSONRPCErrorInterface } from &amp;apos;./dto/errors.ts&amp;apos;
/**
 * This can be used for constrain of type that can be converted to json
 */
export type JSONRPCValue = PrimitiveValue | StructuredValue
export type PrimitiveValue = string | number | boolean | null
export type StructuredValue = ObjectValue | ArrayValue
export type ObjectValue = {
    [key: string]: JSONRPCValue
}
export type ArrayValue = Array&amp;lt;JSONRPCValue&amp;gt;
/**
 * Any function in method set will accept **single** `params` variable,
 * should otherwise *return/resolve* `JSONRPCValue`,
 * or must *throw/reject* `JSONRPCError`
 *
 * If method throws a value that is not `JSONRPCError`, it will be treated as `JSONRPCInternalError`
 *
 * Note that client is allowed to send no params, meaning that params can also be `undefined`,
 * server may also send result `undefined`
 */
export interface JSONRPCMethods {
    // deno-lint-ignore no-explicit-any
    [method: string]: JSONRPCMethod&amp;lt;any, any&amp;gt;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Represent any json rpc method, any detailed method should extend it
 */
export type JSONRPCMethod&amp;lt;Params, Result&amp;gt; = (
    params: Params,
) =&amp;gt; Promise&amp;lt;Result&amp;gt; | Result
export type WithOptionalJSONRPCVersion&amp;lt;T extends object&amp;gt; =
    &amp;amp; Omit&amp;lt;T, &amp;apos;jsonrpc&amp;apos;&amp;gt;
    &amp;amp; {
        jsonrpc?: &amp;apos;2.0&amp;apos;
    }
// client only
export interface JSONRPCFulfilledResult&amp;lt;T extends JSONRPCValue = JSONRPCValue&amp;gt;
    extends PromiseFulfilledResult&amp;lt;T&amp;gt; {
    value: T
}
export interface JSONRPCRejectedResult extends PromiseRejectedResult {
    reason: JSONRPCErrorInterface
}
export type JSONRPCSettledResult&amp;lt;T extends JSONRPCValue = JSONRPCValue&amp;gt; =
    | JSONRPCFulfilledResult&amp;lt;T&amp;gt;
    | JSONRPCRejectedResult&lt;/file&gt;&lt;/files&gt;&lt;/repomix&gt;</file><file path="examples/hypermix.config.jsonc">{
  &quot;silent&quot;: false,
  &quot;outputPath&quot;: &quot;.hypermix&quot;,
  &quot;mixes&quot;: [
    { &quot;remote&quot;: &quot;vercel/ai&quot;, &quot;include&quot;: [&quot;packages/ai/core/**/*.ts&quot;] },
    { &quot;remote&quot;: &quot;YieldRay/json-rpc-ts&quot;, &quot;include&quot;: [&quot;src/**/*.ts&quot;] },
    {
      &quot;remote&quot;: &quot;openai/openai-node&quot;,
      &quot;include&quot;: [&quot;src/examples/**/*.ts&quot;],
      &quot;output&quot;: &quot;openai/sdk-examples.xml&quot;
    },
    {
      &quot;remote&quot;: &quot;openai/openai-node&quot;,
      &quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;api.md&quot;, &quot;README.md&quot;],
      &quot;output&quot;: &quot;openai/sdk.xml&quot;
    },
    {
      &quot;remote&quot;: &quot;anthropics/anthropic-sdk-typescript&quot;,
      &quot;include&quot;: [&quot;examples/**/**&quot;],
      &quot;output&quot;: &quot;anthropics/sdk-examples.xml&quot;
    },
    {
      &quot;remote&quot;: &quot;anthropics/anthropic-sdk-typescript&quot;,
      &quot;include&quot;: [&quot;src/**/**&quot;, &quot;api.md&quot;, &quot;README.md&quot;],
      &quot;output&quot;: &quot;anthropics/sdk.xml&quot;
    },
    {
      &quot;remote&quot;: &quot;denoland/std&quot;,
      &quot;include&quot;: [&quot;testing/**/*&quot;],
      &quot;ignore&quot;: [&quot;testing/tests/**&quot;, &quot;testing/mocks/**&quot;],
      &quot;output&quot;: &quot;@std/testing.xml&quot;
    },
    // Mix the current codebase / just an example if you also wanted to keep a repomix.config around. Path is relative to your root.
    { &quot;repomixConfig&quot;: &quot;repomix.config.json&quot;, &quot;output&quot;: &quot;hypermix/context.xml&quot;, &quot;extraFlags&quot;: [&quot;--quiet&quot;] }
  ]
}</file><file path="examples/hypermix.config.ts">import { join } from &apos;@std/path&apos;</file><file path="scripts/build.ts">/**
 * @module build
 * @description Builds a deno project into native binaries for all platforms
 *
 * This script uses the Deno compile command to create platform-specific binaries
 * and then compresses them into archives for distribution.
 *
 * @flags
 * --bin-path, -o - Specifies the output directory for compiled binaries and archives.
 *                   Defaults to &apos;bin&apos; if not provided.
 *                   Example: deno run -A scripts/build.ts --bin-path=./dist
 *
 * --src-path - Specifies the entry point file to compile. If not provided, the script
 *              will auto-detect entry points by searching for mod.ts, main.ts, index.ts,
 *              or cli.ts in the current directory and src/ subdirectory.
 *              Example: deno run -A scripts/build.ts --src-path=custom/entry.ts
 *
 * --silent, -s - Suppresses all logging output. When enabled, the script runs silently
 *                except for errors that prevent execution.
 *                Example: deno run -A scripts/build.ts --silent
 */
import { join } from &apos;@std/path&apos;
import { toKebabCase } from &apos;@std/text&apos;
import { ensureDir, exists, expandGlob } from &apos;@std/fs&apos;
import { parseArgs } from &apos;@std/cli&apos;
import { parse } from &apos;@std/jsonc&apos;
// Global logger with silent mode support
⋮----
// Get app name from deno config
⋮----
// Neither file exists, use default
⋮----
// Extract short name by removing scope if it exists
⋮----
// Define targets for cross-compilation
⋮----
// Files to include in the distribution alongside the binary
⋮----
// Platform mappings for creating &quot;latest&quot; files
⋮----
interface CompileOptions {
  binPath: string
  srcPath?: string
  silent: boolean
}
async function findEntryPoint(): Promise&lt;string | null&gt;
⋮----
// Return relative path from cwd
⋮----
// Continue searching if glob fails
⋮----
async function compress(files: string[], outputPath: string, isTarGz = false)
⋮----
// For tar.gz, we need to use tar command
⋮----
// Create a temporary directory
⋮----
// Copy all files to temp directory
⋮----
// Create tar.gz
⋮----
// Clean up temp directory
⋮----
// Create zip archive
⋮----
async function compile(
⋮----
// Set global silent mode
⋮----
// Ensure the output directory exists
⋮----
// File doesn&apos;t exist, which is fine
⋮----
// Add icon only for Windows builds if it exists
⋮----
// Add entry point at the end
⋮----
// Handle zip archive
⋮----
// Compress the binary with additional files
⋮----
// Also create tar.gz for Homebrew
⋮----
// Create symlinks for the latest versions
⋮----
async function createLatestSymlinks(binPath: string)
⋮----
// Create a copy of the latest binary and archive (symlinks may not work well cross-platform)</file><file path="scripts/serve-docs.ts">import { serveDir } from &apos;@std/http&apos;
import { getAvailablePort } from &apos;@std/net&apos;</file><file path="scripts/tag.ts">/**
 * @module scripts/tag
 *
 * Automates the release tagging process following semantic versioning.
 * Handles validation, git operations, and ensures proper tag sequencing.
 *
 * Process steps:
 * 1. Validates tag format compliance with SemVer (must start with &apos;v&apos;)
 * 2. Checks working directory status and commits any changes
 * 3. Syncs with remote main branch using pull --rebase
 * 4. Pushes local commits to remote
 * 5. Fetches existing tags and verifies new tag is a valid increment
 * 6. Creates tag locally (removing existing if needed)
 * 7. Pushes tag to remote (removing remote tag if it exists)
 *
 * @example
 * ```bash
 * deno task tag &quot;v1.2.3&quot;
 * ```
 */
import { parseArgs } from &apos;@std/cli&apos;
⋮----
// Types
type CommandResult = {
  stdout: string
  stderr: string
  success: boolean
}
type TagContext = {
  tag: string
  latestTag?: string | undefined
}
// Error handling
class TagError extends Error
⋮----
constructor(message: string)
⋮----
// Git operations encapsulated in a client class
class GitClient
⋮----
async execute(args: string[]): Promise&lt;CommandResult&gt;
// Repository status operations
async getStatus(): Promise&lt;string&gt;
async stageChanges(): Promise&lt;void&gt;
async commitChanges(message: string): Promise&lt;void&gt;
// Remote operations
async syncWithRemote(): Promise&lt;void&gt;
async pushToMain(): Promise&lt;boolean&gt;
// Tag operations
async fetchTags(): Promise&lt;void&gt;
async getLatestTag(): Promise&lt;string | undefined&gt;
async checkLocalTag(tag: string): Promise&lt;boolean&gt;
async checkRemoteTag(tag: string): Promise&lt;boolean&gt;
async deleteLocalTag(tag: string): Promise&lt;void&gt;
async deleteRemoteTag(tag: string): Promise&lt;boolean&gt;
async createTag(tag: string): Promise&lt;void&gt;
async pushTag(tag: string): Promise&lt;void&gt;
⋮----
// Validation helper functions
const validateTagFormat = (tag: string): void =&gt;
const validateSemVerIncrement = (
const isValidCommitMessage = (message: string): boolean =&gt;
// User interface helpers
const promptUser = async (
  promptText: string,
  defaultValue?: string,
): Promise&lt;string&gt; =&gt;
⋮----
// Workflow steps
const processWorkingDirectory = async (
  git: GitClient,
  tagValue: string,
): Promise&lt;boolean&gt; =&gt;
const syncWithRemoteMain = async (git: GitClient): Promise&lt;void&gt; =&gt;
const pushChangesToRemote = async (git: GitClient): Promise&lt;void&gt; =&gt;
⋮----
// Always push to ensure we&apos;re in sync
⋮----
const fetchAndValidateExistingTags = async (
  git: GitClient,
  tag: string,
): Promise&lt;TagContext&gt; =&gt;
const createAndPushTag = async (git: GitClient, tag: string): Promise&lt;void&gt; =&gt;
⋮----
// Handle local tag
⋮----
// Handle remote tag
⋮----
// Main script execution pipeline
const createTag = async (tagValue: string): Promise&lt;void&gt; =&gt;
⋮----
// Process workflow in sequence
⋮----
// Script entry point
const main = async (): Promise&lt;void&gt; =&gt;
⋮----
// Parse command line arguments</file><file path="src/add-tasks.ts">import { exists } from &apos;@std/fs&apos;
import { basename, join } from &apos;@std/path&apos;
import { applyEdits, modify } from &apos;jsonc-parser&apos;
import {
  APP_NAME,
  FORMATTING_OPTIONS,
  MAKEFILE_SECTION_MARKER,
  MAKEFILE_TASKS,
  NX_EXECUTOR,
  VSCODE_TASK_DEFAULTS,
} from &apos;./constants.ts&apos;
⋮----
type ProjectConfigFile = typeof PROJECT_CONFIG_FILES[number]
type TaskDefinition = Record&lt;string, string&gt;
⋮----
async function detectProjectConfigFile(
  repoRoot: string,
): Promise&lt;ProjectConfigFile | null&gt;
async function updateJsonScript(
  file: string,
  section: &apos;tasks&apos; | &apos;scripts&apos;,
  name: string,
  cmd?: string,
): Promise&lt;boolean&gt;
function getTaskDefinition(
  configFileName: ProjectConfigFile,
  hypermixConfigPath?: string,
): TaskDefinition
async function addTasksToProjectConfig(
  repoRoot: string,
  configFileName: ProjectConfigFile,
  task: TaskDefinition,
  hypermixConfigPath?: string,
): Promise&lt;boolean&gt;
⋮----
const createTask = (label: string, command: string) =&gt; (
⋮----
async function removeTasksFromProjectConfig(
  repoRoot: string,
  configFileName: ProjectConfigFile,
  hypermixConfigPath?: string,
): Promise&lt;boolean&gt;</file><file path="src/constants.ts">import { join } from &apos;@std/path&apos;</file><file path="src/load-config.ts">import { extname } from &apos;@std/path&apos;
import { parse } from &apos;@std/jsonc&apos;
import type { HypermixConfig, RepomixConfig } from &apos;./types.ts&apos;
import { CONFIG_NAMES } from &apos;./constants.ts&apos;
async function loadConfig(configPath?: string): Promise&lt;HypermixConfig&gt;
⋮----
// File doesn&apos;t exist, continue to next
⋮----
// Handle both array of RepomixConfig and HypermixConfig object</file><file path="src/mod.ts">/**
 * AI Context Builder
 *
 * Builds XML context files for AI tools using repomix.
 * Fetches code from remote repositories or local codebase.
 *
 * Command-line options:
 * - --output-path, -o: Override the default output directory for all context files
 *   Example: `deno run -A scripts/build-context.ts --output-path ./custom/path`
 * - --silent, -s: Suppress all output except errors
 *
 * Config entries can be defined in the configs array with these properties:
 * - remote: GitHub repository in &apos;owner/repo&apos; format (https://github.com/ prefix is optional)
 * - include: Array of glob patterns for files to include
 * - ignore: Array of glob patterns for files to ignore
 * - output: Custom output path relative to OUTPUT_PATH
 * - config: Path to an existing repomix.config.json file
 * - extraFlags: Additional command-line flags for repomix
 *
 * The script automatically updates .gitignore, .cursorignore, and .cursorignoreindex
 * to ensure proper handling of the generated context files.
 */
import { parseArgs } from &apos;@std/cli/parse-args&apos;
import { basename, dirname, extname, join, parse, relative } from &apos;@std/path&apos;
import { Spinner, type SpinnerOptions } from &apos;@std/cli/unstable-spinner&apos;
import { bold, brightYellow, dim, green, red, yellow } from &apos;@std/fmt/colors&apos;
import { toKebabCase } from &apos;@std/text&apos;
import { dedent } from &apos;@std/text/unstable-dedent&apos;
import { ensureDir, exists } from &apos;@std/fs&apos;
import { countTokens } from &apos;gpt-tokenizer/model/gpt-4o&apos;
import { toTransformStream } from &apos;@std/streams/to-transform-stream&apos;
import { parse as parseJsonc } from &apos;jsonc-parser&apos;
import { loadConfig } from &apos;./load-config.ts&apos;
import { BOOLEAN_FLAGS, DEFAULT_FLAGS, DEFAULT_PATH } from &apos;./constants.ts&apos;
import type { HypermixConfig, RepomixConfig } from &apos;./types.ts&apos;
⋮----
// IMPORTANT: Always use the logger instead of console.log/warn/error directly
// This ensures the --silent flag works properly throughout the application
const createLogger = (silent: boolean) =&gt; (
const createFileHelpers = () =&gt;
⋮----
const kebabFilename = (path: string) =&gt;
const outputFromGithub = (url: string) =&gt;
⋮----
const buildRepomixArgs = (
  config: RepomixConfig,
  outputPath: string,
  helpers: ReturnType&lt;typeof createFileHelpers&gt;,
) =&gt;
⋮----
// Only pass repomix config if explicitly specified in the config object
⋮----
// Only add output path if no repomix config is specified
// When repomix config is used, it should determine its own output path
⋮----
// For repomix configs, we need to read the config to get the actual output path
// For now, we&apos;ll use a placeholder and handle this in runRepomix
⋮----
const runRepomix = async (
  config: RepomixConfig,
  outputPath: string,
  helpers: ReturnType&lt;typeof createFileHelpers&gt;,
) =&gt;
⋮----
// Validate repomix config file exists if specified
⋮----
// Validate extraFlags to ensure they exist in BOOLEAN_FLAGS
⋮----
// If using repomix config, read the actual output path from the config file
⋮----
// If no output path is specified in the repomix config, default to &apos;codebase.xml&apos;
⋮----
// Continue with placeholder path
⋮----
// Ensure output directory exists
⋮----
// Verify the output file was actually created at the correct path
⋮----
const modifyIgnoreFile = async (
  filePath: string,
  pattern: string,
  shouldExist: boolean,
  contentToAdd: string,
  fileType: &apos;gitignore&apos; | &apos;cursorignoreindex&apos; | &apos;cursorignore&apos;,
) =&gt;
⋮----
const getFileMessage = (action: string)
⋮----
const updateIgnoreFiles = async (outputPath: string) =&gt;
⋮----
// Normalize to forward slashes for glob patterns (ignore files expect Unix-style paths)
// these dot-files will never have Windows paths, so we can safely replace all backslashes with forward slashes momentarily
⋮----
const countTokensInFiles = async (
  filePaths: string[],
): Promise&lt;Record&lt;string, number&gt; &amp;
async function main()
⋮----
// Filter to only include files that actually exist
⋮----
const getTokenColor = (tokens: number): (str: string) =&gt; string =&gt;</file><file path="src/types.ts">import type { BOOLEAN_FLAGS } from &apos;./constants.ts&apos;
type RepomixConfig = {
  remote?: string
  include?: string[]
  ignore?: string[]
  output?: string
  config?: string
  repomixConfig?: string
  extraFlags?: typeof BOOLEAN_FLAGS[number][]
}
type HypermixConfig = {
  mixes: RepomixConfig[]
  silent?: boolean
  outputPath?: string
}</file><file path="test/add-tasks.test.ts">import {
  assert,
  assertEquals,
  assertExists,
  createTempDir,
  createTempFile,
  join,
} from &apos;./test-utils.ts&apos;
import {
  addTasksToProjectConfig,
  detectProjectConfigFile,
  getTaskDefinition,
  ProjectConfigFile,
} from &apos;../src/add-tasks.ts&apos;
import { APP_NAME } from &apos;../src/constants.ts&apos;
⋮----
// Create a package.json file
⋮----
// Should detect package.json
⋮----
// Create a deno.json file and verify it&apos;s detected too
⋮----
// Test assumes the detection order is as defined in PROJECT_CONFIG_FILES
// It should find the first one which is package.json
⋮----
// Empty directory, no config files
⋮----
// Default task without config path
⋮----
// Task with config path for deno.json includes $@
⋮----
// Deno tasks include $@ parameter
⋮----
// Create a package.json file
⋮----
// Add task
⋮----
// Verify task was added
⋮----
// Check file content
⋮----
// Create a deno.json file
⋮----
// Add task
⋮----
// Verify task was added
⋮----
// Check file content
⋮----
// Create a Makefile
⋮----
// Add task
⋮----
// Verify task was added
⋮----
// Check file content
⋮----
// Create a tasks.json file
⋮----
// Add task
⋮----
// Verify task was added
⋮----
// Check file content
⋮----
// Try to add to a non-existent file
⋮----
// Should return false for non-existent files</file><file path="test/cli-args.test.ts">import {
  assert,
  assertEquals,
  createTempDir,
  createTempFile,
  join,
  mockConsole,
} from &apos;./test-utils.ts&apos;
import { parseArgs } from &apos;@std/cli/parse-args&apos;
import { DEFAULT_PATH } from &apos;../src/constants.ts&apos;
// Test parseArgs directly as we can&apos;t easily access the private main function
⋮----
// Test using the short alias
⋮----
// Test using the camelCase alias
⋮----
// Test short form
⋮----
// Test silent mode suppresses output
⋮----
// Create a simple logger that respects silent flag
const createLogger = (silent: boolean) =&gt; (
// Test with silent = false first
⋮----
// Test with silent = true
⋮----
// Verify logs didn&apos;t increase (silent mode blocks console.log)
⋮----
// Verify warnings and errors still increased
⋮----
// Test path resolution
⋮----
// In the actual code, it would fall back to DEFAULT_PATH
⋮----
// Test handling multiple arguments</file><file path="test/error-recovery.test.ts">import {
  assert,
  assertEquals,
  createTempDir,
  join,
  mockConsole,
} from &apos;./test-utils.ts&apos;
import type { RepomixConfig } from &apos;../src/types.ts&apos;
// Simplified version of runRepomix for testing
async function runRepomix(
  config: RepomixConfig,
  outputPath: string,
  shouldFail = false,
): Promise&lt;
⋮----
// Simulate failure based on shouldFail flag
⋮----
// Simplified processor that runs multiple mixes and handles failures
async function processConfigs(
  configs: RepomixConfig[],
  outputPath: string,
  failingIndexes: number[] = [],
): Promise&lt;
⋮----
// Set up to fail the 2nd and 4th configs
⋮----
// Verify successful configs
⋮----
// Verify failed configs
⋮----
// Verify warnings were logged for failures
⋮----
// Set up to fail the middle config
⋮----
// Verify first and last configs were processed
⋮----
// Verify middle config failed
⋮----
// No failing indexes
⋮----
// Verify all configs succeeded
⋮----
// Verify no failures
⋮----
// All configs fail
⋮----
// Verify no configs succeeded
⋮----
// Verify all configs failed
⋮----
// Verify warnings were logged for all failures</file><file path="test/github-url.test.ts">import { assertEquals, createTempDir, join } from &apos;./test-utils.ts&apos;
import type { RepomixConfig } from &apos;../src/types.ts&apos;
// Simplified function for normalizing GitHub URLs
function normalizeGitHubUrl(url?: string): string | undefined
// Simplified function for extracting repository name from URL
function extractRepoName(url?: string): string
// Simplified version of output path generation from GitHub URL
function outputFromGithub(url?: string): string
⋮----
// Test multiple URL formats using RepomixConfig type</file><file path="test/ignore-files.test.ts">import {
  assert,
  assertEquals,
  createTempDir,
  createTempFile,
  join,
} from &apos;./test-utils.ts&apos;
// Import the private function directly for testing
// In a real implementation, we might expose these for testing
const importModFunctions = async () =&gt;
⋮----
// @ts-ignore accessing private function
⋮----
// @ts-ignore accessing private function
⋮----
// Simplified version for testing without accessing private functions
async function modifyIgnoreFile(
  filePath: string,
  pattern: string,
  shouldExist: boolean,
  contentToAdd: string,
): Promise&lt;void&gt;
⋮----
// File doesn&apos;t exist
⋮----
async function updateIgnoreFiles(outputPath: string): Promise&lt;void&gt;
⋮----
// File doesn&apos;t exist yet
⋮----
// Verify file was created with correct content
⋮----
// Verify pattern was added
⋮----
// Verify pattern was not duplicated
⋮----
// Count occurrences of the pattern
⋮----
// Create working directory with empty ignore files
⋮----
// Mock Deno.cwd to return our temp directory
⋮----
// Verify patterns were added to all files</file><file path="test/load-config.test.ts">import {
  assertEquals,
  assertRejects,
  createTempDir,
  createTempFile,
  join,
} from &apos;./test-utils.ts&apos;
import { loadConfig } from &apos;../src/load-config.ts&apos;
import type { HypermixConfig } from &apos;../src/types.ts&apos;
⋮----
// Test with explicit path (not auto-discovery)
⋮----
// Test with explicit path (not auto-discovery)
⋮----
// Create a fake types.ts for import
⋮----
// This test will be skipped in CI because it requires dynamic import
// which is hard to mock for TS files. In local development, you can
// test this manually.
⋮----
// Force Deno.cwd() to return our temp directory path
⋮----
// This may fail in CI due to dynamic import limitations
⋮----
// This is expected in CI environment
⋮----
// Force Deno.cwd() to return our empty temp directory path
⋮----
// Create a config file in the actual working directory for auto-discovery
⋮----
// Create the config file in current directory
⋮----
// Test auto-discovery (no path provided)
⋮----
// Clean up the config file
⋮----
// File might not exist, ignore error</file><file path="test/output-file-verification.test.ts">import {
  assert,
  assertEquals,
  createTempDir,
  createTempFile,
  join,
  mockConsole,
} from &apos;./test-utils.ts&apos;
import type { RepomixConfig } from &apos;../src/types.ts&apos;
// Function to filter only existing output files
async function filterExistingOutputFiles(
  results: Array&lt;{ repoName: string; outputPath: string }&gt;,
): Promise&lt;Array&lt;
// Mock token counting function (simplified)
function countTokens(
  files: string[],
): Promise&lt;Record&lt;string, number&gt; &amp;
⋮----
// Mock token count based on file name length
⋮----
// Create some output files
⋮----
// file2 intentionally not created
⋮----
// Mock console.warn to capture warnings
⋮----
// Should only include the existing file
⋮----
// Should warn about the missing file
⋮----
// Create some output paths but don&apos;t create the files
⋮----
// Mock console.warn to capture warnings
⋮----
// Should have no files
⋮----
// Should warn about both missing files
⋮----
// Create all output files
⋮----
// Mock console.warn to capture warnings
⋮----
// Should include all files
⋮----
// Should not warn
⋮----
// Create some output files
⋮----
// Count tokens
⋮----
// Should have token counts for both files
assertEquals(Object.keys(tokensResult).length, 3) // 2 files + totalTokens
assertEquals(tokensResult.short, 5000) // &quot;short&quot; length is 5
assertEquals(tokensResult.longerfilename, 14000) // &quot;longerfilename&quot; length is 14
assertEquals(tokensResult.totalTokens, 19000) // 5000 + 14000
⋮----
// Create only one of the files
⋮----
// First filter to ensure only existing files are counted
⋮----
// Count tokens
⋮----
// Should only count the existing file
assertEquals(Object.keys(tokensResult).length, 2) // 1 file + totalTokens
assertEquals(tokensResult.exists, 6000) // &quot;exists&quot; length is 6</file><file path="test/repomix-command.test.ts">import {
  assert,
  assertEquals,
  assertExists,
  createTempDir,
  createTempFile,
  exists,
  join,
  mockDenoCommand,
} from &apos;./test-utils.ts&apos;
import { DEFAULT_FLAGS, DEFAULT_PATH } from &apos;../src/constants.ts&apos;
import type { RepomixConfig } from &apos;../src/types.ts&apos;
import { BOOLEAN_FLAGS } from &apos;../src/constants.ts&apos;
// Since mod.ts doesn&apos;t export these functions, we&apos;ll need to mock them for testing
// and directly test the core functionality using our own implementation
// based on the source code
const createFileHelpers = () =&gt;
⋮----
const kebabFilename = (path: string)
const outputFromGithub = (url: string) =&gt;
⋮----
const buildRepomixArgs = (
  config: RepomixConfig,
  outputPath: string,
  helpers: ReturnType&lt;typeof createFileHelpers&gt;,
) =&gt;
⋮----
// Only pass repomix config if explicitly specified in the config object
⋮----
// Simpler version of runRepomix for testing
const runRepomix = async (
  config: RepomixConfig,
  outputPath: string,
  helpers: ReturnType&lt;typeof createFileHelpers&gt;,
) =&gt;
⋮----
// Validate repomix config file exists if specified
⋮----
// Validate extraFlags to ensure they exist in BOOLEAN_FLAGS
⋮----
// In the real implementation, it would run the command and check file exists
⋮----
// Verify all default flags are included
⋮----
// Should not have --remote flag
⋮----
// But should still have include patterns
⋮----
// When repomix config is provided, no output path should be added
⋮----
// Create a fake output file that runRepomix will check exists
⋮----
// Run the test
⋮----
// Verify result
⋮----
// Mock console.error to capture the error message
⋮----
// Create a type that allows an invalid flag for testing
type TestConfig = Omit&lt;RepomixConfig, &apos;extraFlags&apos;&gt; &amp; {
      extraFlags?: string[]
    }
⋮----
// Mock console.error to capture the error message
⋮----
// Cast as RepomixConfig to pass to our function</file><file path="test/repomix-config-resolution.test.ts">import {
  assert,
  assertEquals,
  createTempDir,
  createTempFile,
  join,
} from &apos;./test-utils.ts&apos;
import type { RepomixConfig } from &apos;../src/types.ts&apos;
// Create a simpler version of buildRepomixArgs for testing
function buildRepomixArgs(
  config: RepomixConfig,
  outputPath: string,
)
⋮----
// Only pass repomix config if explicitly specified in the config object
⋮----
// Default flags would be added here in the real implementation
⋮----
// When repomix config is provided, we don&apos;t add the output flag
// The real implementation would read the output path from the config
⋮----
// Read the output path from a repomix config file
async function readOutputPathFromConfig(
  configPath: string,
): Promise&lt;string | null&gt;
⋮----
// Verify config path is passed
⋮----
// Verify output flag is not included
⋮----
// Verify hasRepomixConfig flag is set
⋮----
// Verify config flag is not included
⋮----
// Verify output flag is included
⋮----
// Verify hasRepomixConfig flag is not set
⋮----
// Create a repomix config file
⋮----
// Read the output path
⋮----
// Verify the output path was correctly read
⋮----
// Create a repomix config file without output section
⋮----
// Read the output path
⋮----
// Verify the output path is null
⋮----
// Create an invalid JSON file
⋮----
// Read the output path
⋮----
// Verify the output path is null
⋮----
// Try to read a non-existent file
⋮----
// Read the output path
⋮----
// Verify the output path is null</file><file path="test/test-utils.ts">import { assert, assertEquals, assertExists, assertRejects } from &apos;@std/assert&apos;
import { spy } from &apos;@std/testing/mock&apos;
import { join } from &apos;@std/path&apos;
import { exists } from &apos;@std/fs&apos;
⋮----
export const createTempDir = async () =&gt;
export const createTempFile = async (path: string, content: string) =&gt;
export const mockDenoCommand = () =&gt;
⋮----
// @ts-ignore overriding built-in
⋮----
constructor(command: string, options:
output()
⋮----
// @ts-ignore restoring built-in
⋮----
export const mockConsole = () =&gt;</file><file path="test/token-counting.test.ts">import {
  assert,
  assertEquals,
  createTempDir,
  createTempFile,
  join,
} from &apos;./test-utils.ts&apos;
// Mock approach for token counting (avoiding direct mocking of external modules)
// This simplifies our tests without having to mock countTokens
const simplifiedTokenCount = (text: string) =&gt;
⋮----
// Simple implementation - 1 token per character for testing purposes
⋮----
// For the actual tests, we&apos;ll implement simplified versions of the functions
// rather than trying to access the private ones from mod.ts
⋮----
async function countTokensInFiles(
  filePaths: string[],
): Promise&lt;Record&lt;string, number&gt; &amp;
⋮----
// Create test files with known content
⋮----
// Count tokens
⋮----
// With our simplified implementation, tokens should equal characters
⋮----
// Create a large test file
⋮----
// Process the file in chunks
⋮----
// Verify chunks were created
⋮----
// Test for large file handling
⋮----
// Create a large test file
⋮----
// Count tokens in large file
⋮----
// Verify correct token count</file><file path=".cursorignore"># Include AI context files (auto-generated by the build-context script)
!.hypermix/**/*.xml</file><file path=".cursorignoreindex"># AI context files
.hypermix/**/*.xml</file><file path="deno.json">{
  &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/denoland/deno/refs/heads/main/cli/schemas/config-file.v1.json&quot;,
  &quot;name&quot;: &quot;@zackiles/hypermix&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;description&quot;: &quot;Real-time, token-aware, intelligent repomixing of all your codebase and dependencies. Auto-integrations for Cursor, Claude, and Windsurf. Repoxmix for power-users and agentic engineering.&quot;,
  &quot;author&quot;: &quot;Zachary Iles&lt;zack.iles@gmail.com&gt;&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/zackiles/hypermix&quot;
  },
  &quot;tasks&quot;: {
    &quot;dev&quot;: &quot;deno run -A src/mod.ts --config examples/hypermix.config.ts&quot;,
    &quot;check&quot;: &quot;deno lint &amp;&amp; deno check src/main.ts&quot;,
    &quot;tag&quot;: &quot;deno run -A scripts/tag.ts&quot;,
    &quot;serve-docs&quot;: &quot;deno run -A scripts/serve-docs.ts&quot;,
    &quot;build&quot;: &quot;deno run -A scripts/build.ts&quot;,
    &quot;build:docs&quot;: &quot;deno doc --html --name=Hypermix --output=./docs/hypermix src/**/*.ts&quot;
  },
  &quot;unstable&quot;: [
    &quot;net&quot;,
    &quot;http&quot;,
    &quot;fs&quot;
  ],
  &quot;imports&quot;: {
    &quot;@ai-sdk/anthropic&quot;: &quot;npm:@ai-sdk/anthropic@^1.2.11&quot;,
    &quot;@ai-sdk/google-vertex&quot;: &quot;npm:@ai-sdk/google-vertex@^2.2.22&quot;,
    &quot;@ai-sdk/openai&quot;: &quot;npm:@ai-sdk/openai@^1.3.22&quot;,
    &quot;@ai-sdk/valibot&quot;: &quot;npm:@ai-sdk/valibot@^0.1.27&quot;,
    &quot;@olli/kvdex&quot;: &quot;jsr:@olli/kvdex@3&quot;,
    &quot;@std/async&quot;: &quot;jsr:@std/async@^1.0.13&quot;,
    &quot;@std/dotenv&quot;: &quot;jsr:@std/dotenv@^0.225.3&quot;,
    &quot;@std/fmt&quot;: &quot;jsr:@std/fmt@^1.0.8&quot;,
    &quot;@std/fs&quot;: &quot;jsr:@std/fs@1&quot;,
    &quot;@std/http&quot;: &quot;jsr:@std/http@1&quot;,
    &quot;@std/jsonc&quot;: &quot;jsr:@std/jsonc@1&quot;,
    &quot;@std/net&quot;: &quot;jsr:@std/net@1&quot;,
    &quot;@std/path&quot;: &quot;jsr:@std/path@1&quot;,
    &quot;@std/assert&quot;: &quot;jsr:@std/assert@1&quot;,
    &quot;@std/cli&quot;: &quot;jsr:@std/cli@1&quot;,
    &quot;@qnighy/dedent&quot;: &quot;jsr:@qnighy/dedent@^0.1.2&quot;,
    &quot;@std/semver&quot;: &quot;jsr:@std/semver@1&quot;,
    &quot;@std/streams&quot;: &quot;jsr:@std/streams@1&quot;,
    &quot;@std/testing&quot;: &quot;jsr:@std/testing@1&quot;,
    &quot;@std/text&quot;: &quot;jsr:@std/text@1&quot;,
    &quot;@valibot/valibot&quot;: &quot;jsr:@valibot/valibot@^1.1.0&quot;,
    &quot;@yieldray/json-rpc-ts&quot;: &quot;jsr:@yieldray/json-rpc-ts@^0.2.1&quot;,
    &quot;ai&quot;: &quot;npm:ai@^4.3.15&quot;,
    &quot;gcp-metadata&quot;: &quot;npm:gcp-metadata@6.1.0&quot;,
    &quot;@luna-ai/core/runtime&quot;:&quot;./src/runtime.ts&quot;,
    &quot;@luna-ai/core/storage&quot;:&quot;./src/runtime.ts&quot;,
    &quot;@luna-ai/core/session&quot;:&quot;./src/runtime.ts&quot;,
    &quot;@luna-ai/core/logger&quot;:&quot;./src/runtime.ts&quot;,
    &quot;@luna-ai/core/config&quot;:&quot;./src/runtime.ts&quot;,
    &quot;@luna-ai/core/tools&quot;:&quot;./src/tools/index.ts&quot;,
    &quot;@luna-ai/tool-ls&quot;:&quot;./packages/tool-ls/index.ts&quot;,
    &quot;@luna-ai/tool-grep&quot;:&quot;./packages/tool-grep/index.ts&quot;,
    &quot;gpt-tokenizer&quot;: &quot;npm:gpt-tokenizer@^2.9.0&quot;,
    &quot;jsonc-parser&quot;: &quot;npm:jsonc-parser@^3.3.1&quot;
  },
  &quot;lint&quot;: {
    &quot;include&quot;: [
      &quot;deno.json&quot;,
      &quot;plugins/**/*.ts&quot;,
      &quot;src/**/*.ts&quot;,
      &quot;scripts/**/*.ts&quot;,
      &quot;test/**/*.ts&quot;,
      &quot;*.md&quot;
    ]
  },
  &quot;fmt&quot;: {
    &quot;lineWidth&quot;: 80,
    &quot;useTabs&quot;: false,
    &quot;indentWidth&quot;: 2,
    &quot;singleQuote&quot;: true,
    &quot;proseWrap&quot;: &quot;preserve&quot;,
    &quot;semiColons&quot;: false,
    &quot;include&quot;: [
      &quot;deno.json&quot;,
      &quot;test/**/*.ts&quot;,
      &quot;src/**/*.ts&quot;,
      &quot;scripts/**/*.ts&quot;,
      &quot;*.md&quot;
    ]
  },
  &quot;exports&quot;: {
    &quot;.&quot;: &quot;./src/mod.ts&quot;
  }
}</file><file path="deno.lock">{
  &quot;version&quot;: &quot;4&quot;,
  &quot;specifiers&quot;: {
    &quot;jsr:@olli/kvdex@3&quot;: &quot;3.4.0&quot;,
    &quot;jsr:@qnighy/dedent@~0.1.2&quot;: &quot;0.1.2&quot;,
    &quot;jsr:@std/assert@1&quot;: &quot;1.0.13&quot;,
    &quot;jsr:@std/assert@^1.0.13&quot;: &quot;1.0.13&quot;,
    &quot;jsr:@std/async@^1.0.13&quot;: &quot;1.0.13&quot;,
    &quot;jsr:@std/bytes@^1.0.4&quot;: &quot;1.0.6&quot;,
    &quot;jsr:@std/bytes@^1.0.5&quot;: &quot;1.0.6&quot;,
    &quot;jsr:@std/cli@1&quot;: &quot;1.0.19&quot;,
    &quot;jsr:@std/cli@1.0.12&quot;: &quot;1.0.12&quot;,
    &quot;jsr:@std/cli@^1.0.18&quot;: &quot;1.0.19&quot;,
    &quot;jsr:@std/collections@^1.0.9&quot;: &quot;1.1.1&quot;,
    &quot;jsr:@std/data-structures@^1.0.8&quot;: &quot;1.0.8&quot;,
    &quot;jsr:@std/dotenv@~0.225.3&quot;: &quot;0.225.5&quot;,
    &quot;jsr:@std/encoding@^1.0.10&quot;: &quot;1.0.10&quot;,
    &quot;jsr:@std/fmt@^1.0.8&quot;: &quot;1.0.8&quot;,
    &quot;jsr:@std/fs@1&quot;: &quot;1.0.18&quot;,
    &quot;jsr:@std/fs@^1.0.17&quot;: &quot;1.0.18&quot;,
    &quot;jsr:@std/html@^1.0.4&quot;: &quot;1.0.4&quot;,
    &quot;jsr:@std/http@1&quot;: &quot;1.0.17&quot;,
    &quot;jsr:@std/internal@^1.0.6&quot;: &quot;1.0.8&quot;,
    &quot;jsr:@std/internal@^1.0.8&quot;: &quot;1.0.8&quot;,
    &quot;jsr:@std/json@^1.0.2&quot;: &quot;1.0.2&quot;,
    &quot;jsr:@std/jsonc@1&quot;: &quot;1.0.2&quot;,
    &quot;jsr:@std/media-types@^1.1.0&quot;: &quot;1.1.0&quot;,
    &quot;jsr:@std/net@1&quot;: &quot;1.0.4&quot;,
    &quot;jsr:@std/net@^1.0.4&quot;: &quot;1.0.4&quot;,
    &quot;jsr:@std/path@1&quot;: &quot;1.1.0&quot;,
    &quot;jsr:@std/path@^1.1.0&quot;: &quot;1.1.0&quot;,
    &quot;jsr:@std/semver@1&quot;: &quot;1.0.5&quot;,
    &quot;jsr:@std/streams@1&quot;: &quot;1.0.9&quot;,
    &quot;jsr:@std/streams@^1.0.9&quot;: &quot;1.0.9&quot;,
    &quot;jsr:@std/testing@1&quot;: &quot;1.0.13&quot;,
    &quot;jsr:@std/text@1&quot;: &quot;1.0.14&quot;,
    &quot;jsr:@std/ulid@1&quot;: &quot;1.0.0&quot;,
    &quot;jsr:@valibot/valibot@^1.1.0&quot;: &quot;1.1.0&quot;,
    &quot;jsr:@yieldray/json-rpc-ts@~0.2.1&quot;: &quot;0.2.1&quot;,
    &quot;npm:@ai-sdk/anthropic@^1.2.11&quot;: &quot;1.2.12_zod@3.25.28&quot;,
    &quot;npm:@ai-sdk/google-vertex@^2.2.22&quot;: &quot;2.2.23_zod@3.25.28&quot;,
    &quot;npm:@ai-sdk/openai@^1.3.22&quot;: &quot;1.3.22_zod@3.25.28&quot;,
    &quot;npm:@ai-sdk/valibot@~0.1.27&quot;: &quot;0.1.28_@valibot+to-json-schema@1.2.0__valibot@1.1.0_valibot@1.1.0&quot;,
    &quot;npm:ai@^4.3.15&quot;: &quot;4.3.16_zod@3.25.28&quot;,
    &quot;npm:gcp-metadata@6.1.0&quot;: &quot;6.1.0&quot;,
    &quot;npm:gpt-tokenizer@^2.9.0&quot;: &quot;2.9.0&quot;,
    &quot;npm:jsonc-parser@^3.3.1&quot;: &quot;3.3.1&quot;,
    &quot;npm:zod@^3.24.0&quot;: &quot;3.25.28&quot;
  },
  &quot;jsr&quot;: {
    &quot;@olli/kvdex@3.4.0&quot;: {
      &quot;integrity&quot;: &quot;007b1dca50a20f7d036d186fb24875ce2eb19d9c0b3a32878edc1d0e8181aa9a&quot;,
      &quot;dependencies&quot;: [
        &quot;jsr:@std/bytes@^1.0.4&quot;,
        &quot;jsr:@std/cli@1.0.12&quot;,
        &quot;jsr:@std/collections&quot;,
        &quot;jsr:@std/ulid&quot;,
        &quot;npm:zod&quot;
      ]
    },
    &quot;@qnighy/dedent@0.1.2&quot;: {
      &quot;integrity&quot;: &quot;9e420cff5b0082dba168385c9dfc56f25ef9a07999605e5fc9bc2058529998ee&quot;
    },
    &quot;@std/assert@1.0.13&quot;: {
      &quot;integrity&quot;: &quot;ae0d31e41919b12c656c742b22522c32fb26ed0cba32975cb0de2a273cb68b29&quot;,
      &quot;dependencies&quot;: [
        &quot;jsr:@std/internal@^1.0.6&quot;
      ]
    },
    &quot;@std/async@1.0.13&quot;: {
      &quot;integrity&quot;: &quot;1d76ca5d324aef249908f7f7fe0d39aaf53198e5420604a59ab5c035adc97c96&quot;
    },
    &quot;@std/bytes@1.0.6&quot;: {
      &quot;integrity&quot;: &quot;f6ac6adbd8ccd99314045f5703e23af0a68d7f7e58364b47d2c7f408aeb5820a&quot;
    },
    &quot;@std/cli@1.0.12&quot;: {
      &quot;integrity&quot;: &quot;e5cfb7814d189da174ecd7a34fbbd63f3513e24a1b307feb2fcd5da47a070d90&quot;
    },
    &quot;@std/cli@1.0.19&quot;: {
      &quot;integrity&quot;: &quot;b3601a54891f89f3f738023af11960c4e6f7a45dc76cde39a6861124cba79e88&quot;
    },
    &quot;@std/collections@1.1.1&quot;: {
      &quot;integrity&quot;: &quot;eff6443fbd9d5a6697018fb39c5d13d5f662f0045f21392d640693d0008ab2af&quot;
    },
    &quot;@std/data-structures@1.0.8&quot;: {
      &quot;integrity&quot;: &quot;2fb7219247e044c8fcd51341788547575653c82ae2c759ff209e0263ba7d9b66&quot;
    },
    &quot;@std/dotenv@0.225.5&quot;: {
      &quot;integrity&quot;: &quot;9ce6f9d0ec3311f74a32535aa1b8c62ed88b1ab91b7f0815797d77a6f60c922f&quot;
    },
    &quot;@std/encoding@1.0.10&quot;: {
      &quot;integrity&quot;: &quot;8783c6384a2d13abd5e9e87a7ae0520a30e9f56aeeaa3bdf910a3eaaf5c811a1&quot;
    },
    &quot;@std/fmt@1.0.8&quot;: {
      &quot;integrity&quot;: &quot;71e1fc498787e4434d213647a6e43e794af4fd393ef8f52062246e06f7e372b7&quot;
    },
    &quot;@std/fs@1.0.18&quot;: {
      &quot;integrity&quot;: &quot;24bcad99eab1af4fde75e05da6e9ed0e0dce5edb71b7e34baacf86ffe3969f3a&quot;,
      &quot;dependencies&quot;: [
        &quot;jsr:@std/path@^1.1.0&quot;
      ]
    },
    &quot;@std/html@1.0.4&quot;: {
      &quot;integrity&quot;: &quot;eff3497c08164e6ada49b7f81a28b5108087033823153d065e3f89467dd3d50e&quot;
    },
    &quot;@std/http@1.0.17&quot;: {
      &quot;integrity&quot;: &quot;98aec8ab4080d95c21f731e3008f69c29c5012d12f1b4e553f85935db601569f&quot;,
      &quot;dependencies&quot;: [
        &quot;jsr:@std/cli@^1.0.18&quot;,
        &quot;jsr:@std/encoding&quot;,
        &quot;jsr:@std/fmt&quot;,
        &quot;jsr:@std/html&quot;,
        &quot;jsr:@std/media-types&quot;,
        &quot;jsr:@std/net@^1.0.4&quot;,
        &quot;jsr:@std/path@^1.1.0&quot;,
        &quot;jsr:@std/streams@^1.0.9&quot;
      ]
    },
    &quot;@std/internal@1.0.8&quot;: {
      &quot;integrity&quot;: &quot;fc66e846d8d38a47cffd274d80d2ca3f0de71040f855783724bb6b87f60891f5&quot;
    },
    &quot;@std/json@1.0.2&quot;: {
      &quot;integrity&quot;: &quot;d9e5497801c15fb679f55a2c01c7794ad7a5dfda4dd1bebab5e409cb5e0d34d4&quot;
    },
    &quot;@std/jsonc@1.0.2&quot;: {
      &quot;integrity&quot;: &quot;909605dae3af22bd75b1cbda8d64a32cf1fd2cf6efa3f9e224aba6d22c0f44c7&quot;,
      &quot;dependencies&quot;: [
        &quot;jsr:@std/json&quot;
      ]
    },
    &quot;@std/media-types@1.1.0&quot;: {
      &quot;integrity&quot;: &quot;c9d093f0c05c3512932b330e3cc1fe1d627b301db33a4c2c2185c02471d6eaa4&quot;
    },
    &quot;@std/net@1.0.4&quot;: {
      &quot;integrity&quot;: &quot;2f403b455ebbccf83d8a027d29c5a9e3a2452fea39bb2da7f2c04af09c8bc852&quot;
    },
    &quot;@std/path@1.1.0&quot;: {
      &quot;integrity&quot;: &quot;ddc94f8e3c275627281cbc23341df6b8bcc874d70374f75fec2533521e3d6886&quot;
    },
    &quot;@std/semver@1.0.5&quot;: {
      &quot;integrity&quot;: &quot;529f79e83705714c105ad0ba55bec0f9da0f24d2f726b6cc1c15e505cc2c0624&quot;
    },
    &quot;@std/streams@1.0.9&quot;: {
      &quot;integrity&quot;: &quot;a9d26b1988cdd7aa7b1f4b51e1c36c1557f3f252880fa6cc5b9f37078b1a5035&quot;,
      &quot;dependencies&quot;: [
        &quot;jsr:@std/bytes@^1.0.5&quot;
      ]
    },
    &quot;@std/testing@1.0.13&quot;: {
      &quot;integrity&quot;: &quot;74418be16f627dfe996937ab0ffbdbda9c1f35534b78724658d981492f121e71&quot;,
      &quot;dependencies&quot;: [
        &quot;jsr:@std/assert@^1.0.13&quot;,
        &quot;jsr:@std/data-structures&quot;,
        &quot;jsr:@std/fs@^1.0.17&quot;,
        &quot;jsr:@std/internal@^1.0.8&quot;,
        &quot;jsr:@std/path@^1.1.0&quot;
      ]
    },
    &quot;@std/text@1.0.14&quot;: {
      &quot;integrity&quot;: &quot;1a810108482414d19112b8b506ad0b7cba826000cd13f74274ffda6dd83d273f&quot;
    },
    &quot;@std/ulid@1.0.0&quot;: {
      &quot;integrity&quot;: &quot;d41c3d27a907714413649fee864b7cde8d42ee68437d22b79d5de4f81d808780&quot;
    },
    &quot;@valibot/valibot@1.1.0&quot;: {
      &quot;integrity&quot;: &quot;2617f02b532011b8140926899d420a3e1bbb0fcb7cdf8e7b669df89e7edd7f5f&quot;
    },
    &quot;@yieldray/json-rpc-ts@0.2.1&quot;: {
      &quot;integrity&quot;: &quot;127414945bc3e202086b56f46dec02b45f2258165b68c6d1f4bc97c15b132004&quot;
    }
  },
  &quot;npm&quot;: {
    &quot;@ai-sdk/anthropic@1.2.12_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-YSzjlko7JvuiyQFmI9RN1tNZdEiZxc+6xld/0tq/VkJaHpEzGAb1yiNxxvmYVcjvfu/PcvCxAAYXmTYQQ63IHQ==&quot;,
      &quot;dependencies&quot;: [
        &quot;@ai-sdk/provider&quot;,
        &quot;@ai-sdk/provider-utils&quot;,
        &quot;zod&quot;
      ]
    },
    &quot;@ai-sdk/google-vertex@2.2.23_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-q8rOXqEYBOTcgVW1+QlkYEd+bP1ZWfRYhRs3QzzAL1SP3AQqltuKM7ovO53AFDq5hwlodFMHQ4v9WmXmibgjAg==&quot;,
      &quot;dependencies&quot;: [
        &quot;@ai-sdk/anthropic&quot;,
        &quot;@ai-sdk/google&quot;,
        &quot;@ai-sdk/provider&quot;,
        &quot;@ai-sdk/provider-utils&quot;,
        &quot;google-auth-library&quot;,
        &quot;zod&quot;
      ]
    },
    &quot;@ai-sdk/google@1.2.18_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-8B70+i+uB12Ae6Sn6B9Oc6W0W/XorGgc88Nx0pyUrcxFOdytHBaAVhTPqYsO3LLClfjYN8pQ9GMxd5cpGEnUcA==&quot;,
      &quot;dependencies&quot;: [
        &quot;@ai-sdk/provider&quot;,
        &quot;@ai-sdk/provider-utils&quot;,
        &quot;zod&quot;
      ]
    },
    &quot;@ai-sdk/openai@1.3.22_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-QwA+2EkG0QyjVR+7h6FE7iOu2ivNqAVMm9UJZkVxxTk5OIq5fFJDTEI/zICEMuHImTTXR2JjsL6EirJ28Jc4cw==&quot;,
      &quot;dependencies&quot;: [
        &quot;@ai-sdk/provider&quot;,
        &quot;@ai-sdk/provider-utils&quot;,
        &quot;zod&quot;
      ]
    },
    &quot;@ai-sdk/provider-utils@2.2.8_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-fqhG+4sCVv8x7nFzYnFo19ryhAa3w096Kmc3hWxMQfW/TubPOmt3A6tYZhl4mUfQWWQMsuSkLrtjlWuXBVSGQA==&quot;,
      &quot;dependencies&quot;: [
        &quot;@ai-sdk/provider&quot;,
        &quot;nanoid&quot;,
        &quot;secure-json-parse&quot;,
        &quot;zod&quot;
      ]
    },
    &quot;@ai-sdk/provider@1.1.3&quot;: {
      &quot;integrity&quot;: &quot;sha512-qZMxYJ0qqX/RfnuIaab+zp8UAeJn/ygXXAffR5I4N0n1IrvA6qBsjc8hXLmBiMV2zoXlifkacF7sEFnYnjBcqg==&quot;,
      &quot;dependencies&quot;: [
        &quot;json-schema&quot;
      ]
    },
    &quot;@ai-sdk/react@1.2.12_react@19.1.0_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-jK1IZZ22evPZoQW3vlkZ7wvjYGYF+tRBKXtrcolduIkQ/m/sOAVcVeVDUDvh1T91xCnWCdUGCPZg2avZ90mv3g==&quot;,
      &quot;dependencies&quot;: [
        &quot;@ai-sdk/provider-utils&quot;,
        &quot;@ai-sdk/ui-utils&quot;,
        &quot;react&quot;,
        &quot;swr&quot;,
        &quot;throttleit&quot;,
        &quot;zod&quot;
      ]
    },
    &quot;@ai-sdk/ui-utils@1.2.11_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-3zcwCc8ezzFlwp3ZD15wAPjf2Au4s3vAbKsXQVyhxODHcmu0iyPO2Eua6D/vicq/AUm/BAo60r97O6HU+EI0+w==&quot;,
      &quot;dependencies&quot;: [
        &quot;@ai-sdk/provider&quot;,
        &quot;@ai-sdk/provider-utils&quot;,
        &quot;zod&quot;,
        &quot;zod-to-json-schema&quot;
      ]
    },
    &quot;@ai-sdk/valibot@0.1.28_@valibot+to-json-schema@1.2.0__valibot@1.1.0_valibot@1.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-GalY68g0kcHSviMhb61VRQKy07AzeT7x/wDatxQubOjdmAAFTQt6QPmQm8uuOR6YOKpUzEPO1+kqNoDYo4ZghA==&quot;,
      &quot;dependencies&quot;: [
        &quot;@valibot/to-json-schema&quot;,
        &quot;ai&quot;,
        &quot;valibot&quot;
      ]
    },
    &quot;@opentelemetry/api@1.9.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-3giAOQvZiH5F9bMlMiv8+GSPMeqg0dbaeo58/0SlA9sxSqZhnUtxzX9/2FzyhS9sWQf5S0GJE0AKBrFqjpeYcg==&quot;
    },
    &quot;@types/diff-match-patch@1.0.36&quot;: {
      &quot;integrity&quot;: &quot;sha512-xFdR6tkm0MWvBfO8xXCSsinYxHcqkQUlcHeSpMC2ukzOb6lwQAfDmW+Qt0AvlGd8HpsS28qKsB+oPeJn9I39jg==&quot;
    },
    &quot;@valibot/to-json-schema@1.2.0_valibot@1.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-vNPg/esuEAUFaJoyNdnKLEIIRL0LndRyFD3eJR2itwLGr3hH3X8q17Yo84dkyDfZBR8WetHto/5K2OYlyQUUYQ==&quot;,
      &quot;dependencies&quot;: [
        &quot;valibot&quot;
      ]
    },
    &quot;agent-base@7.1.3&quot;: {
      &quot;integrity&quot;: &quot;sha512-jRR5wdylq8CkOe6hei19GGZnxM6rBGwFl3Bg0YItGDimvjGtAvdZk4Pu6Cl4u4Igsws4a1fd1Vq3ezrhn4KmFw==&quot;
    },
    &quot;ai@4.3.16_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-KUDwlThJ5tr2Vw0A1ZkbDKNME3wzWhuVfAOwIvFUzl1TPVDFAXDFTXio3p+jaKneB+dKNCvFFlolYmmgHttG1g==&quot;,
      &quot;dependencies&quot;: [
        &quot;@ai-sdk/provider&quot;,
        &quot;@ai-sdk/provider-utils&quot;,
        &quot;@ai-sdk/react&quot;,
        &quot;@ai-sdk/ui-utils&quot;,
        &quot;@opentelemetry/api&quot;,
        &quot;jsondiffpatch&quot;,
        &quot;zod&quot;
      ]
    },
    &quot;base64-js@1.5.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==&quot;
    },
    &quot;bignumber.js@9.3.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-EM7aMFTXbptt/wZdMlBv2t8IViwQL+h6SLHosp8Yf0dqJMTnY6iL32opnAB6kAdL0SZPuvcAzFr31o0c/R3/RA==&quot;
    },
    &quot;buffer-equal-constant-time@1.0.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==&quot;
    },
    &quot;chalk@5.4.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-zgVZuo2WcZgfUEmsn6eO3kINexW8RAE4maiQ8QNs8CtpPCSyMiYsULR3HQYkm3w8FIA3SberyMJMSldGsW+U3w==&quot;
    },
    &quot;debug@4.4.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==&quot;,
      &quot;dependencies&quot;: [
        &quot;ms&quot;
      ]
    },
    &quot;dequal@2.0.3&quot;: {
      &quot;integrity&quot;: &quot;sha512-0je+qPKHEMohvfRTCEo3CrPG6cAzAYgmzKyxRiYSSDkS6eGJdyVJm7WaYA5ECaAD9wLB2T4EEeymA5aFVcYXCA==&quot;
    },
    &quot;diff-match-patch@1.0.5&quot;: {
      &quot;integrity&quot;: &quot;sha512-IayShXAgj/QMXgB0IWmKx+rOPuGMhqm5w6jvFxmVenXKIzRqTAAsbBPT3kWQeGANj3jGgvcvv4yK6SxqYmikgw==&quot;
    },
    &quot;ecdsa-sig-formatter@1.0.11&quot;: {
      &quot;integrity&quot;: &quot;sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==&quot;,
      &quot;dependencies&quot;: [
        &quot;safe-buffer&quot;
      ]
    },
    &quot;extend@3.0.2&quot;: {
      &quot;integrity&quot;: &quot;sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==&quot;
    },
    &quot;gaxios@6.7.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-LDODD4TMYx7XXdpwxAVRAIAuB0bzv0s+ywFonY46k126qzQHT9ygyoa9tncmOiQmmDrik65UYsEkv3lbfqQ3yQ==&quot;,
      &quot;dependencies&quot;: [
        &quot;extend&quot;,
        &quot;https-proxy-agent&quot;,
        &quot;is-stream&quot;,
        &quot;node-fetch&quot;,
        &quot;uuid&quot;
      ]
    },
    &quot;gcp-metadata@6.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-Jh/AIwwgaxan+7ZUUmRLCjtchyDiqh4KjBJ5tW3plBZb5iL/BPcso8A5DlzeD9qlw0duCamnNdpFjxwaT0KyKg==&quot;,
      &quot;dependencies&quot;: [
        &quot;gaxios&quot;,
        &quot;json-bigint&quot;
      ]
    },
    &quot;google-auth-library@9.15.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-Jb6Z0+nvECVz+2lzSMt9u98UsoakXxA2HGHMCxh+so3n90XgYWkq5dur19JAJV7ONiJY22yBTyJB1TSkvPq9Ng==&quot;,
      &quot;dependencies&quot;: [
        &quot;base64-js&quot;,
        &quot;ecdsa-sig-formatter&quot;,
        &quot;gaxios&quot;,
        &quot;gcp-metadata&quot;,
        &quot;gtoken&quot;,
        &quot;jws&quot;
      ]
    },
    &quot;gpt-tokenizer@2.9.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-YSpexBL/k4bfliAzMrRqn3M6+it02LutVyhVpDeMKrC/O9+pCe/5s8U2hYKa2vFLD5/vHhsKc8sOn/qGqII8Kg==&quot;
    },
    &quot;gtoken@7.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-pCcEwRi+TKpMlxAQObHDQ56KawURgyAf6jtIY046fJ5tIv3zDe/LEIubckAO8fj6JnAxLdmWkUfNyulQ2iKdEw==&quot;,
      &quot;dependencies&quot;: [
        &quot;gaxios&quot;,
        &quot;jws&quot;
      ]
    },
    &quot;https-proxy-agent@7.0.6&quot;: {
      &quot;integrity&quot;: &quot;sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==&quot;,
      &quot;dependencies&quot;: [
        &quot;agent-base&quot;,
        &quot;debug&quot;
      ]
    },
    &quot;is-stream@2.0.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==&quot;
    },
    &quot;json-bigint@1.0.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-SiPv/8VpZuWbvLSMtTDU8hEfrZWg/mH/nV/b4o0CYbSxu1UIQPLdwKOCIyLQX+VIPO5vrLX3i8qtqFyhdPSUSQ==&quot;,
      &quot;dependencies&quot;: [
        &quot;bignumber.js&quot;
      ]
    },
    &quot;json-schema@0.4.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-es94M3nTIfsEPisRafak+HDLfHXnKBhV3vU5eqPcS3flIWqcxJWgXHXiey3YrpaNsanY5ei1VoYEbOzijuq9BA==&quot;
    },
    &quot;jsonc-parser@3.3.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-HUgH65KyejrUFPvHFPbqOY0rsFip3Bo5wb4ngvdi1EpCYWUQDC5V+Y7mZws+DLkr4M//zQJoanu1SP+87Dv1oQ==&quot;
    },
    &quot;jsondiffpatch@0.6.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-3QItJOXp2AP1uv7waBkao5nCvhEv+QmJAd38Ybq7wNI74Q+BBmnLn4EDKz6yI9xGAIQoUF87qHt+kc1IVxB4zQ==&quot;,
      &quot;dependencies&quot;: [
        &quot;@types/diff-match-patch&quot;,
        &quot;chalk&quot;,
        &quot;diff-match-patch&quot;
      ]
    },
    &quot;jwa@2.0.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-hRF04fqJIP8Abbkq5NKGN0Bbr3JxlQ+qhZufXVr0DvujKy93ZCbXZMHDL4EOtodSbCWxOqR8MS1tXA5hwqCXDg==&quot;,
      &quot;dependencies&quot;: [
        &quot;buffer-equal-constant-time&quot;,
        &quot;ecdsa-sig-formatter&quot;,
        &quot;safe-buffer&quot;
      ]
    },
    &quot;jws@4.0.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-KDncfTmOZoOMTFG4mBlG0qUIOlc03fmzH+ru6RgYVZhPkyiy/92Owlt/8UEN+a4TXR1FQetfIpJE8ApdvdVxTg==&quot;,
      &quot;dependencies&quot;: [
        &quot;jwa&quot;,
        &quot;safe-buffer&quot;
      ]
    },
    &quot;ms@2.1.3&quot;: {
      &quot;integrity&quot;: &quot;sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==&quot;
    },
    &quot;nanoid@3.3.11&quot;: {
      &quot;integrity&quot;: &quot;sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==&quot;
    },
    &quot;node-fetch@2.7.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==&quot;,
      &quot;dependencies&quot;: [
        &quot;whatwg-url&quot;
      ]
    },
    &quot;react@19.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg==&quot;
    },
    &quot;safe-buffer@5.2.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==&quot;
    },
    &quot;secure-json-parse@2.7.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-6aU+Rwsezw7VR8/nyvKTx8QpWH9FrcYiXXlqC4z5d5XQBDRqtbfsRjnwGyqbi3gddNtWHuEk9OANUotL26qKUw==&quot;
    },
    &quot;swr@2.3.3_react@19.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-dshNvs3ExOqtZ6kJBaAsabhPdHyeY4P2cKwRCniDVifBMoG/SVI7tfLWqPXriVspf2Rg4tPzXJTnwaihIeFw2A==&quot;,
      &quot;dependencies&quot;: [
        &quot;dequal&quot;,
        &quot;react&quot;,
        &quot;use-sync-external-store&quot;
      ]
    },
    &quot;throttleit@2.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-nt6AMGKW1p/70DF/hGBdJB57B8Tspmbp5gfJ8ilhLnt7kkr2ye7hzD6NVG8GGErk2HWF34igrL2CXmNIkzKqKw==&quot;
    },
    &quot;tr46@0.0.3&quot;: {
      &quot;integrity&quot;: &quot;sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==&quot;
    },
    &quot;use-sync-external-store@1.5.0_react@19.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-Rb46I4cGGVBmjamjphe8L/UnvJD+uPPtTkNvX5mZgqdbavhI4EbgIWJiIHXJ8bc/i9EQGPRh4DwEURJ552Do0A==&quot;,
      &quot;dependencies&quot;: [
        &quot;react&quot;
      ]
    },
    &quot;uuid@9.0.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-b+1eJOlsR9K8HJpow9Ok3fiWOWSIcIzXodvv0rQjVoOVNpWMpxf1wZNpt4y9h10odCNrqnYp1OBzRktckBe3sA==&quot;
    },
    &quot;valibot@1.1.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-Nk8lX30Qhu+9txPYTwM0cFlWLdPFsFr6LblzqIySfbZph9+BFsAHsNvHOymEviUepeIW6KFHzpX8TKhbptBXXw==&quot;
    },
    &quot;webidl-conversions@3.0.1&quot;: {
      &quot;integrity&quot;: &quot;sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==&quot;
    },
    &quot;whatwg-url@5.0.0&quot;: {
      &quot;integrity&quot;: &quot;sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==&quot;,
      &quot;dependencies&quot;: [
        &quot;tr46&quot;,
        &quot;webidl-conversions&quot;
      ]
    },
    &quot;zod-to-json-schema@3.24.5_zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-/AuWwMP+YqiPbsJx5D6TfgRTc4kTLjsh5SOcd4bLsfUg2RcEXrFMJl1DGgdHy2aCfsIA/cr/1JM0xcB2GZji8g==&quot;,
      &quot;dependencies&quot;: [
        &quot;zod&quot;
      ]
    },
    &quot;zod@3.25.28&quot;: {
      &quot;integrity&quot;: &quot;sha512-/nt/67WYKnr5by3YS7LroZJbtcCBurDKKPBPWWzaxvVCGuG/NOsiKkrjoOhI8mJ+SQUXEbUzeB3S+6XDUEEj7Q==&quot;
    }
  },
  &quot;workspace&quot;: {
    &quot;dependencies&quot;: [
      &quot;jsr:@olli/kvdex@3&quot;,
      &quot;jsr:@qnighy/dedent@~0.1.2&quot;,
      &quot;jsr:@std/assert@1&quot;,
      &quot;jsr:@std/async@^1.0.13&quot;,
      &quot;jsr:@std/cli@1&quot;,
      &quot;jsr:@std/dotenv@~0.225.3&quot;,
      &quot;jsr:@std/fmt@^1.0.8&quot;,
      &quot;jsr:@std/fs@1&quot;,
      &quot;jsr:@std/http@1&quot;,
      &quot;jsr:@std/jsonc@1&quot;,
      &quot;jsr:@std/net@1&quot;,
      &quot;jsr:@std/path@1&quot;,
      &quot;jsr:@std/semver@1&quot;,
      &quot;jsr:@std/streams@1&quot;,
      &quot;jsr:@std/testing@1&quot;,
      &quot;jsr:@std/text@1&quot;,
      &quot;jsr:@valibot/valibot@^1.1.0&quot;,
      &quot;jsr:@yieldray/json-rpc-ts@~0.2.1&quot;,
      &quot;npm:@ai-sdk/anthropic@^1.2.11&quot;,
      &quot;npm:@ai-sdk/google-vertex@^2.2.22&quot;,
      &quot;npm:@ai-sdk/openai@^1.3.22&quot;,
      &quot;npm:@ai-sdk/valibot@~0.1.27&quot;,
      &quot;npm:ai@^4.3.15&quot;,
      &quot;npm:gcp-metadata@6.1.0&quot;,
      &quot;npm:gpt-tokenizer@^2.9.0&quot;,
      &quot;npm:jsonc-parser@^3.3.1&quot;
    ]
  }
}</file><file path="repomix.config.json">{
  &quot;$schema&quot;: &quot;https://repomix.com/schemas/latest/schema.json&quot;,
  // Configures input file handling for Repomix.
  &quot;input&quot;: {
    // Specifies the maximum size in bytes for an individual file to be processed. Files exceeding this size will be excluded.
    // Default: 52428800 (50MB)
    &quot;maxFileSize&quot;: 1048576
  },
  &quot;app&quot;: {
    &quot;name&quot;: &quot;hypermix&quot;
  },
  // Configures the output generated by Repomix.
  &quot;output&quot;: {
    // Custom text to prepend to the output file, often used for context or instructions for AI models.
    &quot;headerText&quot;: &quot;CRITICAL: This contains a snapshot of the entire codebase. It was manually generated and may be slightly out of date and/or inaccurate. It can be generated again with the command `hypermix`&quot;,
    // If true, includes a summary section in the output, which may contain file overviews and directory structures.
    &quot;summary&quot;: true,
    // If true, enables code compression using Tree-sitter to reduce token count while aiming to preserve structural code elements. Corresponds to the CLI option: --compress.
    &quot;compress&quot;: false,
    // If true, formats the output in a style that is more easily parsable by machines or specific AI tools, potentially using structured tags more extensively.
    &quot;parsableStyle&quot;: true,
    // If true, includes a summary of files (e.g., names, paths, token counts) in the output.
    &quot;fileSummary&quot;: true,
    // If true, includes a representation of the repository&apos;s directory structure in the output.
    &quot;directoryStructure&quot;: true,
    // If true, includes the actual content of the processed files in the output.
    &quot;files&quot;: true,
    // If true, attempts to remove comments from the code included in the output.
    &quot;removeComments&quot;: false,
    // If true, attempts to remove empty lines from the code included in the output.
    &quot;removeEmptyLines&quot;: true,
    // Specifies the number of files to list in summaries that rank files (e.g., by size or git changes, if applicable).
    &quot;topFilesLength&quot;: 15,
    // If true, includes line numbers alongside the code in the output.
    &quot;showLineNumbers&quot;: true,
    // If true, attempts to copy the generated output content to the system clipboard upon completion.
    &quot;copyToClipboard&quot;: false,
    // Configuration settings specific to Git integration.
    &quot;git&quot;: {
      // If true, files in the output can be sorted based on their recent Git change activity.
      &quot;sortByChanges&quot;: true,
      // When sortByChanges is enabled, this limits the number of commits scanned to determine change frequency.
      &quot;sortByChangesMaxCommits&quot;: 100,
      // If true, includes Git diff information in the output, where applicable.
      &quot;includeDiffs&quot;: false
    }
  },
  // An array of glob patterns specifying which files and directories to explicitly include. Corresponds to the --include CLI parameter.
  &quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;README.md&quot;, &quot;examples/**/**&quot;],
  // Configures patterns for ignoring files and directories.
  &quot;ignore&quot;: {
    // If true, Repomix will respect rules defined in the project&apos;s .gitignore file.
    &quot;useGitignore&quot;: false,
    // If true, Repomix applies a set of default ignore patterns (e.g., for .git, node_modules).
    &quot;useDefaultPatterns&quot;: true,
    // An array of custom glob patterns for files and directories that should be excluded from processing.
    &quot;customPatterns&quot;: []
  },
  // Configures security-related features.
  &quot;security&quot;: {
    // If true, enables security checks, such as using Secretlint to detect potential secrets or sensitive information in the codebase.
    &quot;enableSecurityCheck&quot;: true
  },
  // Configures token counting for understanding LLM context window usage.
  &quot;tokenCount&quot;: {
    // Specifies the encoding model used for token counting (e.g., &apos;o200k_base&apos; for newer OpenAI models).
    &quot;encoding&quot;: &quot;o200k_base&quot;
  }
}</file><file path=".gitignore"># Build output
dist/
bin/
.hypermix/

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of &apos;npm pack&apos;
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# AI context files
.hypermix/**/*.xml</file><file path="LICENSE">MIT License

Copyright (c) 2025 Zachary Iles

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</file><file path="README.md"># Hypermix

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;logo.png&quot; alt=&quot;Hypermix Logo&quot; height=&quot;300&quot;&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;i&gt;Repomix for agentic power-users&lt;/i&gt;&lt;/br&gt;&lt;/br&gt;
    &lt;b&gt;Real-time, token-aware, intelligent repomixing of your codebase and all dependencies. Auto-integrations for Cursor, Claude, and Windsurf that maintain the mixes configures rules and a tool for your agent to get the most out of your mixes.&lt;/b&gt;
  &lt;/div&gt;&lt;/br&gt;
  &lt;p&gt;
    &lt;a href=&quot;https://github.com/zackiles/hypermix/actions/workflows/release-github.yml&quot;&gt;
      &lt;img src=&quot;https://github.com/zackiles/hypermix/actions/workflows/release-github.yml/badge.svg&quot; alt=&quot;Release&quot;&gt;
    &lt;/a&gt;
  &lt;/p&gt;
&lt;/div&gt;

## Why

`deno run -A mod.ts [flags]`... and everything is handled for you seamlessly. Build context files with intelligent token-awareness and code analytics. Auto-integrates with Cursor, Claude, and other tools for enhanced AI interactions.

## How

Hypermix uses repomix to build context files for AI tools, automatically managing integration with various development environments. It supports:

- **Token counting:** Tracks token usage across context files to optimize AI context windows
- **Project integration:** Automatically adds tasks to package.json, deno.json, Makefiles, and more
- **IDE configuration:** Sets up VS Code tasks and integrates with Cursor
- **Intelligent ignores:** Automatically updates .gitignore, .cursorignore, and .cursorignoreindex

&gt; [!TIP]
&gt; Check out some examples of [When To Use It](#when-to-use-it).

## Installation

Run hypermix directly with Deno:

```bash
deno run -A mod.ts [flags]
```

## Usage

**Run hypermix with flags:**

```bash
deno run -A mod.ts
```

Builds context files for your codebase and configured repositories, with intelligent token counting.

**Available flags:**

```
--output-path, -o  Override the default output directory for all context files
                   Example: deno run -A mod.ts --output-path ./custom/path
--silent, -s       Suppress all output except errors
```

The script also passes through flags to the underlying repomix tool, which are configured in the configs array within the script. These include:

- Repository configurations (remote, include patterns, ignore patterns)
- Output paths for context files
- Repomix configuration options

**Use from your project task runner:**

Once integrated into your project, you can simply run:

```bash
# For npm/yarn projects
npm run hypermix

# For deno projects
deno task hypermix

# For Makefile projects
make hypermix
```

&gt; [!IMPORTANT]
&gt; Your .gitignore and .cursorignore files will be automatically updated to handle the generated context files properly.

## Cursor Integration

Hypermix works seamlessly with Cursor IDE:

- Prevents context pollution by configuring .cursorignoreindex
- Ensures context files are accessible when needed with .cursorignore
- Sets up IDE tasks for quick access to hypermix commands

## Token Awareness

Hypermix tracks token usage across all context files:

- Reports token counts per file and total usage
- Warns when files exceed recommended token limits
- Optimizes context files to stay within model token windows
- Provides streaming token counting for large files

## Configuring Mixes

Hypermix builds context by processing a `mixes` array, typically defined in a `hypermix.config.js/ts` (or `.json/c`) file. Each object in this array defines a single context-building task. There are two main ways to configure a mix item, which are mutually exclusive:

### 1. Remote Repository Mix

This type of mix fetches code from a specified remote GitHub repository.

- **`remote`**:
  - **Type**: `string`
  - **Required**: Yes
  - **Description**: The GitHub repository URL in `owner/repo` format (e.g., `denoland/std`).

- **`include`**:
  - **Type**: `string[]`
  - **Required**: No
  - **Description**: An array of glob patterns for files/directories to include (e.g., `[&apos;src/**/*.ts&apos;, &apos;README.md&apos;]`). Defaults to `**/*` (all files).

- **`ignore`**:
  - **Type**: `string[]`
  - **Required**: No
  - **Description**: An array of glob patterns to exclude files/directories (e.g., `[&apos;**/test_data/**&apos;]`).

- **`output`**:
  - **Type**: `string`
  - **Required**: No
  - **Description**: Custom output path for the generated XML file, relative to the global `outputPath`. If omitted, a path is derived from the remote URL (e.g., `owner/repo.xml`).

- **`extraFlags`**:
  - **Type**: `string[]`
  - **Required**: No
  - **Description**: An array of additional boolean command-line flags to pass to `repomix` (e.g., `[&apos;--compress&apos;]`).

### 2. Local Repomix Configuration Mix

This type of mix uses an existing `repomix.config.json` file to define the context building rules, typically for your local project codebase.

- **`config`** or **`repomixConfig`**:
  - **Type**: `string`
  - **Required**: Yes
  - **Description**: Path to your `repomix.config.json` file (e.g., `&apos;./repomix.config.json&apos;`).

- **`extraFlags`**:
  - **Type**: `string[]`
  - **Required**: No
  - **Description**: An array of additional boolean command-line flags to pass to `repomix` (e.g., `[&apos;--quiet&apos;]`). Other options like `include`, `ignore`, and `output` are typically defined within the referenced `repomix.config.json` itself.

### Example `hypermix.config.ts`

Here&apos;s how you might structure your `hypermix.config.ts` to include multiple mixes:

```typescript
// hypermix.config.ts
import { join } from &apos;@std/path&apos; // Or your preferred path joining utility

export default {
  silent: false, // Global option: suppress non-error output
  outputPath: &apos;.hypermix&apos;, // Global option: root directory for all generated .xml files
  mixes: [
    // Example of a remote repository mix
    {
      remote: &apos;denoland/std&apos;,
      include: [&apos;fs/**/*.ts&apos;], // Only include files from the fs module
      ignore: [&apos;fs/**/_*.ts&apos;, &apos;fs/**/test*.ts&apos;], // Exclude private and test files
      output: join(&apos;@std&apos;, &apos;fs.xml&apos;), // Custom output path
      extraFlags: [&apos;--compress&apos;], // Compress this specific output
    },
    // Another remote mix, simpler configuration
    {
      remote: &apos;vercel/ai&apos;,
      include: [&apos;packages/ai/core/**/*.ts&apos;],
      output: &apos;vercel-ai-core.xml&apos;,
    },
    // Example of a local mix using an existing repomix.config.json
    {
      repomixConfig: &apos;./repomix.config.json&apos;, // Use local repomix config for the current project
      extraFlags: [&apos;--quiet&apos;], // Pass --quiet to repomix for this local build
    },
    // You can add more remote or local mixes as needed
  ],
}
```

This structure allows for flexible and powerful context aggregation from various sources into a centralized location, tailored to your project&apos;s needs.

## When To Use It

- Enhance AI agent context with comprehensive codebase knowledge
- Optimize token usage across large projects
- Integrate multiple repositories into a unified context
- Provide better context to AI-powered development tools
- Simplify AI integration in complex projects
- Manage context files with intelligent repository mixing

## License

MIT License - see the [LICENSE](LICENSE) file for details.</file></files></repomix>